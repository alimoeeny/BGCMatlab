function errors = ShowErrors(DATA, varargin)%errors = ShowErrors(X)%Print out error messages in a stucutre or file%If X is a directory name, loads Errors.mat and prints%if X is a stucture/cell array, searches recursively for %        errros in the strcuture%  ...,'-all') usually similar errors are not repeated. This shows alltry  %Never need to stop exectuion just because of ShowErrorsstrargs = cell2cellstr(varargin);matcherr = '';j = 1;while j <= length(varargin)    if strcmp(varargin{j},'-match')        j = j+1;        matcherr = varargin{j};    end    j = j+1;enderrors = [];if iscellstr(DATA)    ShowErrorStrings(DATA,varargin{:});    errors = DATA;    return;elseif iscell(DATA)    for j = 1:length(DATA)        errors{j} = ShowErrors(DATA{j},varargin{:});    end    return;elseif ischar(DATA) && isdir(DATA);    name = [DATA '/Errors.mat'];    if exist(name)        X = my.load(name);        errors = ShowErrors(X,varargin{:});    end    return;end        if isfield(DATA,'errs')    idstr = [];    [errs, id] = unique(DATA.errs);    if isfield(DATA, 'errdata')        errdata = DATA.errdata(id);    else        errdata = [];        if isfield(DATA,'ex') && length(DATA.ex) == 1            idstr = sprintf('%sE%d',idstr,DATA.ex);            errors.eid = DATA.ex;        end        if isfield(DATA,'p') && length(DATA.p) == 1            idstr = sprintf('%sP%d',idstr,DATA.p);            errors.probe = DATA.p;        end    end    for j = 1:length(errs)        clear errors;        if ~isempty(errdata)            [idstr, errors(j)] = BuildErrIdstr(errdata(j),errs{j});        end        if ~isempty(idstr)            fprintf('%s ',idstr);        end        cprintf('red','%s\n',deblank(errs{j}));    endelseif isfield(DATA,'Errors')    if isfield(DATA,'name') && isfield(DATA.Errors,'s')        fprintf('Errors for %s\n',DATA.name);    elseif isfield(DATA,'myload') && isfield(DATA.Errors,'s')        fprintf('Errors for %s\n',DATA.myload.name);    end    errors = ShowErrors(DATA.Errors,varargin{:});elseif isfield(DATA,'AllErrs')    ShowErrors(DATA.AllErrs,varargin{:});elseif isfield(DATA,'autofits')    ShowErrors(DATA.autofits);elseif isfield(DATA,'AllErrs')    for j = 1:length(DATA.AllErrs)        fprintf('%s\n',DATA.AllErrs{j});    endelseif isfield(DATA,'s')    clear errors;    if isempty(DATA)        errors = [];        return;    end    [show, nerr, sstr] = CheckErrorList(DATA, matcherr, varargin{:});    if sum(strcmp('-all',strargs))        show = ones(size(show));    end    for j = find(show(:)>0)'            [idstr, errors{j}] = BuildErrIdstr(DATA(j),DATA(j).s);            if ~isempty(idstr)                fprintf('%s ',idstr);            end            if show(j) > 1                xstr = sprintf(' (%d Errors like this)',nerr(show(j)-1));            else                xstr = '';            end            cprintf('red','%s%s\n',DATA(j).s,xstr);    end    if ~isempty(sstr)        cprintf('red','%s\n',sstr);    end    if sum(show) == 0        errors = [];    else           errors = CellToStruct(errors,'flat');    endendif isfield(DATA,'errorlist')    for j = 1:length(DATA.errorlist)        ShowErrors(DATA.errorlist(j));    endendcatch ME    CheckExceptions(ME);endfunction [show, nerr, xstr] = CheckErrorList(DATA, matcherr, varargin)%types lists errors that may happen many times.  Only Show once.types = {'^[0-9]+ Frames in' '^[0-9]+ StimOns before ' 'Expt[0-9]* missing Trial ids' 'Expt[0-9]* Duration varies: 1/'};types = {types{:} 'CH[0-9]+ [0-9]+ blocks end(' 'Name mismatch'};severity = ones(size(types));showall = 0;nerr = zeros(size(types));xstr = '';strargs = cell2cellstr(varargin);if sum(strcmp('severe',strargs)) %turn off trivial warnings    severity(2) = 0;endshow = ones(size(DATA));if sum(strcmp('all',strargs))    showall = 1;endif isfield(DATA,'s')    strs = {DATA.s};elseif iscellstr(DATA)    strs = DATA;else    return;end        for j = 1:length(strs)        errtype = 0;        if isempty(matcherr)            for k = 1:length(types)                if ~isempty(regexp(strs{j},types{k}))                    errtype = k;                    nerr(errtype) = nerr(errtype)+1;                end            end            if errtype == 0                show(j) = 1; %1 = any error not listed in types            elseif nerr(errtype) ==1                show(j) =errtype+1; %so 2 = error of type 1            elseif showall                show(j) = 1;            else                show(j) = 0;            end            if errtype > 0 && severity(errtype) == 0                show(j) = 0;            end            id = regexp(strs{j},'Expt[0-9]* Duration varies: [0-9]+/');            if ~isempty(id)                eid = sscanf(strs{j}(id(1)+4:end),'%d');                id = regexp(strs{j},'Duration varies: [0-9]+/');                ndrop = sscanf(strs{j}(id(1)+17:end),'%d/%d');                drops(eid,:) = ndrop;                if ndrop(1) > 1                    show(j) = -1;                elseif ndrop(1) == 0 %!! should not happen                    show(j) = 1;                    errtype = length(types)+2;                end            end        elseif iscell(matcherr)            show(j) = 0;            for k = 1:length(matcherr)                if ~isempty(regexp(strs{j},matcherr{k}))                    show(j) = 1;                end            end        else            if ~isempty(regexp(DATA(j).s,matcherr))                show(j) = 1;            else                show(j) = 0;            end        end    end    id = find(show ==-1);    if showall        show(id) = 1;    elseif length(id) > 3        show(id) = 0;        id = find(drops(:,1) > 1);        xstr = 'Duration Outliers: ';        for j = 1:length(id)            xstr = sprintf('%s E%d: %d/%d',xstr,id(j),drops(id(j),:));        end              endfunction [idstr, Error] = BuildErrIdstr(E, str)    idstr = '';    if isfield(E,'exptno') && ~isempty(E.exptno)        idstr = sprintf('%sE%d',idstr,E.exptno);        Error.exptno = E.exptno;    elseif isfield(E,'expt')        idstr = sprintf('%sE%d',idstr,E.expt);        Error.exptno = E.expt;    end    if isfield(E,'probe')        idstr = sprintf('%sP%d',idstr,E.probe);        Error.probe = E.probe;end    if isfield(E,'program') && ~isempty(E.program)        idstr = sprintf('%s:%s',idstr,E.program);        Error.program = E.program;    elseif isfield(E,'progname')        idstr = sprintf('%s:%s',idstr,E.progname);        Error.program = E.progname;    end    if isfield(E,'time') %date when error recorded        idstr = sprintf('%s:%s',idstr,datestr(E.time));        Error.time = E.time;    end    if isfield(E,'t') && length(E.t) == 1 %should be time in sec        idstr = sprintf('%s:%.1f',idstr,E.t./10000);        Error.t = E.t;    end    Error.s = str;function DATA = CombineErrors(DATA, X)if ~isfield(X,'errs')    return;endif ~isfield(DATA,'errs')    if isfield(DATA,'errmsg')        DATA.errmsg = {DATA.errmsg{:} X.errs{:}};        DATA.errdata = cat(1,DATA.errdata,X.errdata);    else        DATA.errs = X.errs;        DATA.errdata = X.errdata;    endelse    DATA.errs = {DATA.errs{:} X.errs{:}};    DATA.errdata = cat(1,DATA.errdata,X.errdata);endfunction ShowErrorStrings(S, varargin)strargs = cell2cellstr(varargin);matcherr = '';  %need to process vararg for thisS = unique(S);if isempty(S)    return;endfor j = 1:length(S)    if length(S{j}) > 20        shortS{j} = S{j}(1:end-10);    else        shortS{j} = S{j};    endend[a,b] = Counts(shortS);[shortS,id] = unique(shortS);S = S(id);[show, nerr, sstr] = CheckErrorList(S, matcherr, varargin{:});S = S(find(show>0));show = show(find(show>0));for j = 1:length(S)    aid = find(strcmp(shortS{j},b));       if a(aid) > 1        cprintf('blue','%d errors like %s\n',a(aid),S{j});    elseif show(j) > 1        xstr = sprintf(' (%d Errors like this)',nerr(show(j)-1));        cprintf('red','%s %s\n',S{j},xstr);    else        cprintf('blue','%s\n',S{j});    endendif ~isempty(sstr)    cprintf('red','%s\n',sstr);end