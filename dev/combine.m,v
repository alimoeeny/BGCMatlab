head	1.2;
access;
symbols;
locks
	bgc:1.2; strict;
comment	@// @;


1.2
date	2009.06.17.11.56.27;	author bgc;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.02.21.32.59;	author bgc;	state Exp;
branches;
next	;


desc
@combines expts from Spike 2 Files
@


1.2
log
@before sorting out missing psych trials
@
text
@function out = combine(name, varargin)
%combine(file)
%cuts clusters and combines expts for Spike2 generated matlab data files
%
%

% can't get rid of cluster 2 (M019)
% show cluster colors in time display
% build voltage average for synchronous spikes;
% add checkbox for plotflip
% deleting clusters in AllClusters box

TOPTAG = 'Combiner'; %default
LFP = [];
nextcell = 0;
argon = {};
if length(varargin) & isstruct(varargin{1})
   DATA = varargin{1};
   TOPTAG = DATA.tag.top;
else
    j = 1;
    while j <= length(varargin)
        if isstruct(varargin{j})
        elseif strcmp('Tag',varargin{j})
            TOPTAG = varargin{j+1};
        elseif strncmpi('setprobe',varargin{j},4)
            j = j+1;
            argon = {argon{:} 'setprobe' varargin{j}};
        end
    j = j+1;
    end
end
it = findobj('Tag',TOPTAG);

if isempty(it)
DATA.expstrs = {'dx' 'xo' 'dp' 'dO' 'dxXce' 'sf' 'dxXId' 'or' 'Op' 'Pp' 'sz' 'jv'...
    'orXob' 'orXme' 'szXob' 'DcXor' 'OpXme' 'PpXme' 'co' 'CtfXip' 'tfXip' 'IB' 'backMov' 'backMovXannTyp' 'IBXannTyp' 'dirXme' ...
    'OpXip' 'PpXip' 'me' 'OlXOr' 'ce' 'dxXUs'};
DATA.expnames = {'DT', 'XO', 'DP' 'ODX' 'AC' 'SF' 'ABD' 'OT' 'OP' 'PP' 'SZ' 'VE' ...
    'ORBW' 'OXM' 'SZOB' 'DCOR' 'OPM' 'PPM' 'CO' 'CTFIP' 'TFIP' 'IB' 'Movie' 'MovieANN' 'IB' ....
    'OD' 'OPIP' 'PPIP' 'OD' 'BOP' 'CE' 'UADT'};
DATA.expstrs = {DATA.expstrs{:} 'sfXob' 'sfXme' 'szXme' 'dxXdx' 'dOXdO'};
DATA.spkvarnames = GetSpikeVals(DATA,NaN,NaN,NaN);
DATA.expnames = {DATA.expnames{:} 'SFOB' 'SFM' 'SZM' 'DT' 'ODX'};
    DATA.suffs = 'abcdeghijklmnopqrstuvwxyz';
    DATA.state.recut = 1; %default
    DATA.state.recount = 0;
    DATA.state.plotpsych = 0;
    DATA.state.plotcombined = 0;
    DATA.state.autoplot = 0;
    DATA.state.autolist = 0;
    DATA.state.plotseq  = 0;
    DATA.state.uselfp = 0;
    DATA.state.includeprobename = 0;
    DATA.tag.top = TOPTAG;
    DATA.tag.options = [TOPTAG 'Options'];
    DATA.tag.spikev = [TOPTAG 'SpikeV'];
    DATA.tag.clusterxy = [TOPTAG 'ClusterPlot'];
    DATA.tag.emplot = [TOPTAG 'EM'];
    DATA.tag.lfpplot = [TOPTAG 'LFP'];
    DATA.tag.rcfiga = [TOPTAG 'RCa'];
    DATA.tag.rcfigb= [TOPTAG 'RCb'];
    DATA.tag.showvals= [TOPTAG 'ShowVal'];
    DATA.tag.celllist= [TOPTAG 'CellList'];
    DATA.tag.psych = [TOPTAG 'Psych'];
    colors = mycolors;
    DATA.spkcolor{1} = [0.5 0.5 0.5];
    DATA.spkcolor(2:20) = colors(1:19);
    DATA.tag.dataplot = [TOPTAG 'Combiner'];
    DATA.datafilename = name;
    DATA.wsc= [1 1];
    DATA.defaults.fz = 96;
    DATA.state.fixrange = 0;
    DATA.spooling = 0;
    DATA.densityplot = 0;
    DATA.plot.clusterXrange = [0 10];
    DATA.plot.clusterYrange = [0 1.5];
    DATA.plot.clusterZrange = [0 10];
    DATA.cluster{1,1}.Arange = [6:8];
    DATA.cluster{1,1}.Brange = [11:20];
    DATA.cluster{1,1}.Erange = [1:100];
    DATA.clusterArange = [6:8];
    DATA.clusterBrange = [11:20];
    DATA.clusterErange = [1:100];
    DATA.cluster{1,1}.params = [1 2];
    DATA.cluster{1,1}.autocut = 0;
    DATA.plot.autoscale = 1;
    DATA.state.autofit = 0;
    DATA.state.autonext = 0;
    DATA.state.showspkxy = 0;
    DATA.state.forcebuild = 0;
    DATA.plot.nodc = 1;
    DATA.plot.autoclustermode = 1;
    DATA.test.fastplot = 0;
    DATA.show.sz = 0;
    DATA.show.or = 0;
    DATA.show.jv = 0;
    DATA.show.sf = 0;
    DATA.show.me = 0;
    DATA.show.tf = 0;
    DATA.show.dw = 0;
    DATA.show.Dw=0;
    DATA.show.Dm=0;
    DATA.show.ed = 1;
    DATA.show.Ri = 0;
    DATA.show.ob = 0;
    DATA.show.Ro = 0;
    DATA.show.Fr = 0;
    DATA.show.times = 0;
    DATA.xyfig = 0;
    DATA.optionfig = 0;
    DATA.svfig = 0;
    DATA.plot.showem = 0;
    DATA.plot.showcp = 0;
    DATA.plot.showsync = 0;
    DATA.spikelist = 1;
    DATA.plot.dvdt = 0;
    DATA.minplottime = 0.1;
    DATA.plot.clusterX = 1;
    DATA.plot.clusterY = 2;
    DATA.plot.nmin = 0;
    DATA.plot.nminrc = 0;
    DATA.plot.sdfw = 166;
    DATA.plot.showISI = 0;
    DATA.plot.acov = 0;
    DATA.plot.collapse = 0;
    DATA.plot.flip = 0;
    DATA.plot.bsdelaymax = 5000;
    DATA.plot.setptsize = 0;
    DATA.plot.condenseRC = 1;
    DATA.plot.SpikeMaxV = 5;
    DATA.plot.lfpplot = 0;
    DATA.plot.plotmod = 0;
    DATA.plot.xcorr = 0;
    DATA.plot.addhash = 0;
    DATA.probenames = {'1' '2'};
    DATA.probelist = [5];
    DATA.probe = 5;
    DATA.linesread = 0;
    DATA.currentcluster = 1;
    DATA.state.online = 0;
    DATA.outname = 'tmp.mat';
    DATA.badnames = {};
    DATA.allcombineids = {};
    DATA.fitvals = [];
    DATA.logfid = 0;
    DATA.plot.lfptype = 0;
    DATA.state.scalelfp = 0;
    DATA.state.autoplotallspikes = 0;
    DATA.syncsign = 2;
    DATA.plot.syncoverlay = 1;
    DATA.plot.synccluster = 0;
    load('StdTemplate');
    DATA.Templates = Templates;
    DATA.tag.allprobes = 'AllProbeSpikes';
    DATA.currenttrial = 0;
    DATA.playingspk = 0;
    DATA.state.nospikes = 0;
    DATA.state.optimizeclusters = 0;
    DATA = BuildGUI(DATA);
    DATA.figs.allprobes = 0;
    DATA.plot.emskip = 0;
    DATA.em.stattime = [1500 21000]; %time window to look for saccades
    DATA.em.maxdrift = 0;


    firstcall = 1;
else
    firstcall = 0;
    if length(varargin) & isstruct(varargin{1})
        DATA = varargin{1};
        TOPTAG = DATA.tag.top;
    else
        DATA = get(it,'UserData');
    if isempty(strmatch(TOPTAG,'Combiner','exact'))
        DATA.forcetag = TOPTAG;
    else
        DATA.forcetag = '';  
    end
    end

    set(DATA.toplevel,'Name','Busy......');
    drawnow;
end

if strncmpi(name,'nextcell',5)
    dir = splitpath(DATA.datafilename,'dir');
    if dir > 99
    newdir = num2str(str2num(dir)+1);
    else
        newdir = num2str(str2num(dir)+1,'%.3d');
    end
    name = strrep(DATA.datafilename,dir,newdir);
end

reindex = 0;
recombine = 0;
plotall = 0;
j = 1;
while j <= nargin -1
    if isstruct(varargin{j})
        if isfield(varargin{j},'Trials')
            LFP = varargin{j};
        end
    elseif strncmpi(varargin{j},'plotall',6)
        plotall = 1;
    elseif strncmpi(varargin{j},'recombine',4)
        recombine = 1;
    elseif strncmpi(varargin{j},'relist',4)
        reindex = 1;
    end
    j = j+1;
end



if strncmpi(name,'autocut',6)
    eid = get(DATA.elst,'value');
    for j = 1:length(eid)
        AutoCut(DATA,DATA.expid(eid(j)),eid(j));
    end
elseif strncmpi(name,'autocluster',6)
    eid = get(DATA.elst,'value');
    args = {};
    if DATA.state.optimizeclusters
        args = {args{:} 'minimize'};
    end
    if sum(DATA.plot.useprobe)
        [nr,nc] = Nsubplots(length(DATA.probelist));
        oldprobe = DATA.probe;
        pid = find(DATA.plot.useprobe);
        DATA = GetAllProbeFig(DATA);
        for j = 1:length(eid)
            for k = pid
                DATA.probe = DATA.probelist(k);
                subplot(nr,nc,k);
                DATA = AutoCut(DATA,DATA.expid(eid(j)),eid(j),'cluster',args{:});
            end
        end
        DATA.probe = oldprobe;
    else
    for j = 1:length(eid)
        DATA = AutoCut(DATA,DATA.expid(eid(j)),eid(j),'cluster',args{:});
    end
    end
    DATA.AutoClusters = SaveAutoClusters(DATA);
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'AddProbeList',5)
    AddProbeList(DATA);
    DATA.plot.showsync = 1;
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'fixmains',6)
    load(DATA.datafilename);
    tic;
    if isfield(DATA,'AllSpikes')
        for j = 1:length(DATA.AllSpikes)
        [avg(:,j), DATA.AllSPikes{j}] = FixSpkMains(DATA.AllSpikes{j},Ch24.times.*10000,'fix');
        end
        set(DATA.toplevel,'UserData',DATA);
    else
    avg = FixSpkMains(DATA.AllData.Spikes,Ch24.times.*10000);
    end
    toc
    GetFigure('Mains');
    plot(avg);
elseif strncmpi(name,'plotddf',6)
    eid = get(DATA.elst,'value');
    PlotDDF(DATA);
elseif strncmpi(name,'listexps',6)
    eid = get(DATA.clst,'value');
    if eid(1) > 1
        suff = '';
        it = strmatch(DATA.exptypelist{eid(1)},DATA.expstrs,'exact');
        stimname = strrep(DATA.explist{eid(1)},['.' DATA.exptypelist{eid(1)}],'');
        if strfind(stimname,'RC')
            stimname = strrep(stimname,'RC','');
            suff = 'RC';
        end
        if ~isempty(it)
            expname = DATA.expnames{it};
            if strmatch(expname,'CO','exact') & strmatch(stimname,'square')
                expname = 'FLSH';
            end
            if regexp(DATA.datafilename,'Expt[0-9]*.mat') %online file
                DATA.outname = [DATA.datafilename '/c' num2str(DATA.spikelist(1)) '.' stimname '.' DATA.expnames{it} suff '.mat'];
            else
                DATA.outname = CombinedName(DATA,eid(1),DATA.spikelist(1));
            end
            if exist(DATA.outname,'file')
                GetFigure(DATA.tag.dataplot);
                load(DATA.outname);
                Expt.Header.Name = BuildName(Expt.Header.Name);
                DATA.Expt = Expt;
                args = PlotArgs(DATA, Expt);
                DATA.plotres = PlotExpt(Expt,args{:});
                csuffs = [];
                for j = 1:length(Expt.Header.Combined)
                    csuffs = [csuffs num2str(Expt.Header.Combined(j)) ' '];
                end
               title(sprintf('%s %s ed %.2f',splitpath(DATA.outname),csuffs,GetEval(Expt,'ed')));
            end
        else
            DATA.outname = 'tmp.mat';
        end
    else
            DATA.outname = 'tmp.mat';
    end
    DATA = ListSubExpts(DATA,eid);
    set(DATA.saveitem,'string',DATA.outname);
    set(DATA.toplevel,'UserData',DATA);
    if nargout
        out = DATA;
    end
elseif strncmpi(name,'getexpt',6)
    out = DATA.Expt;
    NotBusy(DATA);
    return;
elseif strncmpi(name,'getstate',6)
    out = DATA;
    NotBusy(DATA);
    return;
elseif strncmpi(name,'checklists',6)
    CheckLists(DATA);
elseif strncmpi(name,'ClearClusters',7)
    eid = DATA.currentexpt;
    nc = CountClusters(DATA.Expts{eid}.Cluster);
    for k = 1:nc;
        for j = 1:size(DATA.Expts{eid}.Cluster,2);
            if ~isempty(DATA.Expts{eid}.Cluster{k,j}) & isfield(DATA.Expts{eid}.Cluster{k,j},'x')
            DATA.Expts{eid}.Cluster{k,j}.touched = 0;
            DATA.Expts{eid}.Cluster{k,j} = rmfield(DATA.Expts{eid}.Cluster{k,j},{'x' 'y'});
            end
        end
    end
    nc = CountClusters(DATA.cluster);
    for k = 1:nc;
        for j = 1:size(DATA.cluster,2);
            if ~isempty(DATA.cluster{k,j}) & isfield(DATA.cluster{k,j},'x')
            DATA.cluster{k,j}.touched = 0;
            DATA.cluster{k,j} = rmfield(DATA.cluster{k,j},{'x' 'y'});
            end
        end
    end
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'comments',6)
    PrintComments(DATA);
elseif strncmpi(name,'combine',6)
    DATA.extype = get(DATA.clst,'value');
    [Expt, DATA] = CombinePlot(DATA,1);
    DATA.Expt = Expt;
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'options',5)
    DATA.optionfig = setoptions(DATA,DATA.tag.options);
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'meanspike',6)
    DATA = CalcMeanSpike(DATA,DATA.expid);
    if strfind(name,'save')
        SaveSpikeShape(DATA);
    end
elseif strncmpi(name,'plotshape',6)
    GetFigure('ClusterShape');
    PlotSpikeShapes(DATA.MeanSpike,varargin{:});
elseif strncmpi(name,'PlotISI',5)
    GetFigure('ISI');
    [isis, t, s] = CalcISI(DATA.Expts{DATA.currentexpt}.Trials);
    id = find(isis < 1000)
    hist(isis(id),100);
    [a,b] = sort(isis);
%    DATA.isit = t(b);
    DATA.isis = s(b);
    DATA.ISIpair = 1;
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'reclassify',5)
    ts = now;
    DATA = ReClassifyAll(DATA);
    fprintf('Took %.2f sec\n',(now-ts)*(24*60*60));
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'showvals',5)
    DATA.showid = setshow(DATA,DATA.tag.showvals);
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'spikes',5)
    PlotSpikes(DATA,varargin{1});
elseif strncmpi(name,'setexp',6)
    if DATA.playingspk
        set(findobj(DATA.svfig,'Tag','StopSpool'),'value',1);
        set(findobj(DATA.svfig,'Tag','StopSpool'),'UserData',1);
        DATA.playingspk = 0;
        set(DATA.toplevel,'UserData',DATA);
        return;
    end
    ts  = now;
    id = get(DATA.elst,'value');
    DATA.exabsid = DATA.expid(id);
    GetFigure(DATA.tag.dataplot,'noforce');
    if DATA.state.plotcombined
        rc = DATA.plot.condenseRC;
        DATA.plot.condenseRC = 0;
        PlotCombined(DATA, DATA.Expt);
        DATA.plot.condenseRC = rc;
        NotBusy(DATA);
        return;
    end

    hs = 'nohold';
    colors = mycolors;
    if strncmpi(name,'setexpplot',8)
        playspk = 0;
    else
        playspk = get(findobj(DATA.toplevel,'Tag','ShowSpikes'),'value');
    end
    if DATA.state.online 
        ton = strcmp(get(DATA.timerobj,'Running'),'on');
        if DATA.expid(id(end)) == length(DATA.Expts) || DATA.state.autolist
            if ~ton
                start(DATA.timerobj);
                DATA = get(DATA.toplevel,'UserData');
            end
        elseif ton
            stop(DATA.timerobj);
        end
    end
    lastexpt = DATA.currentexpt;
    DATA.currentexpt = DATA.expid(id(1));
    if ~isempty(findobj('Tag',DATA.tag.celllist))
        GetFigure(DATA.tag.celllist);
        PlotCellList(DATA);
    end
    if DATA.state.online & lastexpt ~= DATA.currentexpt
        DATA = LoadSpikes(DATA, DATA.currentexpt);
    end
    if DATA.state.online < 2 & DATA.Expts{DATA.expid(id(1))}.gui.classified == 0 || ...
             (DATA.Expts{DATA.expid(id(1))}.gui.clustertype == 2 && DATA.state.autoplot)
        playspk = 1;
    end
    if DATA.state.autoplotallspikes == 0 && length(id) > 1
        playspk = 0;
    end
    if DATA.state.nospikes %override all the possibilites
        playspk = 0;
    end
    if isfield(DATA,'AllClusters') | isfield(DATA,'AllSpikes')
        DATA.allexp = DATA.currentexpt;
        for j = 1:size(DATA.cluster,2)
            if isfield(DATA.Expts{DATA.currentexpt},'Cluster') && iscluster(DATA.Expts{DATA.currentexpt}.Cluster,1,j)
                DATA.cluster{1,j} = DATA.Expts{DATA.currentexpt}.Cluster{1,j};
                DATA.cluster{1,j}.touched = 1;
            else
                DATA.cluster{1,j}.touched = 0;
            end
        end
    end

    if playspk & DATA.probe == 100
        DATA = PlaySpikes(DATA, DATA.expid(id(1)));
    elseif playspk & (~isempty(DATA.AllData.Spikes) || isfield(DATA,'AllSpikes'))
        if DATA.spooling %was looking at a different classification. Re-classif
            for j = id(1:end)
            end
        end
        DATA.spklist = [];
        DATA.spooling = 0;

        for j = id(1:end)
 % If this expt last shown with a temporary cut, revert back to the saved
 % one, unless this is a "spool" showing the temporary cut.
 % or if the classifiction has  not been done at all yet.
            if isfield(DATA,'AllSpikes')
            elseif ~DATA.spooling && ismember(DATA.Expts{DATA.expid(j)}.gui.classified,[0 2])
                DATA = SetExptSpikes(DATA,DATA.expid(id(1)),0);
            else
                [DATA.plot.clusterX , DATA.plot.clusterY, DATA] = GetClusterSpace(DATA, DATA.Expts{DATA.expid(id(1))});        
            end
            DATA = PlaySpikes(DATA, DATA.expid(j));
        end
        if DATA.state.showspkxy & isfield(DATA,'AllClusters') | isfield(DATA,'AllSpikes')
           DATA =  PlotAllProbeXY(DATA,0);
        end
        set(DATA.toplevel,'UserData',DATA);
        if ~DATA.state.autoplot
            NotBusy(DATA);
            out = DATA;
            return; % This stops plotting of results. Why? ? only return if not auto
        end
    elseif DATA.state.showspkxy
        if isfield(DATA,'AllClusters') | isfield(DATA,'AllSpikes')
           DATA =  PlotAllProbeXY(DATA,0);
        else
        GetFigure(DATA.tag.clusterxy);
        DATA = SetExptSpikes(DATA,DATA.expid(id(1)),2);
        hold off;
        DrawXYPlot(DATA, DATA.spklist);
        end
    end
    DATA.spklist = []; %once clusters are cut, this should be in them. Don't let first expt set for all
    out = DATA;
    GetFigure(DATA.tag.dataplot,'noforce');
    ClearPlot;
    h = [];
    xargs = {};
    if length(id) > 1 && DATA.Expts{DATA.expid(id(1))}.Header.rc
        xargs = {xargs{:} 'condense'};
    end
    eid = get(DATA.clst,'value');
 
    for j = id(1:end)
        if DATA.state.recount | DATA.Expts{DATA.expid(j)}.gui.counted == 0;
            DATA = CountSpikes(DATA,DATA.expid(j));
        end
        
        s = ExptComments(DATA.Expts{DATA.expid(j)});
        te = now;
        edepth = GetEval(DATA.Expts{DATA.expid(j)},'ed');
       if length(id)  == 1 || eid > 1 %don't add plots from 'All' list
            args = PlotArgs(DATA,DATA.Expts{DATA.expid(j)});
        res = PlotExpt(DATA.Expts{DATA.expid(j)},hs,'forcecolor',colors{j},args{:},'legendpos',7,xargs{:});
         fprintf('%.2f ',(now-te)*60*60*24);
        sp  = strfind(DATA.subexplist{j},' ');
        if sp
            names{j} = DATA.subexplist{j}(1:sp(1)-1);
        else
            names{j} = DATA.subexplist{j};
        end
        names{j} = [names{j} ShowString(DATA,DATA.Expts{DATA.expid(j)})];
        if  ~isempty(res) && isfield(res,'handles') && ishandle(res(1).handles(1))
            h(j) = res(1).handles(1);
        end
        hs = 'Hold';
        end
    end
    if ~isempty(h)
        mylegend(h,names);
    end
    t = get(get(gca,'title'),'String');
    title([t sprintf(' P%d',DATA.probe) 'Cl' sprintf(' %d',WhichClusters(DATA.toplevel)) sprintf('ed%.2f',edepth)]);
 %   fprintf('Took %.2f\n',(now-ts)*60*60*24);
    set(DATA.toplevel,'UserData',DATA);
    
elseif strncmpi(name,'Close',4)
    if isfield(DATA,'timerobj')
        stop(DATA.timerobj);
    end
    if isfield(DATA,'tag')
        names = fieldnames(DATA.tag);
        for j = 1:length(names)
            CloseTag(DATA.tag.(names{j}));
        end
    end
    return;
elseif strncmpi(name,'savelfp',7)
    outname = get(DATA.saveitem,'string');
    Expt = DATA.Expt;
    Expt.Header.CombineDate = now;
    if DATA.datafilename(2) == ':'
        drive = DATA.datafilename(1:2);
    else
        drive = '';
    end
    tic;
    useraw = 0;
    outname = regexprep(outname,'\.c[0-9]\.','.lfp.');
    outname = regexprep(outname,'\.p[0-9]*c[0-9]\.','.lfp.');
    if DATA.state.online
        for j = 1:length(DATA.combineids)
            if length(DATA.probelist) > 8
            lfpfile = strrep(DATA.Expts{DATA.combineids(j)}.Header.Name,'/Expt','A/LFPS');
            else
            lfpfile = strrep(DATA.Expts{DATA.combineids(j)}.Header.Name,'/Expt','/LFPS');
            end
            lfpfiles{j} = [drive lfpfile];
        end
        Expt= LoadSpike2LFP(Expt,'reload','lfpfile',lfpfiles,'drive',drive,'fixshort',10);
% above reps should fail with online files, but remove .lfp first to be sure
        if ~isfield(Expt.Trials,'LFP')
            fprintf('No LFP Data in %s\n',lfpfiles{:});
            return;
        end
        if DATA.state.scalelfp
            Expt = ScaleLFP(Expt, 'scale', 0.05);
        end
        outname = strrep(outname,'.lfp.mat','.mat');
        outname = strrep(outname,'.mat','.lfp.mat');
    elseif ~isempty(LFP)
        Expt= LoadSpike2LFP(Expt,LFP);
    elseif useraw
        lfpfile = [drive strrep(Expt.Header.Name,'.mat','A.lfp.mat')];
        Expt= LoadSpike2LFP(Expt,'reload','lfpfile',lfpfile,'fixshort',5);
    else   
        Expt= LoadSpike2LFP(Expt,'reload','drive',drive,'fixshort',5);
    end
    ltime = toc;
    ck = CheckLFP(Expt,'verbose');
    ns = mode(ck.lens);
    Expt.Trials = rmfield(Expt.Trials,{'Spikes' 'OSpikes' 'Ocodes' 'count'});
    LFP = Expt;
    if sum(ck.lens .* ck.nch) > 100e6
        LFP.Trials = rmfield(LFP.Trials,'FTlfp');
    end
    tic;
    save(outname,'LFP');
    if DATA.plot.lfpplot > 0
        DATA.LFP = LFP;
        set(DATA.toplevel,'UserData',DATA);
        ShowLFPPlot(DATA);
    end
    fprintf('Saved %d samples/trial. %s Loading LFP tookd %.2f, saving %.2f\n',ns,outname,ltime,toc)
    if DATA.logfid
        fprintf(DATA.logfid, '%s, LFP file %s (Took %.1f %.1f)\n',datestr(now),outname,ltime,toc);
    end

elseif strncmpi(name,'save',4)
    DATA.outname = get(DATA.saveitem,'string');
    Expt = DATA.Expt;
    Expt.Header.CombineDate = now;
    if isfield(DATA,'cluster')
        Expt.Header.Cluster = DATA.cluster;
    end
    Expt.Header.clist = DATA.spikelist;
    if isfield(Expt.Trials,'LFP')
    Expt.Trials = rmfield(Expt.Trials,{'LFP' 'lfptime' 'lfpo' 'FTlfp'});
    end
    save(DATA.outname,'Expt');
    nspk = sum([Expt.Trials.count]);
    fprintf('Saved %d spikes (Expts%s) to %s\n',nspk,sprintf(' %d',DATA.combineids),DATA.outname);
    if DATA.logfid
        fprintf(DATA.logfid, '%s,Saved %d spikes (Expts%s) to %s\n',datestr(now),nspk,sprintf(' %d',DATA.combineids),DATA.outname);
    end
    cfile = CombinerLst(DATA);
    if exist(cfile,'file') == 2
        load(cfile);
    else
        combines.name = {};
    end
    id = strmatch(splitpath(DATA.outname),combines.name,'exact');
    if isempty(id)
        id = length(combines.name)+1;
    end
    combines.name{id} = splitpath(DATA.outname);
    combines.lastdate(id) = now;
    combines.list{id} = Expt.Header.Combined;
    combines.starts{id} = Expt.Header.BlockStart;
    combines.trials(id,:) = [Expt.Trials(1).Trial Expt.Trials(end).Trial];
    DATA.combines = combines;
    %tic;
    DATA = ListExpts(DATA,DATA.Expts);
   % toc
    set(DATA.toplevel,'UserData',DATA);
  %  combine('listexpts');
  %  save(cfile,'combines');
elseif strncmpi(name,'spoolall',7)
    SpoolAllProbeClusters(DATA);
elseif strncmpi(name,'store',5)
    set(DATA.toplevel,'UserData',varargin{1});
elseif strncmpi(name,'relist',6)
    DATA = ReadDir(DATA, DATA.name,'setprobe',DATA.probe);
    DATA = combine('listexps',DATA,'Tag',DATA.tag.top);
    eid = get(DATA.clst,'value');
    DATA = ListSubExpts(DATA,eid);

    set(DATA.toplevel,'UserData',DATA);
    if DATA.state.autoplot
        names = get(DATA.clst,'String');
        eid = strmatch(DATA.Expts{end}.Header.expname, names,'exact');
        if length(eid) == 1
           set(DATA.clst,'value', eid);
           DATA = ListSubExpts(DATA,eid);
            nex = length(get(DATA.elst,'String'));
            set(DATA.elst,'value',nex);
            set(DATA.toplevel,'UserData',DATA);
        end
        WinFront(DATA.tag);
    end
elseif exist(name,'dir') % do dir before file, since dirs pass exist(name,'file')
    DATA.Expts = {};
    args = argon;
    if reindex
        args = {args{:}, 'relist'};
    end
    DATA.state.onine = 1;
    DATA = ReadDir(DATA, name, args{:});
    DATA = LoadClusters(DATA,ClusterFile(DATA));
    DATA.lastread = 0;
    DATA.lastsize = 0;
    if ~isfield(DATA,'timerobj')
            DATA.timerobj = timer('TimerFcn',@@timerfna, 'Period', 1.0,...
                'Tag',DATA.tag.top, 'ExecutionMode','FixedSpacing');
            DATA.lastread = 0;
    end
    set(DATA.toplevel,'UserData',DATA);
elseif strncmpi(name,'newfile',6)
    DATA.datafilename = get(findobj(DATA.toplevel, 'Tag','FileName'),'string');
    combine(DATA.datafilename);
elseif strncmpi(name,'reptrial',6)
    PlayOneTrial(DATA,DATA.currenttrial,0);
elseif strncmpi(name,'rfupdate',6)
    if isfield(DATA.fitvals,'Pp') & isfield(DATA.fitvals,'Op')
        if abs(DATA.fitvals.OpRo-DATA.fitvals.PpRo) > 2
            message('Ro mismatch');
        end
        xy = op2xy([DATA.fitvals.Op DATA.fitvals.Pp],DATA.fitvals.OpRo);
        uflname = strrep(DATA.datafilename,'.mat','.ufl');
        fid = fopen(uflname,'a');
        if fid > 0
        fprintf(fid,'FitRF %.2f %.2f %.2f %.2f\n',xy(1),xy(2),DATA.fitvals.Opw,DATA.fitvals.Ppw);
        fclose(fid);
        end
    end
elseif strncmpi(name,'winfront',6)
    WinFront(DATA.tag);
elseif strncmpi(name,'xcorr',4)
    type = strmatch(name,{'xcorrdc' 'xcorrv' 'xcorr'},'exact');
    probes = varargin{1};
    nc = length(probes);
    GetFigure('CrossCorrelation');
    if nc > 2
        for j = 1:nc
            subplot(nc,nc,((j-1)*nc)+1);
            for k = 1:j
                subplot(nc,nc,((j-1)*nc) + k);
                if type == 3
                CalcXcorr(DATA, DATA.currentexpt,probes(j),probes(k));
                elseif type == 1
                CalcXcorrDC(DATA, DATA.currentexpt,probes(j),probes(k));
                else
                CalcXcorrV(DATA, DATA.currentexpt,probes(j),probes(k));
                end
                set(gca,'ytick',[],'xtick',[]);
                if k == 1
                    ylabel(sprintf('P%d',probes(j)));
                end
                if j == nc
                    xlabel(sprintf('P%d',probes(k)));
                end
            end
        end
    else
        if type == 3
            CalcXcorr(DATA, DATA.currentexpt,probes(1),probes(2));
        elseif type == 1
            CalcXcorrDC(DATA, DATA.currentexpt,probes(1),probes(2));
        else
            CalcXcorrV(DATA, DATA.currentexpt,probes(1),probes(2));
        end
    end
elseif exist(name,'file')
    args = argon;
    if reindex
        args = {args{:}, 'relist'};
    end
    DATA = ReadFile(DATA, name, args{:});
    set(DATA.toplevel,'UserData',DATA);
    if recombine == 1
        ReCombineAll(DATA,0);
    end
    if plotall
        d = fileparts(DATA.datafilename);
        PlotAllProbes(d,'save','sptrig')
    end
    PrintComments(DATA);
    if strfind(name,'ic-169')
        CheckSaccades(DATA.Expts,'Z:/smr/icarus/169/ic169.em.mat');
    end
elseif iscell(name)
    args = argon;
    if reindex
        args = {args{:}, 'relist'};
    end
    names = name;
    for j = 1:length(names)
        name = names{j};
        if exist(name,'file')
            DATA = ReadFile(DATA, name, args{:});
            set(DATA.toplevel,'UserData',DATA);
            if recombine == 1
                ReCombineAll(DATA,0);
                if plotall
                    d = fileparts(DATA.datafilename);
                    PlotAllProbes(d,'save','sptrig')
                end
            end
        end
    end
        
elseif regexp(name,'ruf[0-9][0-9][0-9]') %if its not a file name, try building path
    dnum = strrep(name,'ruf','');
    set(DATA.toplevel,'UserData',DATA);
    name = ['/data/rufus/' dnum '/' name '.mat'];
    if exist(name,'file')
        combine(name,'Tag',DATA.tag.top);
    end
elseif firstcall
    fprintf('No file or directory %s\n',name);
    close(DATA.toplevel);
    return;
end

SetGui(DATA);
NotBusy(DATA);

function DATA = ReadFile(DATA, name, varargin)
            
args = {};
j = 1;
while j <= length(varargin)
    args = {args{:} varargin{j}};
    j =j+1;
end
    DATA.datafilename = name;
    DATA.state.online = 0;
    DATA.logfid = fopen(strrep(name,'.mat', '.log'),'a');
    set(findobj(DATA.toplevel, 'Tag','FileName'),'string',name);
    if strfind(name,'.txt') %% and online text file
        Expts = ReadOnlineTxt(name, args{:});
        Expts = CountTxtSpikes(Expts,DATA.probe,DATA.spikelist);
        DATA.state.online = 2;
        DATA.lastread = 0;
        DATA.lastsize = 0;
        if ~isfield(DATA,'timerobj')
            DATA.timerobj = timer('TimerFcn',@@timerfn, 'Period', 1.0, ...
                'Tag',DATA.tag.top, 'ExecutionMode','FixedSpacing');
            DATA.lastread = 0;
        end
    else
        [Trials, Expts, All] = APlaySpkFile(name, args{:});
        if isfield(Trials,'Probes');
            if length(DATA.probelist) <= 1 & length(Trials.Probes) > 1
                if sum(DATA.probelist < 100) > 1 % count # of recording chans
                    DATA.state.includeprobename = 1;
                end

                AddMultiProbeGUI(DATA);
            end
            DATA.probelist = unique([Trials.Probes.probe]);
            DATA.probevars = {Trials.Probes.var};
            DATA.probenames = cellstr(int2str([DATA.probelist]'));
            DATA.probes = Trials.Probes;
            if isfield(Trials,'setprobe')
                id = find(DATA.probelist == Trials.setprobe(1));
                if isempty(id)
                    id = 1;
                end
            else
                id = 1;
            end
            DATA.probe = DATA.probelist(id(1));
            it = findobj(DATA.toplevel,'Tag','ProbeId');
            set(it,'string',DATA.probenames,'value',id(1));

        end
        DATA.cellfile = strrep(name,'.mat','.cells.mat');
        if exist(DATA.cellfile,'file')
            load(DATA.cellfile);
            DATA.CellList = CellList;
            if exist('CellQuality','var')
                if size(CellQuality,2) < size(CellList,2)
                   nq = size(CellQuality,2);
                   nl = size(CellList,2);
                   CellQuality(:,nq+1:nl) = 0;
                end
                DATA.CellQuality = CellQuality;
            else
                DATA.CellQuality = zeros(size(DATA.CellList));
            end
            if exist('CellListCluster','var')
                DATA.CellListCluster = CellListCluster;
            else
                DATA.CellListCluster = zeros(size(CellList));
                id = find(CellList > 0)
                DATA.CellListCluster(id) = 1;
            end
            if exist('Templates','var')
                DATA.Templates = Templates;
            end
        end
        
    end
    DATA = ListExpts(DATA,Expts);
    Trialids = [];
    for nexp = 1:length(Expts)
        newt = [Expts{nexp}.Trials.Trial];
        Trialids = [Trialids newt];
        Expts{nexp}.gui.classified = 0;
        Expts{nexp}.gui.counted = 0;
        Expts{nexp}.gui.clustertype = 0;
        if isfield(Expts{nexp}.Header,'Nam1e')
            Expts{nexp}.Header.Name = Expts{nexp}.Header.Nam1e;
        end
    end
    if isempty(Expts)
        NotBusy(DATA);
        return;
    end
    DATA.Expts = Expts;
    if DATA.state.online
        DATA.AllData = [];
    else
    DATA.AllData = All;
    DATA.AllData.SpikeIdx = Trials.Spkid;
    DATA.AllData.Trialids = Trialids;
    if isfield(Trials,'Comments')
        DATA.Comments = Trials.Comments;
    end

    
% load saved cluster params
    
    DATA = LoadOnlineClusters(DATA, ClusterFile(DATA,'getonline'));
    DATA = LoadClusters(DATA, ClusterFile(DATA));
    DATA = LoadClusters(DATA, ClusterFile(DATA,'allprobes'));
    cfile = CombinerLst(DATA);
    if exist(cfile,'file')
        load(cfile);
        DATA.combines = combines;
    end
    if isfield(Trials,'setprobe') & length(Trials.setprobe) > 1
            DATA.plot.useprobe(Trials.setprobe) = 1;
            DATA.currentexpt = 1;
            DATA.exabsid = 1:length(DATA.Expts);
            DATA = LoadAllProbeSpikes(DATA, 0, 'select');
    end
    
    
    end


function s = ExptComments(Expt)
    if isfield(Expt,'Comments') & ~isempty(Expt.Comments.text);
        s = Expt.Comments.text;
        bid = strmatch('cm=back=',s);
        gid = setdiff(1:length(s),bid);
        for j = gid
            fprintf('%s\n',s{j});
        end

    else
        s = {};
    end

function PrintComments(DATA)
    
    if isfield(DATA.Expts{1}.Header,'rfstr');
        fprintf('%s\n',DATA.Expts{1}.Header.rfstr);
    end
    if isfield(DATA,'Comments')
        if isfield(DATA.Comments,'Peninfo')
            fprintf('%s\n',DATA.Comments.Peninfo.trode);
        end
        for j = 1:length(DATA.Comments.text)
            if isempty(strmatch('cm=back=',DATA.Comments.text{j}))
            fprintf('%.1f: %s\n',DATA.Comments.times(j)./10000,...
                DATA.Comments.text{j});
            end
        end
    end


function NotBusy(DATA)

[a,b,c] = fileparts(DATA.datafilename);
set(DATA.toplevel,'Name',[DATA.tag.top ':' b]);

function ShowLFPPlot(DATA)
    b = [];
    GetFigure(DATA.tag.lfpplot);
    if ismember(DATA.plot.lfpplot,[4 5 6 7 8 9 10 11 12])
        if DATA.LFP.Header.rc
            [a,b] = PlotRevCorAny(DATA.LFP,'lfp',DATA.probe,'nmin',20,'figa',DATA.tag.rcfiga,'figb',DATA.tag.rcfigb);
            GetFigure(DATA.tag.lfpplot);
        else
            a = PlotLFP(DATA.LFP);
        end
    end
    hold off;
    
    if DATA.plot.lfpplot == 1
        if DATA.LFP.Header.rc > 0
            if isempty(b) 
                [a,b] = PlotRevCorAny(DATA.LFP,'lfp',DATA.probe,'figa',DATA.tag.rcfiga,'figb',DATA.tag.rcfigb,'nmin',DATA.plot.nminrc);
                GetFigure(DATA.tag.lfpplot);
            end
            PlotAllProbes(a);
        elseif strmatch('square.co',DATA.LFP.Header.expname)
            PlotMLFP(DATA.LFP,'image');
        else
            a = PlotLFP(DATA.LFP);
        end     
    elseif DATA.plot.lfpplot == 3
        PlotMLFP(DATA.LFP,'image','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 2
        PlotMLFP(DATA.LFP,'stack','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 4
        PlotAllProbes(a,'blank','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 5

    elseif DATA.plot.lfpplot == 6
        PlotAllProbes(a,'probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 7
        PlotAllProbes(a,'onestim','xvals',1:length(a.sdfs.x(:,1)),'yvals',1:length(a.sdfs.x(1,:)),'probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 8
        PlotAllProbes(a,'monoc','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 9
        PlotAllProbes(a,'LFPEig','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 10
        PlotAllProbes(a,'stimvar','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 11
        PlotAllProbes(a,'varblank','probes',DATA.probelist);
    elseif DATA.plot.lfpplot == 12
        PlotAllProbes(a,'frameresp','probes',DATA.probelist);
    end

function str =ShowString(DATA, Expt)
    str = '';
    fn = fields(DATA.show);
    for k = 1:length(fn)
        if isempty(strmatch(fn{k},'times') )
            x = GetEval(Expt,fn{k});
        if strmatch(fn{k},'Fr') & x > 1
         str = [str sprintf(' %s=%.2f',fn{k},x)];
        elseif DATA.show.(fn{k})
         str = [str sprintf(' %s=%.2f',fn{k},x)];
        end
        end
    end

        
function Expts = CountTxtSpikes(Expts, probe, cl)

if length(cl) > 2
    cl = cl(1:2);
end
for j = 1:length(Expts)
    if isfield(Expts{j},'Trials')
    for k = 1:length(Expts{j}.Trials)

        if size(Expts{j}.Trials(k).AllSpikes,2) < cl(1)+1
            Expts{j}.Trials(k).Spikes = [];
        elseif length(cl) > 1 && size(Expts{j}.Trials(k).AllSpikes,2) > cl(end)
            Expts{j}.Trials(k).Spikes = union(Expts{j}.Trials(k).AllSpikes{probe,cl+1});
        else
            Expts{j}.Trials(k).Spikes = Expts{j}.Trials(k).AllSpikes{probe,cl(1)+1};
        end
    end
    else
        fprintf('Expt %d no trials\n');
    end
    Expts{j}.gui.counted = 1;
end
        
function DATA = LoadClusters(DATA, cfile)
    if isempty(DATA.AllData.Spikes)
        return;
    end
    if exist(cfile,'file')
        excludelist = [];
        clid = [];
        classified = 0;
        load(cfile);
        DATA.state.recut = 1;
        firstspk = length(DATA.AllData.Spikes.times);
        lastspk = 0;
        if size(clid,1) == size(DATA.AllData.Spikes.codes,1);
            DATA.AllData.Spikes.codes(:,2) = clid;
            last = max(find(clid > 0));
            maxclasst = DATA.AllData.Spikes.times(last);
            classified = 1;
        end
        for j = 1:min([length(excludelist) length(DATA.Expts)]);
            lst = -abs([DATA.Expts{j}.Trials(excludelist{j}).Trial]);
            if lst
                for k = 1:length(lst)
                    [DATA.Expts{j}.Trials(excludelist{j}(k)).Trial] = lst(k);
                end
            end
        end
        for j = 1:min([length(AllClusters) length(DATA.Expts)]);
            if ~isempty(AllClusters{j})
                DATA.Expts{j}.Cluster = AllClusters{j}.Cluster;
                if exist('clustertypes','var') %%saved type
                    DATA.Expts{j}.gui.clustertype = clustertypes(j);
                else
                    DATA.Expts{j}.gui.clustertype = 1;
                end
        firstspk = length(DATA.AllData.Spikes.times);
        lastspk = 0;
        nset = 0;
        if ~isfield(DATA.cluster{1,1},'Arange')
            DATA.cluster{1,1}.Arange = [6:8];
            DATA.cluster{1,1}.Brange = [11:20];
            DATA.cluster{1,1}.Erange = [1:100];
        end

%only do this for one probe, as AllData.Spikes only has one probes data       
        p = DATA.probe;
        nprobes = size(DATA.Expts{j}.Cluster,2);

                for k = 1:size(DATA.Expts{j}.Cluster,1)
                    if p > nprobes
                           DATA.Expts{j}.Cluster{k,p}.firstspk = NaN;
                           DATA.Expts{j}.Cluster{k,p}.lastspk = NaN;
                           nprobes = p;
                    end
                    if isempty(DATA.Expts{j}.Cluster{k,p}) | ~isfield(DATA.Expts{j}.Cluster{k,p},'firstspk')
                        DATA.Expts{j}.Cluster{k,p}.firstspk = NaN;
                        DATA.Expts{j}.Cluster{k,p}.lastspk = NaN;
                    else
                        nset = nset + 1;
                    end
                    if DATA.Expts{j}.Cluster{k,p}.firstspk < firstspk 
                        ts = DATA.AllData.Spikes.times(DATA.Expts{j}.Cluster{k,p}.firstspk);
                        if ts  > DATA.Expts{j}.Header.trange(1) && ts < DATA.Expts{j}.Header.trange(2)
                            firstspk = DATA.Expts{j}.Cluster{k,p}.firstspk;
                        end
                    end
                    if DATA.Expts{j}.Cluster{k,p}.lastspk > lastspk && ...
                            DATA.Expts{j}.Cluster{k,p}.lastspk <= length(DATA.AllData.Spikes.times)
                        ls = DATA.AllData.Spikes.times(DATA.Expts{j}.Cluster{k,p}.lastspk);
                        if ls  > DATA.Expts{j}.Header.trange(1) && ls < DATA.Expts{j}.Header.trange(2)
                            lastspk = DATA.Expts{j}.Cluster{k,p}.lastspk;
                        end
                    end
                    if DATA.Expts{j}.gui.clustertype == 2 % online cluster - can't use spk coun
                           DATA.Expts{j}.Cluster{k,p}.firstspk = NaN;
                           DATA.Expts{j}.Cluster{k,p}.lastspk = NaN;
                    end
                    if ~isfield(DATA.Expts{j}.Cluster{k,p},'params')
                        DATA.Expts{j}.Cluster{k,p}.params = [1 2];
                    end                    
                    if ~isfield(DATA.Expts{j}.Cluster{k,p},'Arange')
                        DATA.Expts{j}.Cluster{k,p}.Arange = DATA.cluster{1,1}.Arange;
                        DATA.Expts{j}.Cluster{k,p}.Brange = DATA.cluster{1,1}.Brange;
                        DATA.Expts{j}.Cluster{k,p}.Erange = DATA.cluster{1,1}.Erange;
                    end 

                end
                if lastspk < firstspk %nevet found these in cluster file
                    firstspk = NaN;
                    lastspk = NaN;
                end
                if lastspk > size(DATA.AllData.Spikes.codes,1)
                    lastspk = size(DATA.AllData.Spikes.codes,1);
                end
% with multiple probes, empty clsuters can arise because clusters have beed set
% on other probes. 
                if nset == 0 && nprobes == 1 % actively set no clusters. Only works if one probe
                    DATA.Expts{j}.gui.classified = 1;
                    DATA.Expts{j}.gui.ncluster = 0;
                elseif isnan(firstspk) 
                    DATA.Expts{j}.gui.classified = 0;
                    DATA.Expts{j}.gui.ncluster = 0;
                elseif classified && lastspk > firstspk && max(DATA.AllData.Spikes.codes(firstspk:lastspk,2)) > 0 
                    DATA.Expts{j}.gui.classified = classified;
                    DATA.Expts{j}.gui.ncluster = nset;
                else
                    DATA.Expts{j}.gui.classified = 0;
                    DATA.Expts{j}.gui.ncluster = 0;
                end
            end
        end
    else
        p = DATA.probe;
        for j = 1:length(DATA.Expts);
            if isfield(DATA.Expts{j},'Cluster')
            for k = 1:size(DATA.Expts{j}.Cluster,1)
            DATA.Expts{j}.Cluster{k,p} = {};
            end
            end
        end
    end

function DATA = LoadOnlineClusters(DATA, cfile)
    if exist(cfile,'file')
        load(cfile);
        DATA.state.recut = 1;
        p = DATA.probe;
        for j = 1:length(AllClusters);
            if ~isempty(AllClusters{j})
                for k = 1:length(DATA.Expts)
                    if isfield(AllClusters{j},'ids') & ...
                            AllClusters{j}.ids(1) > min([DATA.Expts{k}.Trials.id]) -2 & ...
                            AllClusters{j}.ids(2) < max([DATA.Expts{k}.Trials.id]) +2
                        
                        DATA.Expts{k}.Cluster = AllClusters{j}.Cluster;
                        DATA.Expts{k}.gui.clustertype = 2;
%
%Fill in fields that might be missing from old cluster files
%remove firstpk, lastspk refs from the online file - these spike id #s will
%not necessarily match the saved fil
                        for m = 1:length(DATA.Expts{k}.Cluster)
                            DATA.Expts{k}.Cluster{m,p}.firstspk = NaN;
                            DATA.Expts{k}.Cluster{m,p}.lastspk = NaN;
                            if ~isfield(DATA.Expts{k}.Cluster{m,p},'params')
                                DATA.Expts{k}.Cluster{m,p}.params = [1 2];
                            end
                        end
                        DATA.Expts{k}.gui.classified = 0; %loaded def, but not classified
                    end
                end
            end
        end
    end


function [DATA, Stimvals] = CheckCombine(DATA, interactive)
    
    if nargin < 2
        interactive = 1;
    end
    err = '';
    id = get(DATA.elst,'value');
    for j = 1:length(id)
        stims(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'st');
        bws(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'ob');
        mes(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'me');
        tfs(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'tf');
        sfs(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'sf');
        ors(j) = GetEval(DATA.Expts{DATA.expid(id(j))},'or');
        ets{j} = DATA.Expts{DATA.expid(id(j))}.Stimvals.et;
        e2s{j} = DATA.Expts{DATA.expid(id(j))}.Stimvals.e2;
        Stimvals = DATA.Expts{DATA.expid(id(j))}.Stimvals;
    end
    Stimvals.BlockedStim = 0;
    for j = 1:length(e2s)
            if isempty(e2s{j}) 
            e2s{j} = 'e0';
            end
            if isempty(ets{j}) 
            ets{j} = 'e0';
            end
    end
    blank = strmatch('none',unique(stims));
    nstims = length(unique(stims)) - length(blank);
    blank = strmatch('e0',unique(e2s));
    e2lst = unique(e2s);
    e1lst = unique(ets);
    ne2 = length(e2lst) - length(blank);
    bws = unique(bws);
    bws = bws(find(~isnan(bws)));
    if length(bws) > 1 & ne2 == 0 & Stimvals.st== 22 %bw only means anything for stim image
        err = [err sprintf('%d Bandwidths in %s',length(unique(bws)),DATA.outname) sprintf('%.2f ',unique(bws))];
        for j = id(1:end)
            DATA.Expts{DATA.expid(j)} = FillTrials(DATA.Expts{DATA.expid(j)},'ob');
            Stimvals.e2 = 'ob';
            Stimvals.BlockedStim = 1;
        end
    elseif ne2 == 1 & strmatch('me',e2lst)
        for j = id(1:end)
            DATA.Expts{DATA.expid(j)} = FillTrials(DATA.Expts{DATA.expid(j)},'me');
            Stimvals.e2 = 'me';
            Stimvals.BlockedStim = 1;
        end        
    end
    if length(unique(sfs)) >1 & isempty(strmatch('sf',{e1lst{:} e2lst{:}}))
      err = [err sprintf('%d SFS in %s',length(unique(sfs)),DATA.outname) sprintf('%.2f ',unique(sfs))];
    end
    if length(unique(ors)) > 1 & isempty(strmatch('or',{e1lst{:} e2lst{:}}))
      err = [err sprintf('%d Oris in %s',length(unique(ors)),DATA.outname) sprintf('%.2f ',unique(ors))];
    end
    if length(err) > 1
        if interactive 
        questdlg(err,'test','OK','OK');
        else
            fprintf('%s\n',err);
        end
    end
 
    
 function AutoClusters = SaveAutoClusters(DATA)
 
     cfile = ClusterFile(DATA,'auto');
     if exist(cfile,'file')
         load(cfile);
     end
     for j = 1:length(DATA.Expts)
         for k = 1:length(DATA.probelist)
             p = DATA.probelist(k);
             if isfield(DATA.Expts{j}.Cluster{1,p},'autocut') && DATA.Expts{j}.Cluster{1,p}.autocut
                 AutoClusters{j}{1,p} = DATA.Expts{j}.Cluster{1,p};
             end
         end
     end
     save(cfile,'AutoClusters');
     
 function DATA = AutoCut(DATA,eid, expno, varargin)
 
     minimize = 0;
     plotmode = 1;
     show = 2;
     j = 1;
     mode = DATA.plot.autoclustermode;
     while j <= length(varargin)
         if strncmpi(varargin{j},'cluster',4)
             mode = 1;
         elseif strncmpi(varargin{j},'minimize',4)
             minimize = 1;
         elseif strncmpi(varargin{j},'noplot',4)
             plotmode = 0;
             show = 0;
         end
         j = j+1;
     end
     
     
     if DATA.state.online
         DATA = LoadSpikes(DATA,eid);
     end
     [DATA, ispk] = SetExptSpikes(DATA, eid, 'setrange');

     if length(ispk) > 3
     DATA = CalcClusterVars(DATA, DATA.Expts{eid}.gui.spkrange);

     if mode == 1
         if isfield(DATA,'AllClusters')
             Cy = DATA.AllClusters(DATA.probe).cy;
             Cx = DATA.AllClusters(DATA.probe).cx;
         else
         Cy = DATA.Spikes.cy;
         Cx = DATA.Spikes.cx;
         end
         [x,y,z] = CalcDensity(DATA, ispk, 3);
         xv = x(1,:);
         yv = y(:,1);
         % find local maxima in smoothed 2-D density
         sd = 5;
         np = 10;

         nl = 1;
         stepscale = 1;
         while (np > 2 || np == 1) & stepscale > 0.1 & sd < 25 & sd > 0.25
             if sd > 15
                 [a,b,K] = gauss2d(sd,[-60:60]);
             else
                 [a,b,K] = gauss2d(sd,[-30:30]);
             end
             K = K./sum(K(:));
             Z = conv2(z,K,'same');
             dy = diff(Z,[],2);
             dx = diff(Z);
             yz = diff(sign(dy),[],2);
             xz = diff(sign(dx));
             lastnp = np;
             pid = find(yz(2:199,:) < 0 & xz(1:198,2:199) < 0);
             if length(ispk) > 5000
                 zthresh = max(Z(:))./40;
             elseif length(pid) > 4
                 zthresh = max(Z(:))/10;
             elseif length(pid) > 2
                 zthresh = max(Z(:))./20;
             else
                 zthresh = 0;
             end
             pid = find(yz(2:199,:) < 0 & xz(1:198,2:199) < 0 & Z(2:199,2:199) > zthresh);

             np = length(pid);
             if np == 2 
                 [py,  px] = ind2sub([198 198], pid);
                 d = abs((px(2)-px(1) + i * (py(2)-py(1))));
                 if d < 30
                     np = 1;
                 end
             end
             nps(nl) = np;
             sds(nl) = sd;
             zts(nl) = zthresh;
             if nl ==1 && np > 10
                 stepscale = 4;
             end
             if np == 1 && sd < 50 && sd > 1
                 sd = sd - 0.5 * stepscale;
             elseif np == 1 && sd  < 1
                 sd = sd * 0.8;
             elseif np == 1
                 sd = sd * 0.8;
             elseif nl > 1 && nps(nl-1) == 1
                 stepscale = stepscale  * 0.25;
                 sd = sd + stepscale;
             else
                 sd = sd +stepscale;
             end
             nl = nl+1;
         end
         [py,  px] = ind2sub([198 198], pid);
         px = px+1;
         py = py+1;
         [pd, peaki] = max(abs(px +i*py)); %find most distant local maximum
         peaka = [px(peaki) py(peaki)];

         % now find highest peak that is not this one
         [id, idx] = setdiff(pid,pid(peaki));
         zid = sub2ind([200 200],py(idx),px(idx));
         [a,b] = max(Z(zid));
         if np > 1
% This didn't help...
%             [a,c,K] = gauss2d(sd/2,[-30:30]);
%             K = K./sum(K(:));
%             Zf = conv2(z,K,'same');
             peakb = [px(idx(b)) py(idx(b))];
             xdi = linspace(x(1,peaka(1)),x(1,peakb(1)));
             ydi = linspace(y(peaka(2),1),y(peakb(2),1));
             dd = interp2(x,y,Z,xdi,ydi);
             [dmin,b] = min(dd);
             minpt = [xdi(b) ydi(b)];
             zmax = Z(peaka(2),peaka(1));

             d = sqrt(sum((peaka-peakb).^2));
         else
             zmax = max(Z(:));
             peakb = [];
         end
         if length(ispk) < 500
             minzt = 0.1;
         elseif length(ispk) < 2000
             minzt = 0.05;
         else
             minzt = 0.02;
         end
         if np == 1 || d < 30 || dmin/zmax > 0.8 || zmax/max(Z(:)) < minzt % too close treat as a single blob
             if np > 1 %% peak is not for real
                 [a,id] = max(Z(:));
                 [peaka(2),  peaka(1)] = ind2sub([200 200], id);
                 if dmin/zmax > 0.8
                     dmin = zmax/5;
                 else
                     dmin = zmax/20;
                 end
             else
                 dmin = zmax/50;
             end
             twopeaks = 0;
             xu = max(Cx(ispk));
             xl = peaka(1);
             xc = (xv(xl)+xu)/2;
             xr = (xu-xv(xl))/2;
             id = find(Z(peaka(2):end,peaka(1)) < dmin);
             if isempty(id)
                 id = find(Cx(ispk) > xv(xl));
                 yu = max(Cy(ispk(id)));
             else
                 yu = yv(id(1)+peaka(2)-1);
             end
             yr = yu-yv(peaka(2));
             yc = yv(peaka(2));
         else
             twopeaks = 1;
             %dmin is the low density value between teh cluster peak and the rest
             %should find lower values in the outward directions, but may not - if the
             %cluster is very good, dmin can be low.
             id = find(Z(peaka(2),1:peaka(1)) > dmin);
             if isempty(id)
                 id = find(Z(peaka(2),1:peaka(1)) < zmax/20);
             end
             if isempty(id)
                 xl = 1;
             else
                 xl = id(1);
             end
             id = find(Z(peaka(2),peaka(1):end) < dmin);
             if isempty(id)
                 xu = length(xv);
             else
                 xu = id(1)+peaka(1)-1;
             end
             id = find(Z(1:peaka(2),peaka(1)) > dmin);
             if isempty(id) % check for local minima
                 yl = 1;
             else
                 yl = id(1);
             end
             id = find(Z(peaka(2):end,peaka(1)) < dmin);
             if isempty(id)
                 yu = length(yv);
             else
                 yu = id(1)+peaka(2)-1;
             end
             k = (xv(xu)-xv(xl))/(yv(yu)-yv(yl)); %ratio of radii
             yr = sqrt((ydi(b)-ydi(1)).^2 + (xdi(b)-xdi(1)).^2/k^2);
             xr = yr * k;

             id = find(Z(peaka(2), peaka(1):end) < zmax/20);
             if isempty(id)
                 xu = length(xv);
             else
                 xu = peaka(1)+id(1);
                 if xu > length(xv)
                     xu = length(xv);
                 end
             end
             id = find(Z(peaka(2):end,peaka(1)) < zmax/20);
             if isempty(id)
                 yu = max(Cy(ispk));
             else
                 yu = yv(peaka(2)+id(1)-1);
             end
             k =  (xv(xu)-xdi(1))/xr;
             xc = xdi(1) + xr * (k-1)/2;
             xr = xr + xr *(k-1)/2;
             k = (yu-ydi(1))/yr;
             yc = ydi(1) + yr * (k-1)/2;
             yr = yr + yr *(k-1)/2;
         end
         C.x = [xc xr 1];
         C.y = [yc yr 1];
         C.angle = 0;
         C.firstspk = NaN;
         C.lastspk = NaN;
         C.autocut = 2;
         C.params(1) = DATA.plot.clusterX;
         C.params(2) = DATA.plot.clusterY;
         C.Arange = DATA.clusterArange;
         C.Brange = DATA.clusterBrange;
         C.Erange = DATA.clusterErange;
         DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
         DATA.Expts{eid}.gui.classified = 3;
         if plotmode
         GetFigure('AutoCut');
         subplot(2,1,1);
         hold off;
         pcolor(x,y,Z); shading('interp');
         hold on;
         plot(xv(peaka(1)),yv(peaka(2)),'ok');
         if ~isempty(peakb)
         plot(xv(peakb(1)),yv(peakb(2)),'ow');
         end
         plot(xc,yc,'+k');
         if np > 1
             plot(minpt(1),minpt(2),'+w');
         end
         x = linspace(0,xr);
         y =  sqrt(yr.^2 - (x.*yr/xr).^2);
         x = [x fliplr(x) -x fliplr(-x)];
         y = [y fliplr(-y) -y fliplr(y)];
         plot(x+xc,y+yc,'r');
         title(sprintf('P%d %d peaks',DATA.probe,np));
         subplot(2,1,2);
         hold off;
         plot(Z(peaka(1),:));
         hold on;
         plot(Z(:,peaka(2)),'r');
         if isfigure(DATA.figs.allprobes)
             figure(DATA.figs.allprobes);
             [nr,nc] = Nsubplots(length(DATA.probelist));
             subplot(nr,nc,DATA.probe);
         else
         GetFigure(DATA.tag.clusterxy);
         end
         [DATA, ispk, dprime, details] = SetExptSpikes(DATA, eid, show);
         else
         [DATA, ispk, dprime, details] = SetExptSpikes(DATA, eid, 0);
             
         end
         DATA.Expts{eid}.Cluster{1,DATA.probe}.dprime = dprime;
         nspk = sum(details.nc);

% IF there are two peaks, optimize cluster size 
         if twopeaks
             oldC = C;
             if minimize
                 DATA.ispk = ispk;
                 C = OptimizeDprime(DATA);
                 DATA.cluster{1,DATA.probe} = C;
                 [DATA, newd, d] = SetSpkCodes(DATA,ispk,DATA.probe,0);
             else
             newd = dprime * 1.001;
             dps(1) = dprime;
             nl = 1;
             frac = 0;
             while newd > dprime 
                 dprime = newd;
                 xr = xr.*1.1;
%                 yr = yr.*1.1;
                 C.x = [xc xr 1];
                 C.y = [yc yr 1];
                 DATA.cluster{1,DATA.probe} = C;
                 [DATA, newd, d] = SetSpkCodes(DATA,ispk,DATA.probe, 0);
                 frac = d.nc(1)./length(ispk);
                 nl = nl+1;
                 dps(nl) = newd;
             end
             C.x = [xc xr./1.1 1];
             dprime = dps(nl-1);
             newd = dprime*1.001;
             while newd > dprime
                 dprime = newd;
%                 xr = xr.*1.1;
                 yr = yr.*1.1;
 %                C.x = [xc xr 1];
                 C.y = [yc yr 1];
                 DATA.cluster{1,DATA.probe} = C;
                 [DATA, newd, d] = SetSpkCodes(DATA,ispk,DATA.probe,0);
                 nl = nl+1;
                 dps(nl) = newd;
             end
             C.y = [yc yr./1.1 1];
             end
             frac = d.nc(1)./length(ispk);
             if frac > 0.99  %didn't work
                 C = oldC;
             end
             
             DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
             DATA.cluster{1,DATA.probe} = C;
             [DATA, dprime, details] = SetSpkCodes(DATA,ispk,DATA.probe,show);
             DATA.Expts{eid}.Cluster{1,DATA.probe}.dprime = dprime;
         end
         if np == 1 | dprime < 1
             DATA = CheckAutoRate(DATA, eid, C, 10);
         end
         if show
         DrawClusters(DATA,DATA.Expts{eid}.Cluster,0);
         end
         title(sprintf('%d/%d spikes: dprime %.1f',details.nc(1),length(ispk),dprime));

         drawnow;
         return;
         
         
         
         
         
     elseif mode == 2
     [a,b] = max(z);
     py = smooth(y(b,1),5,'gauss');
     dens = smooth(a,5,'gauss');
     [a,maxi] = max(dens);
     maxpt = [b(maxi) maxi];
     for j = 1:length(dens)
         dip(j) = dens(j)./max(dens(1:j));
     end
     id = find(diff(sign(diff(dip))) >0);
     GetFigure('AutoCut');
     subplot(2,1,1);
     hold off; 
     plot(x(1,:),dip);
     hold on;
     for j = 1:length(id)
         plot([x(1,id(j)+1) x(1,id(j)+1)],[0 1],':');
     end
     id = find(dip(2:end) > 0.5 & diff(dip) > 0.005);
     [a,b] = min(dip(id));
     if isempty(id)
         id = find(dip < max(dip)/2);
         ll = id(1);
         ul = length(dens);
     else
     ll = id(b);
%     ll = id(end);
     ul= id(end)+10;
     id = find(diff(dip(1:ll)) <= 0);
     
    
     ll = id(end); %first positive ddip
     peakdip = max(dip(ll:end))
     id = find(diff(dip(ul:end)) > 0 & dip(ul+1:end) > peakdip);
     if id
         ul = ul+id(1);
     else
         ul = length(dens);
     end
     end
     
     if x(1,ul) > max(Cx(ispk)) | ul == size(x,1)
         xu = max(Cx(ispk)).*1.05;
     else
         xu = x(1,ul);
     end
     plot([x(1,ll) x(1,ll)],[0 1],'r:');
     plot([xu xu],[0 1],'r:');
     subplot(2,1,2);
     hold off;
     pcolor(x,y,z);
     hold on;
     shading('flat');
     plot(x(1,:),py);
     
     xc = mean([xu x(1,ll)]);
     xr = (xu-x(1,ll))/2;
     yd = sum(z(:,ll:ul),2);
     yc = sum(y(:,1).*yd)./sum(yd);
     sigma = sqrt(sum(yd.*(y(:,1)-yc).^2)./sum(yd));
     yr = 6.* sigma;
     id = find(Cx > x(1,ll) & Cx <= xu);
     sigma = std(Cy(id));
     
     C.x = [xc xr 1];
     C.y = [yc yr 1];
     C.angle = 0;
     C.firstspk = NaN;
     C.lastspk = NaN;
     C.autocut = 2;
     C.params(1) = DATA.plot.clusterX;
     C.params(2) = DATA.plot.clusterY;
     C.Arange = DATA.clusterArange;
     C.Brange = DATA.clusterBrange;
     C.Erange = DATA.clusterErange;

     DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
     DATA.Expts{eid}.gui.classified = 3;
     
     GetFigure(DATA.tag.clusterxy);
     [DATA, ispk, dprime]  = SetExptSpikes(DATA, eid, show);
     if np == 1 | dprime < 2
         DATA = CheckAutoRate(DATA, eid, C, 10);
     end
     DrawClusters(DATA,DATA.Expts{eid}.Cluster,0);
     return;
     end
     xid = find(DATA.Spikes.cx(ispk) > median(DATA.Spikes.cx(ispk)));
     yid = find(DATA.Spikes.cy(ispk) < median(DATA.Spikes.cy(ispk)));
     xc = prctile(DATA.Spikes.cx(ispk(yid)),90);
     xmax = prctile(DATA.Spikes.cx(ispk(yid)),99);
     yc = prctile(DATA.Spikes.cy(ispk(xid)),90);
     ymax = prctile(DATA.Spikes.cy(ispk(xid)),99);
       xr = (xmax-xc) * 2;
       if xr == 0
           xr = xc/3;
       end
       yr = (ymax-yc) * 1.5;
       if yr == 0
           yr = yc/3;
       end
       xc = xc.*1.4;
       yc = yc.*0.7;
     C.x = [xc xr 1];
     C.y = [yc yr 1];
     C.angle = 0;
     C.firstspk = NaN;
     C.lastspk = NaN;
     C.autocut = 1;
     DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
     if show & isfigure(DATA.xyfig);
         GetFigure(DATA.xyfig);
         hold off;
     end
     if ~isfield(DATA,'ptsize')
        DATA.ptsize = 4;
     end
     DATA = SetExptSpikes(DATA, eid, show);
     dprime = DATA.cluster{1,DATA.probe}.dprime;
     [rate, frac] = SumExptSpikes(DATA, eid, 1);
     if isinf(xr) | isinf(yr)
         fprintf('xc,yc Inf problem %f %f',xc,yc);
         return;
     end
     while rate < 10 & frac < 0.9
         xr = xr .*1.2;
         yr = yr.*1.2;
         if ~(xr < 1000) | ~(yr < 1000) %catches inf also..
             fprintf('Big raduis',xc,yc);
         end
         C.x = [xc xr 1];
         C.y = [yc yr 1];
         fprintf('Only %.2f Hz (%.2f) Trying %.2f,%.2f\n',rate,frac,xr,yr);
         DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
         DATA = SetExptSpikes(DATA, eid, show);
         dprime = DATA.cluster{1,DATA.probe}.dprime;
         [rate, frac] = SumExptSpikes(DATA, eid, 1);
     end
     while rate > 100 & frac > 0.1
         xc = xc .* 1.2;
         yc = yc .* 1.2;
         C.x = [xc xr 1];
         C.y = [yc yr 1];
         fprintf('Rate %.2f Hz (%.2f) Trying %.2f,%.2f\n',rate,frac,xc,yc);
         DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
         DATA = SetExptSpikes(DATA, eid, show);
         dprime = DATA.cluster{1,DATA.probe}.dprime;
         [rate, frac] = SumExptSpikes(DATA, eid, 1);
     end
     DATA.cluster{1,DATA.probe}.autocut = 1;
     DATA.cluster{1,DATA.probe}.dprime = dprime;
     DATA.Expts{eid}.Cluster{1,DATA.probe}.dprime = dprime;
     fprintf('Probe %d Expt %d Cluster at %.3f+- %.3f, %.3f +- %.3f %.2fHz\n',DATA.probe,expno, C.x(1), C.x(2), C.y(1), C.y(2),rate);
     if show
         title(sprintf('probe %d, Expt %d %.f Hz Dp %.2f',DATA.probe,expno,rate,dprime));
     end
     else
     fprintf('Probe %d Expt %d No Spikes\n',DATA.probe,expno);
     C.firstspk = NaN;
     C.lastspk = NaN;
     C.autocut = 1;
         DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
     end

function OptimizeDprimeHit(a,b)
DATA = GetDataFromFig(a);
if sum(DATA.plot.useprobe)
    DATA = GetAllProbeFig(DATA);
    [nr, nc] = Nsubplots(length(DATA.probelist));
    id = find(DATA.plot.useprobe)
    for j = id;
        subplot(nr,nc,j);
        DATA.probe = DATA.probelist(j);
        DATA.ispk = DATA.AllClusters(j).spklist;
        C = OptimizeDprime(DATA);
        DATA.cluster{DATA.currentcluster,DATA.probe} = C;
        [DATA, newd, nc] = SetSpkCodes(DATA,DATA.ispk,DATA.probe,2);
        DrawClusters(DATA,DATA.cluster, 0);
    end
else
       
DATA.ispk = DATA.Expts{DATA.currentexpt}.gui.spks;
C = OptimizeDprime(DATA);
DATA.cluster{DATA.currentcluster,DATA.probe} = C;
[DATA, newd, nc] = SetSpkCodes(DATA,DATA.ispk,DATA.probe,2);
DrawClusters(DATA,DATA.cluster, 0);
end
set(DATA.toplevel,'UserData',DATA);

function C = OptimizeDprime(DATA)
    global ncall;
    global ycs;
    ncall = 0;
    ycs = [];
    eid = DATA.currentexpt;
    cl = DATA.currentcluster;
    C = DATA.cluster{cl,DATA.probe};
  
    byforce = 1;
%    options = optimset();
      if byforce
          x = [C.x(1) C.x(2) C.y(1) C.y(2)];
          for k= 1:3
     scales = [0.9:0.2:1.1];
     n = 0;
     for a = scales
         for b = scales
             for c = scales
                 for d = scales;
                     n = n+1;
                     xs(n,:) = x .* [a b c d];
                 end
             end
         end
     end
     for j = 1:n
    DATA.cluster{1,DATA.probe}.x = [xs(j,1) xs(j,2) C.x(3)];
    DATA.cluster{1,DATA.probe}.y = [xs(j,3) xs(j,4) C.x(3)];
    [DATA, dprimes(j), details] = SetSpkCodes(DATA,DATA.ispk,DATA.probe, 0);
    [dprime, best] = max(dprimes);
    x = xs(best,:);
     end
          end
      else 
          
%for some reason this seems to get suck in very local minima. I
%gueess because dprime is not a smoth function of the variables on
%a fine scale. see lemM0600 probe 4 expt 39
    options = optimset('TolFun',0.1,'TolX',0.01,'Largescale','off','simplex','on');
    [x, dp, flag, output] = fminsearch(@@ClusterDprime, [C.x(1) C.x(2) C.y(1) C.y(2)],options, DATA, C.nspk);
%    [x, dp, flag] = fminsearch(@@ClusterDprime, x,options, DATA, C.nspk);
    dprime = -dp;
      end
    C.x = [x(1) x(2) 1];
    C.y = [x(3) x(4) 1];
    C.dprime = dprime;
             
         
             
function dprime = ClusterDprime(x, DATA, nspks)
    global dprimes;
    global ncall;
    global ycs;

    eid = DATA.currentexpt;
    C = DATA.cluster{DATA.currentcluster,DATA.probe};
    if length(x) == 2
    C.x(2) = x(1);
    C.y(2) = x(2);

    else
    C.x(1) = x(1);
    C.x(2) = x(2);
    C.y(1) = x(3);
    C.y(2) = x(4);
    end
    ispk = DATA.ispk;

    DATA.cluster{1,DATA.probe} = C;
    [DATA, dprime, details] = SetSpkCodes(DATA,ispk,DATA.probe, 0);

    ns = details.nc(1);
    ncall = ncall+1;
    dprimes(ncall) = dprime;
    ycs(ncall,:) = x;
    if ns < nspks * 0.5 | ns > nspks * 1.5 | C.x(1) > details.maxx | C.y(1) > details.maxy 
        dprime = 1000;
    else
    dprime = -dprime;
    end
    
    
function DATA = CheckAutoRate(DATA, eid, C, minrate)
     xr = C.x(2);
     yr = C.y(2);
     xc = C.x(1);
     yc = C.y(1);
     show = 2;
     [rate, frac] = SumExptSpikes(DATA, eid, 1);
     ispk = DATA.Expts{eid}.gui.spks;
     xm = max(DATA.Spikes.cx(ispk));
     while rate < minrate & frac < 0.9
         xr = xr .*1.2;
         yr = yr.*1.2;
         if ~(xr < 1000) | ~(yr < 1000) %catches inf also..
             fprintf('Big raduis',xc,yc);
         end
         C.x = [xc xr 1];
         C.y = [yc yr 1];
         fprintf('Only %.2f Hz (%.2f) Trying %.2f,%.2f\n',rate,frac,xr,yr);
         DATA.Expts{eid}.Cluster{1,DATA.probe} = C;
         [DATA, ispk]  = SetExptSpikes(DATA, eid, show);
         dprime = DATA.cluster{1,DATA.probe}.dprime;
         [rate, frac] = SumExptSpikes(DATA, eid, 1);
     end
         
function [Expt, DATA] = CombinePlot(DATA, dlgs, varargin)
    
    spikelist = DATA.spikelist;
    j = 1;
    while  j <= length(varargin)
        if strncmpi(varargin{j},'cluster',5)
            j = j+1;
            spikelist = varargin{j};
        end
        j = j+1;
    end
    
    if DATA.state.online < 2
        [DATA, Stimvals] = CheckCombine(DATA, dlgs);
    end
    ids = get(DATA.elst,'value');
  
    tfields = {};
    for j = ids(1:end)
        tfields = union(tfields,fields(DATA.Expts{DATA.expid(j)}.Trials));
        Frs(j) = DATA.Expts{DATA.expid(j)}.Stimvals.Fr;
    end
    if length(unique(Frs))
        for j = ids(1:end)
            DATA.Expts{DATA.expid(j)}= FillTrials(DATA.Expts{DATA.expid(j)},'Fr');
        end
    end
    j = DATA.expid(ids(end));
    DATA.combineids = DATA.expid(ids);
    if length(DATA.extype) == 1
    DATA.allcombineids{DATA.extype} = DATA.combineids;
    end
    Expt.Header = DATA.Expts{j}.Header;
    Trials = [];
    Pulses = [];
    nb = 1;
    Clusters = {};
    if DATA.plot.autoclustermode < 3
        DATA.autocut = 1;
    else
        DATA.autocut = 0;
    end
    counts = {}; nspk = 0;
    for j = ids(1:end)
        BlockStart(nb) = DATA.Expts{DATA.expid(j)}.Trials(1).Trial;
        exped(nb) = GetEval(DATA.Expts{DATA.expid(j)},'ed');
        Header = DATA.Expts{DATA.expid(j)}.Header;
        if isfield(DATA.Expts{DATA.expid(j)},'Cluster')
                Clusters{nb} = DATA.Expts{DATA.expid(j)}.Cluster;
                recount = 0;
        end
        if DATA.autocut & (size(Clusters) < nb | size(Clusters{nb},2) < DATA.probe ...
                | isempty(Clusters{nb}) | isempty(Clusters{nb}{1,DATA.probe}) | ~isfield(Clusters{nb}{1,DATA.probe},'x'))
            DATA = AutoCut(DATA,DATA.expid(j),j);
            Clusters{nb} = DATA.Expts{DATA.expid(j)}.Cluster;
            recount = 1;
        else
            recount = 0;
        end
        if DATA.state.online == 0 | recount
            [DATA, counts{j}] = CountSpikes(DATA,DATA.expid(j)); %% recount in case cluster # changed
            
        end
%tfields is the combined fields of all expts (above). Sao any differences
%mean it is missing from the current Expt;
        newf = setdiff(tfields, fields(DATA.Expts{DATA.expid(j)}.Trials));
        newtrials = DATA.Expts{DATA.expid(j)}.Trials;
        for k = 1:length(newf)
            if strcmp(newf{k},'FalseStart')
            [newtrials.(newf{k})] = deal(0);
            else
            [newtrials.(newf{k})] = deal([]);
            end
        end
        Trials = [Trials newtrials];
        if isfield(DATA.Expts{DATA.expid(j)},'ExcludeId')
        end
        if isfield(DATA.Expts{DATA.expid(j)},'Pulses')
            Pulses = [Pulses DATA.Expts{DATA.expid(j)}.Pulses];
        end
        if Header.trange(1) < Expt.Header.trange(1)
            Expt.Header.trange(1) = Header.trange(1);
        end
        if Header.trange(2) > Expt.Header.trange(2)
            Expt.Header.trange(2) = Header.trange(2);
        end
        nb = nb+1;
    end
    for j = 1:length(counts)
        for k = 1:length(counts{j})
            nspk(j,k) = counts{j}(k);
        end
    end
    eid = DATA.expid(ids(end));
    Expt.Stimvals = Stimvals;
    Expt.Trials = Trials;
    Expt.Header.Name = BuildName(DATA.Expts{eid}.Header.Name);
    Expt.Header.BlockStart = BlockStart;
    Expt.Header.depths = exped;
    Expt.Header.Clusters = Clusters;
    Expt.Header.Combined = ids;
    Expt.Header.Combineids = DATA.expid(ids);
    Expt.Header.Spikelist = DATA.spikelist;
    Expt.Header.CombineDate = now;
    Expt.Header.nspk = sum(nspk);
    if isfield(DATA,'Comments') & isfield(DATA.Comments,'Peninfo')
        Expt.Header.Peninfo = DATA.Comments.Peninfo;
                    id = strfind(DATA.Comments.Peninfo.trode,'Contact');
            if length(id)
                x = id(1);
                id = strfind(DATA.Comments.Peninfo.trode(id:end),' ');
                sscanf(DATA.Comments.Peninfo.trode(id+x:end),'%d',x);
                Expt.Header.probesep = x;
            end
    end

    if ~DATA.state.online & ~isfield(DATA,'AllClusters')
    Expt.Header.SpkStats = GetSpkStats(DATA);
    end
    if isfield(Expt.Trials,'FalseStart')
        id = find([Expt.Trials.FalseStart] > 0);
        if ~isempty(id)
            for j = 1:length(id)
                Expt.Trials(id(j)).Start = Expt.Trials(id(j)).Start - Expt.Trials(id(j)).FalseStart;
            end
            msgbox(sprintf('%s,%s: %d Trials with long delays',Expt.Header.Name,Expt.Header.expname,length(id)));
        end
    end
    if ~isempty(Pulses)
        Expt.Pulses = Pulses;
    end
    if ~isfield(Expt.Header,'Spike2Version')
        Expt.Header.Spike2Version = 1.0;
    end
    
    if DATA.state.uselfp & length(ids) > 0  %reload LFP to match lengths etc
        Expt = LoadSpike2LFP(Expt,'reload');
    end
    id = strmatch(DATA.Expts{eid}.Header.expname,DATA.expstrs,'exact');
    if Stimvals.BlockedStim
        DATA.outname = Expt2FileName(DATA, Expt, DATA.spikelist(1));
        set(DATA.saveitem,'string',DATA.outname);
    end
    [Expt, plotres] = PlotCombined(DATA, Expt);
    if DATA.state.autofit
        fit = FitExpt(plotres,'plotfit');
        DATA = AddFitToData(DATA, plotres,fit);
    end
  
function [Expt, res] = PlotCombined(DATA, Expt)
res = [];

 if isfield(Expt,'ExcludeCluster')
    for j = 1:length(Expt.ExcludeCluster{1})
        id = find([Expt.Trials.Trial] == Expt.ExcludeCluster{1}(j));
        if id
            Expt.Trials(id).Trial = -Expt.Trials(id).Trial;
        end
    end
 end
 if ismember(DATA.plot.showcp,[5 6]) & isfield(Expt.Trials,'RespDir')
     psfargs = {};
     on = get(findobj('Tag','ShowN','Parent',DATA.toplevel),'value');
     if on
         psfargs = {psfargs{:} 'shown'};
     end
     GetFigure(DATA.tag.psych);
     hold off;
     if DATA.plot.showcp == 6
         ExptPsych(Expt, 'smooth',10,psfargs{:});
     else
         ExptPsych(Expt,psfargs{:});
     end
     return;
 end
    GetFigure(DATA.tag.dataplot);
    args = PlotArgs(DATA,Expt);
    res = PlotExpt(Expt,args{:});
    if DATA.state.plotseq == 4 & isfield(res,'fig')
        set(res(1).fig, 'WindowButtonDownFcn',@@FigButtonPressed);
        set(res(1).fig, 'WindowButtonUpFcn',@@FigButtonReleased);
        dat = get(res(1).fig,'UserData');
        dat.parentfigtag = DATA.tag.top;
        set(res(1).fig,'UserData',dat);
    end
    t = get(get(gca,'title'),'String');
    spikelist = WhichClusters(DATA.toplevel);
    edepth = GetEval(Expt,'ed');
%    title([t 'Cl' sprintf(' %d',WhichClusters(DATA.toplevel))]);
    title([t sprintf(' P%d',DATA.probe) sprintf(' Cl %d',spikelist) sprintf('ed %.2f',edepth)]);
    if DATA.plot.showem
        GetFigure(DATA.tag.emplot);
        Expt = LoadEmData(Expt);
        PlotExptEM(Expt);
    end
    if DATA.state.uselfp
        GetFigure('LFP');
        hold off;        
        CalcLFPPulse(Expt,DATA.AllData,'plot');
        if size(Expt.Trials(1).LFP,2) > 5
            if DATA.plot.lfpplot == 1
                PlotMLFP(Expt,'stack',0);
            elseif DATA.plot.lfpplot ==2
                PlotMLFP(Expt,'image');
            end
        end
    end
        
%    save(DATA.outname,'Expt'); %use save to do the saving....

    
   
function DATA = ReadDir(DATA, name, varargin)  %% Online Plots

d = dir(name);
reindex = 0;
args = {};
j = 1;

while j <= nargin-2
        if strncmpi(varargin{j},'relist',3)
            reindex =1;
            args = {args{:} 'relist'};
        else
            args = {args{:} varargin{j}};
        end
    j = j+1;
end
    expnames = {};
    if isempty(DATA.Expts)
        nexp = 1;
        SpkId = [];
        Spikes = [];
        Trialids = [];
    else
        for j=1:length(DATA.Expts)
            expnames{j} = splitpath(DATA.Expts{j}.Header.Name);
 %           DATA.Expts{j}.gui.classified = 0;
 % don't reset this here - resets clusters for files already read. Reset
 % it below only when a file is read.
        end
        nexp = j+1;
        SpkId = DATA.AllData.SpikeIdx;
        Spikes = DATA.AllData.Spikes;
        Trialids = DATA.AllData.Trialids;
        All = DATA.AllData;
        Expts = DATA.Expts;
    end
    DATA.defaults.starttrial = 1;
    lastn = nexp;
    nbad = length(DATA.badnames)+1;
    badidx = 1:nbad-1;
    for j = 1:length(d)
        if regexp(d(j).name,'Expt[0-9]*.mat') & ...
                d(j).bytes > 128 & .....
                isempty(strfind(d(j).name,'idx.mat')) & ...    %exclude the .idx file
                d(j).datenum < now-(1/(24 * 60 * 60)) & ... %at least  1 sec old
                isempty(strmatch(d(j).name,{expnames{:} DATA.badnames{badidx}}))     %dont read if we already have
            [trls, exps, All] = APlaySpkFile([name '/' d(j).name],'Defaults',DATA.defaults,'online',args{:});
            if isempty(exps)
                fprintf('%s No expts\n',d(j).name);
                DATA.badnames{nbad} = d(j).name;
                nbad = nbad+1;
            else
                Expts{nexp} = exps{1};
                Expts{nexp}.gui.classified = 0;
                Expts{nexp}.gui.counted = 0;
                Expts{nexp}.gui.clustertype = 0;
                SpkId = [SpkId; trls.Spkid];
                newt = [Expts{nexp}.Trials.Trial];
                Trialids = [Trialids newt];
                if nexp > 1 && isfield(Spikes,'values') && size(Spikes.values,2) == size(All.Spikes.values,2)
                    Spikes.values = [Spikes.values; All.Spikes.values];
                    if isfield(All.Spikes,'dVdt')
                    Spikes.dVdt = [Spikes.dVdt; All.Spikes.dVdt];
                    end
                    Spikes.codes = [Spikes.codes; All.Spikes.codes];
                    Spikes.times = [Spikes.times; All.Spikes.times];
                else
                    Spikes = All.Spikes;
                end

                nexp = nexp+1;
                DATA.defaults.starttrial = 1+ exps{1}.Trials(end).Trial;
                
                         if isfield(trls,'Probes');
                             for j = 1:length(trls.Probes)
                                 probenames{trls.Probes(j).probe} = trls.Probes(j).var;
                                 Probes(trls.Probes(j).probe) = trls.Probes(j);
                             end
                         end

            end
        end
    end

    if exist('probenames','var') %ca be empty for online relist
    np = 0;
    probes = [];
    for j = 1:length(probenames)
        if ~isempty(probenames{j})
            np = np+1;
            DATA.probes(np) = Probes(j);
            probes = [probes j];
        end
    end
                DATA.probelist = probes;
            DATA.probevars = {probenames{probes}};
            DATA.probenames = cellstr(int2str(probes'));
            if sum(DATA.probelist == DATA.probe) == 0 % current probe not in list
                DATA.probe = DATA.probelist(1);
            end
%            DATA.probes = Probes;
            if length(DATA.probelist) > 1 
                AddMultiProbeGUI(DATA);
            end

    end
it = findobj(DATA.toplevel,'Tag','ProbeId');
            set(it,'string',DATA.probenames);


    if nexp == 1
        questdlg(sprintf('No expts in %s',name),'test','OK','OK');
    else
        DATA = ListExpts(DATA,Expts);
        DATA.Expts = Expts;
        DATA.AllData = All;
        DATA.AllData.Spikes = Spikes;
        DATA.AllData.SpikeIdx = SpkId;
        DATA.AllData.Trialids = Trialids;
        if DATA.state.autoplot && DATA.state.online == 1
            for j = lastn:nexp-1
              DATA = SetExptSpikes(DATA, j, 0);
            end
        end
    end
    DATA.name = name;
    DATA.state.online = 1;
    

    
function PlotSpike(DATA, ispk, probe)

    set(0,'CurrentFigure',DATA.svfig);
    if nargin == 2
    j = DATA.AllData.Spikes.codes(ispk,2)+1;
    if DATA.plot.dvdt == 2
          set(DATA.svh(j), 'Ydata', DATA.AllData.Spikes.dVdt(ispk,:),'Xdata',DATA.AllData.Spikes.values(ispk,2:end));
    elseif DATA.plot.dvdt
          set(DATA.svh(j), 'Ydata', DATA.AllData.Spikes.dVdt(ispk,:),'Xdata',[1:size(DATA.AllData.Spikes.dVdt,2)]);
    else
        set(DATA.svh(j), 'Ydata', DATA.AllData.Spikes.values(ispk,:),'Xdata',[1:size(DATA.AllData.Spikes.values,2)]);
    end
    title(sprintf('%d: Cl %d at %.3f',ispk,j-1,DATA.AllData.Spikes.times(ispk)/10000)); 
    else
        j = DATA.AllSpikes{DATA.probe}.codes(ispk,2)+1;
        set(DATA.svh(j), 'Ydata', DATA.AllSpikes{probe(1)}.values(ispk,:)-DATA.plot.SpikeMaxV/2,'Xdata',[1:size(DATA.AllSpikes{probe(1)}.values,2)]);
        id = find(ispk == DATA.sids{1});
        if length(id)
            jspk = DATA.sids{2}(id);
        set(DATA.svh(j+DATA.nclusters+1), 'Ydata', DATA.AllSpikes{probe(2)}.values(jspk,:)+DATA.plot.SpikeMaxV/2,'Xdata',[1:size(DATA.AllSpikes{probe(2)}.values,2)]);
        end
        title(sprintf('%d: Cl %d at %.3f',ispk,j-1,DATA.AllSpikes{DATA.probe}.times(ispk)/10000));
    end
    drawnow;

function PlayNextSpike(a,b)
%DATA = combine('getstate');
DATA = GetDataFromFig(a);
if DATA.ISIpair
    PlotISIPair(DATA,DATA.ISIpair);
    DATA.ISIpair = DATA.ISIpair+1;
    set(DATA.toplevel,'UserData',DATA);
    return;
end
set(0,'CurrentFigure',DATA.svfig);
if isfield(DATA,'AllSpikes')
    PlotSpike(DATA,DATA.currentspike,[DATA.probe DATA.xprobes]);
else
PlotSpike(DATA,DATA.currentspike);
if isfigure(DATA.xyfig)
    set(0,'CurrentFigure',DATA.xyfig);
    PlotSpikeXY(DATA,DATA.currentspike,DATA.spkcolor{DATA.AllData.Spikes.codes(DATA.currentspike,2)+1});
end
end
DATA.currentspike = DATA.currentspike+1;
set(DATA.toplevel,'UserData',DATA);

function PlotISIPair(DATA, pair)

GetFigure(DATA.tag.spikev);
hold off;
spk = find(DATA.AllData.Spikes.times >= floor(DATA.isis(pair)));
spk = spk(1);
tsmp = [1:size(DATA.AllData.Spikes.values,2)] * DATA.AllData.Spikes.interval * 10000;
plot(tsmp,DATA.AllData.Spikes.values(spk-1,:));
[a,ta] = max(DATA.AllData.Spikes.values(spk-1,:));
[b,tb] = max(DATA.AllData.Spikes.values(spk,:));
    hold on;
isi = diff(DATA.AllData.Spikes.times([spk-1 spk]));
times = isi+tsmp+20000*DATA.AllData.Spikes.interval;
isi = isi + (tb-ta) * DATA.AllData.Spikes.interval * 10000;
plot(times,DATA.AllData.Spikes.values(spk,:));
title(sprintf('Time %.0f ISI %.1f',DATA.AllData.Spikes.times(spk-1),isi));

function CutTrial(a,b)
%DATA = combine('getstate');
DATA = GetDataFromFig(a);

t = DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial;
DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial = -abs(t);
it = findobj(DATA.svfig,'Tag','ChooseTrial');
set(it,'string',sprintf('%d|',[DATA.Expts{DATA.currentexpt}.Trials.Trial]),'value',1);
set(DATA.toplevel,'UserData',DATA);
PlayOneTrial(DATA,a,1);
        
function PlayLastTrial(a, b)
DATA = GetDataFromFig(a);
PlayOneTrial(DATA, a,-1);

function PlayNextTrial(a, b)
DATA = GetDataFromFig(a);
PlayOneTrial(DATA,a,1);

function SelectTrial(a, b)
DATA = GetDataFromFig(a);
c = get(findobj('Tag','ChooseTrial'),'value');
PlayOneTrial(DATA,c,0);

function PlayOneTrial(DATA, a, b)
%DATA = combine('getstate');
expid = DATA.currentexpt;

if b < 0  & DATA.currenttrial > 1 %step back
    DATA.currenttrial = DATA.currenttrial-1;
    while DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial < 0 & DATA.currenttrial > 1 
        DATA.currenttrial = DATA.currenttrial-1;
    end
elseif b > 0 & DATA.currenttrial < length(DATA.Expts{DATA.currentexpt}.Trials) %step back
    DATA.currenttrial = DATA.currenttrial+1;
    while DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial < 0 &  ...
            DATA.currenttrial < length(DATA.Expts{DATA.currentexpt}.Trials) 
        DATA.currenttrial = DATA.currenttrial+1;
    end
elseif b == 0 % step to a trial on list
    DATA.currenttrial = find([DATA.Expts{DATA.currentexpt}.Trials.Trial] == a);    
    DATA.currenttrial = a;    
end
if DATA.currenttrial <= 0
    DATA.currenttrial = 1;
end
Trial = DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial);
if Trial.Trial < 0 && b == 0 %%manually select -Trial = include again
    DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial = abs(Trial.Trial);
    it = findobj(DATA.svfig,'Tag','ChooseTrial');
    set(it,'string',sprintf('%d|',[DATA.Expts{expid}.Trials.Trial]),'value',1);
end
itrial = find(DATA.AllData.Trialids == abs(Trial.Trial));
set(0,'CurrentFigure',DATA.svfig);
hold off;
%DATA = PlotTrialSpikes(DATA, itrial, mycolors, DATA.clusters);
if DATA.state.recut
    nc = size(DATA.cluster,1)+1;
else
    nc = DATA.s2clusters;
end
Trial.ed = GetEval(DATA.Expts{DATA.currentexpt},'ed',DATA.currenttrial);
probes =  [DATA.probe DATA.xprobes];
if length(probes) > 1 & DATA.plot.syncoverlay == 0
    Aargs = {'timemode'};
    if  ~isfield(DATA,'timefig')
        DATA.timefig = GetFigure('SpikeTime');
    end
    set(0,'CurrentFigure',DATA.timefig);
else
    Aargs = {};
end
 
if DATA.syncsign < 2
    PlotTrialSyncSpikes(DATA, [Trial.Start(1) Trial.End(end)], [DATA.probe DATA.xprobes], mycolors,'Trial',Trial);
else
for j = 2:length(probes)
DATA = APlotTrialSpikes(DATA, [Trial.Start(1) Trial.End(end)], mycolors, nc, 1,'Trial',Trial,'probe',[probes(j) j length(probes)],'lineoff',(j-1)*(1+DATA.nclusters), Aargs{:});
end
DATA = APlotTrialSpikes(DATA, [Trial.Start(1) Trial.End(end)], mycolors, nc, 1,'Trial',Trial,'probe',[probes(1) 1 length(probes)],Aargs{:});
end
if length(probes) > 1 %also show spikes over time
    for j = 1:length(probes)
        DATA = APlotTrialSpikes(DATA, [Trial.Start(1) Trial.End(end)], mycolors, nc, 0,'Trial',Trial,'probe',[probes(j) j length(probes)],'lineoff',(j-1)*(1+DATA.nclusters),'timemode');
    end
end
if DATA.state.uselfp
    PlotLFP(DATA.state,Trial,DATA.Expts{expid}.Header.LFPsamplerate);
end
set(DATA.toplevel,'UserData',DATA);
set(0,'CurrentFigure',DATA.svfig);
tid = DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).id;
it = findobj(DATA.svfig,'Tag','ChooseTrial');
set(it,'value',DATA.currenttrial);
    
function DATA = PlotTrialSpikes(DATA, itrial, colors, clusters)
    spka = DATA.AllData.SpikeIdx(itrial,1);
    spkb = DATA.AllData.SpikeIdx(itrial,2);
    Spks = DATA.AllData.Spikes;
    if spka
        for spk = spka:spkb;
            adc = Spks.values(spk,:);
            plot(adc,'color',colors{Spks.codes(spk,1)+1});
            hold on;
            energy  = sum(diff(adc).^2);
            DATA.Spikes.energy(spk)= energy;
            svar(spk) = var(adc);
            DATA.Spikes.vw(spk) = svar(spk)/energy;
        end
        title(sprintf('Trial %d (id%d)',DATA.AllData.Trialids(itrial),...
            DATA.AllData.Trialids(itrial)));

        drawnow;


        set(0,'CurrentFigure',DATA.xyfig);
        for j = 1:length(clusters)
            sp = intersect(clusters{j},[spka:spkb]);
            plot(DATA.Spikes.energy(sp),DATA.Spikes.vw(sp),'.','color',colors{j});
        end
    end

function [x,DATA] = GetSpikeVals(DATA, ispk, values, dVdt, type, recalc)

SPKENERGY=1;
SPKVARE=2;
SPKMAXRATE = 3;
SPKPREMINRATE = 4;
SPKPEAKTIME = 5;
SPKPREMIN = 6;
SPKPEAK = 7;
SPKVAR = 8;
SPKSYMMETRY = 9;
SPKCENTROID = 10;
SPKCENTROID = 10;

SPKMINRATE = 11;
SPKMAXRATEA = 12;
SPKMINRATEA = 13;
SPKMEANRATEA = 14;
SPKMAXRATEB = 15;
SPKMINRATEB = 16;
SPKMEANRATEB = 17;
SPKMEANA = 18;
SPKMEANB = 19;
SPKMAXA = 20;
SPKMAXB = 21;
SPKMIN =22;
SPKMINA = 23;
SPKMINB = 24;
SPKHEIGHT = 25;
SPKENERGYA=26;
SPKENERGYB=27;
SPKPREMAXRATE = 28;
TEMPLATEA = 29;
TEMPLATEB = 30;
TEMPLATEC = 31;
SPKVARTESTA= 32;
SPKVARTESTB= 33;


if isnan(values) %% return names
    x = {'Energy' 'Var/Energy' 'MaxRate' 'PreMinRate' 'PeakTime' 'PreMin' 'Peak' 'Var' 'Symmetry' 'Centroid' 'Minrate' 'Maxrate(A)' ... 
    'Minrate(A)' 'Meanrate(A)' 'Maxrate(B)' 'Minrate(B)' 'Meanrate(B)' 'Mean(A)'...
    'Mean(B)' 'Max(A)' 'Min(A)' 'Min' 'Max(B)' 'Min(B)' 'Height' 'EnergyA' 'EnergyB' 'PreMaxRate' ...
    'Template 1' 'Template 2' 'Template 3' 'test1' 'test2'};
  return;
end


p = DATA.probe;
if p > size(DATA.cluster,2)
    DATA.cluster{DATA.currentcluster,p} = {};
end

if DATA.currentcluster > size(DATA.cluster,1) || (~isfield(DATA.cluster{DATA.currentcluster,p},'Arange') & isfield(DATA.cluster{1,p},'Arange'))
    DATA.cluster{DATA.currentcluster,p}.Arange = DATA.cluster{1,p}.Arange;
    DATA.cluster{DATA.currentcluster,p}.Brange = DATA.cluster{1,p}.Brange;
    DATA.cluster{DATA.currentcluster,p}.Erange = DATA.cluster{1,p}.Erange;
end
arange = DATA.clusterArange;
brange = DATA.clusterBrange;
splen = size(values,2);
erange = intersect(DATA.clusterErange,1:splen-1);    
    

%dVdt and values are already just teh values for ispk
%ispk is only sent so that the correct entries in DATA.Spikes are 
%filled in
if type == SPKENERGY
    if recalc
        x  = sum(dVdt(:,erange).^2,2);
        DATA.Spikes.energy(ispk)= x;
    else
        x = DATA.Spikes.energy(ispk);
    end
elseif type == SPKENERGYA
    [mins, imins] = min(values'); 
    imins(find(imins<6)) = 6;
    imins(find(imins>26)) = 26;
    for j = 1:size(dVdt,1)
        x(j)  = sum(dVdt(j,imins(j)-5:imins(j)+5).^2,2);
    end
        DATA.Spikes.energy(ispk)= x;
elseif type == SPKVARE
    if recalc
        x = var(values(:,erange)');
        x = x./DATA.Spikes.energy(ispk);
        DATA.Spikes.vw(ispk) = x;
    else
        x = DATA.Spikes.vw(ispk);
    end
elseif type == SPKMAXRATE
    x = max(dVdt(:,:)');
elseif type == SPKPREMINRATE %min rate value preceding max rate value;
    [x,t] = max(dVdt(:,:)');
    for j = 1:length(t)
        x(j) = min(dVdt(j,1:t(j)));
    end
elseif type == SPKPREMAXRATE %MAX rate preceding peak V
    [x,t] = max(values(:,:)');
    t(find(t > size(dVdt,2))) = size(dVdt,2);
    for j = 1:length(t)
        x(j) = max(dVdt(j,1:t(j)));
    end
elseif type == SPKMAXRATEA
    x = max(dVdt(:,arange)');
elseif type == SPKMAXRATEB
    x = max(dVdt(:,brange)');
elseif type == SPKMINRATE
    x = min(dVdt(:,:)');
elseif type == SPKMINRATEA
    x = min(dVdt(:,arange)');
elseif type == SPKMINRATEB
    x = min(dVdt(:,brange)');
elseif type == SPKMEANA
    x = mean(values(:,arange)');
elseif type == SPKMEANB
    x = mean(values(:,brange)');
elseif type == SPKMEANRATEA
    x = mean(dVdt(:,arange)');
elseif type == SPKMEANRATEB
    x = mean(dVdt(:,brange)');
elseif type == SPKMAXA
    x = max(values(:,arange)');
elseif type == SPKMAXB
    x = max(values(:,brange)');
elseif type == SPKMIN
    x = min(values(:,:)');
    if DATA.plot.nodc
        x = x - mean(values');
    end
elseif type == SPKMINA
    x = min(values(:,arange)');
elseif type == SPKMINB
    x = min(values(:,brange)');
elseif type == SPKPREMIN
    [x,t] = max(dVdt(:,:)');
    for j = 1:length(t)
        x(j) = min(values(j,1:t(j)));
    end
elseif type == SPKPEAKTIME
    [x,t] = max(dVdt(:,:)');
    zc = diff(sign(dVdt(:,:)')); 
    len = size(zc,1);
    for j = 1:length(t)
        tm = find(zc(:,j) < 0 & [1:len]' >= t(j));
        if isempty(tm)
            x(j) = 0;
        else
            x(j) = tm(1); % first zero crossing after peakrate
        end
    end
elseif type == SPKPEAK
    [x,t] = max(values(:,:)');
elseif type == SPKHEIGHT
    [x,t] = max(values(:,:)');
    [y,t] = min(values(:,:)');
    x = x-y;
elseif type == SPKVAR
    x = var(values(:,:)');
elseif type == SPKSYMMETRY
  len =  size(dVdt,2);
  cn  = round(sum((dVdt(:,:).^2)*[1:len]',2)./sum(dVdt(:,:).^2,2));
  for j = 1:length(ispk)
  z(j) = mean(values(j,max([cn(j)-5 1]):cn(j)),2);
  y(j) = mean(values(j,cn(j):min([cn(j)+5 len])),2);
  end
  x = atan2(y,z);
elseif type == SPKCENTROID
  len =  size(dVdt,2);
  x  = sum((dVdt(:,:).^2)*[1:len]',2)./sum(dVdt(:,:).^2,2);
elseif ismember(type, [TEMPLATEA TEMPLATEB TEMPLATEC])
    j = 1+type-TEMPLATEA;
    x = values * DATA.Templates(j,:)';
end

function [x,DATA] = OldGetSpikeVals(DATA, ispk, type, recalc)

SPKENERGY=1;
SPKVARE=2;
SPKMAXRATE = 3;
SPKPREMINRATE = 4;
SPKPEAKTIME = 5;
SPKPREMIN = 6;
SPKPEAK = 7;
SPKVAR = 8;
SPKSYMMETRY = 9;
SPKCENTROID = 10;
SPKCENTROID = 10;

SPKMINRATE = 11;
SPKMAXRATEA = 12;
SPKMINRATEA = 13;
SPKMEANRATEA = 14;
SPKMAXRATEB = 15;
SPKMINRATEB = 16;
SPKMEANRATEB = 17;
SPKMEANA = 18;
SPKMEANB = 19;
SPKMAXA = 20;
SPKMAXB = 21;
SPKMIN =22;
SPKMINA = 23;
SPKMINB = 24;
SPKHEIGHT = 25;
SPKPREMAXRATE = 26;
SPKVARTESTA= 27;
SPKVARTESTB= 28;


if isnan(ispk) %% return names
    x = {'Energy' 'Var/Energy' 'MaxRate' 'PreMinRate' 'PeakTime' 'PreMin' 'Peak' 'Var' 'Symmetry' 'Centroid' 'Minrate' 'Maxrate(A)' ... 
    'Minrate(A)' 'Meanrate(A)' 'Maxrate(B)' 'Minrate(B)' 'Meanrate(B)' 'Mean(A)'...
    'Mean(B)' 'Max(A)' 'Min(A)' 'Min' 'Max(B)' 'Min(B)' 'Height' 'test1' 'test2'};
  return;
end


p = DATA.probe;
if p > size(DATA.cluster,2)
    DATA.cluster{DATA.currentcluster,p} = {};
end

if DATA.currentcluster > size(DATA.cluster,1) || (~isfield(DATA.cluster{DATA.currentcluster,p},'Arange') & isfield(DATA.cluster{1,p},'Arange'))
    DATA.cluster{DATA.currentcluster,p}.Arange = DATA.cluster{1,p}.Arange;
    DATA.cluster{DATA.currentcluster,p}.Brange = DATA.cluster{1,p}.Brange;
    DATA.cluster{DATA.currentcluster,p}.Erange = DATA.cluster{1,p}.Erange;
end
arange = DATA.clusterArange;
brange = DATA.clusterBrange;
splen = size(DATA.AllData.Spikes.values,2);
erange = intersect(DATA.clusterErange,1:splen-1);    
    

if type == SPKENERGY
    if recalc
        x  = sum(DATA.AllData.Spikes.dVdt(ispk,erange).^2,2);
        DATA.Spikes.energy(ispk)= x;
    else
        x = DATA.Spikes.energy(ispk);
    end
elseif type == SPKVARE
    if recalc
        x = var(DATA.AllData.Spikes.values(ispk,erange)');
        x = x./DATA.Spikes.energy(ispk);
        DATA.Spikes.vw(ispk) = x;
    else
        x = DATA.Spikes.vw(ispk);
    end
elseif type == SPKMAXRATE
    x = max(DATA.AllData.Spikes.dVdt(ispk,:)');
elseif type == SPKPREMINRATE
    [x,t] = max(DATA.AllData.Spikes.dVdt(ispk,:)');
    for j = 1:length(t)
        x(j) = min(DATA.AllData.Spikes.dVdt(ispk(j),1:t(j)));
    end
elseif type == SPKPREMAXRATE
    [x,t] = max(DATA.AllData.Spikes.values(ispk,:)');
    for j = 1:length(t)
        x(j) = max(DATA.AllData.Spikes.dVdt(ispk(j),1:t(j)));
    end
elseif type == SPKMAXRATEA
    x = max(DATA.AllData.Spikes.dVdt(ispk,arange)');
elseif type == SPKMAXRATEB
    x = max(DATA.AllData.Spikes.dVdt(ispk,brange)');
elseif type == SPKMINRATE
    x = min(DATA.AllData.Spikes.dVdt(ispk,:)');
elseif type == SPKMINRATEA
    x = min(DATA.AllData.Spikes.dVdt(ispk,arange)');
elseif type == SPKMINRATEB
    x = min(DATA.AllData.Spikes.dVdt(ispk,brange)');
elseif type == SPKMEANA
    x = mean(DATA.AllData.Spikes.values(ispk,arange)');
elseif type == SPKMEANB
    x = mean(DATA.AllData.Spikes.values(ispk,brange)');
elseif type == SPKMEANRATEA
    x = mean(DATA.AllData.Spikes.dVdt(ispk,arange)');
elseif type == SPKMEANRATEB
    x = mean(DATA.AllData.Spikes.dVdt(ispk,brange)');
elseif type == SPKMAXA
    x = max(DATA.AllData.Spikes.values(ispk,arange)');
elseif type == SPKMAXB
    x = max(DATA.AllData.Spikes.values(ispk,brange)');
elseif type == SPKMIN
    x = min(DATA.AllData.Spikes.values(ispk,:)');
elseif type == SPKMINA
    x = min(DATA.AllData.Spikes.values(ispk,arange)');
elseif type == SPKMINB
    x = min(DATA.AllData.Spikes.values(ispk,brange)');
elseif type == SPKPREMIN
    [x,t] = max(DATA.AllData.Spikes.dVdt(ispk,:)');
    for j = 1:length(t)
        x(j) = min(DATA.AllData.Spikes.values(ispk(j),1:t(j)));
    end
elseif type == SPKPEAKTIME
    [x,t] = max(DATA.AllData.Spikes.dVdt(ispk,:)');
    zc = diff(sign(DATA.AllData.Spikes.dVdt(ispk,:)')); 
    len = size(zc,1);
    for j = 1:length(t)
        tm = find(zc(:,j) < 0 & [1:len]' >= t(j));
        if isempty(tm)
            x(j) = 0;
        else
            x(j) = tm(1); % first zero crossing after peakrate
        end
    end
elseif type == SPKPEAK
    [x,t] = max(DATA.AllData.Spikes.values(ispk,:)');
elseif type == SPKHEIGHT
    [x,t] = max(DATA.AllData.Spikes.values(ispk,:)');
    [y,t] = min(DATA.AllData.Spikes.values(ispk,:)');
    x = x-y;
elseif type == SPKVAR
    x = var(DATA.AllData.Spikes.values(ispk,:)');
elseif type == SPKSYMMETRY
  len =  size(DATA.AllData.Spikes.dVdt,2);
  cn  = round(sum((DATA.AllData.Spikes.dVdt(ispk,:).^2)*[1:len]',2)./sum(DATA.AllData.Spikes.dVdt(ispk,:).^2,2));
  for j = 1:length(ispk)
  z(j) = mean(DATA.AllData.Spikes.values(ispk(j),max([cn(j)-5 1]):cn(j)),2);
  y(j) = mean(DATA.AllData.Spikes.values(ispk(j),cn(j):min([cn(j)+5 len])),2);
  end
  x = atan2(y,z);
elseif type == SPKCENTROID
  len =  size(DATA.AllData.Spikes.dVdt,2);
  x  = sum((DATA.AllData.Spikes.dVdt(ispk,:).^2)*[1:len]',2)./sum(DATA.AllData.Spikes.dVdt(ispk,:).^2,2);
end


function DATA = PlotSpikes(DATA, ispk)

    classify = 1;
    ctype = 2;
    [cx, DATA] = GetSpikeVals(DATA,ispk, DATA.AllSpikes.values(ispk,:),DATA.AllSpikes.dVdt(ispk,:), DATA.plot.clusterX, classify);
    DATA.Spikes.cx(ispk) = cx;
    %      [cy, DATA] = GetSpikeVals(DATA,ispk, SPKVARE, classify);
    [cy, DATA] = GetSpikeVals(DATA,ispk, DATA.AllSpikes.values(ispk,:),DATA.AllSpikes.dVdt(ispk,:),DATA.plot.clusterY, classify);
    DATA.Spikes.cy(ispk) = cy;
    DATA.currentspike = ispk(1);
    DATA = SetSpkCodes(DATA,ispk,DATA.probe,0);
    nc =  length(DATA.cluster)+1;
    DrawSpikeWaves(DATA, ispk, nc, 2);
    
    set(0,'CurrentFigure',DATA.xyfig);
    for j = 0:nc
        sp = find(DATA.AllData.Spikes.codes(ispk, ctype) == j);
        plot(cx(sp),cy(sp),...
            '.','color',DATA.spkcolor{j+1},'markersize',DATA.ptsize);
        hold on; %% need this when called from PlotOneTrial
    end

    function DrawSpikeWaves(DATA, ispk, nclusters, ctype)
    for j = 1:nclusters+1
        vs{j} = [];
        xs{j} = [];
    end
    splen = size(DATA.AllData.Spikes.values,2);
    adc = DATA.AllData.Spikes.values(ispk,:);
    dvdt = DATA.AllData.Spikes.dVdt(ispk,:);
    for spk = 1:length(ispk);
        j = DATA.AllData.Spikes.codes(ispk(spk), ctype)+1;
        if DATA.plot.dvdt
            vs{j} = [vs{j} dvdt(spk,:) NaN];
            xs{j} = [xs{j} [1:splen-1] NaN];
        else
            vs{j} = [vs{j} adc(spk,:) NaN];
            xs{j} = [xs{j} [1:splen] NaN];
        end
    end
    set(0,'CurrentFigure',DATA.svfig);
    nc = min([nclusters+1 length(DATA.svh)]);
    for j = 1:nc
        if ~isempty(xs{j})
            if ishandle(DATA.svh(j))
                set(DATA.svh(j),'Xdata' , xs{j}, 'Ydata', vs{j});
            else
                DATA.svh(j) = line('Xdata' , xs{j}, 'Ydata', vs{j});
            end
        elseif ishandle(DATA.svh(j)) %no spikes, wipe clean
            set(DATA.svh(j),'Xdata' , 0, 'Ydata', 0);
        end
    end
    drawnow;

function [ispk, sspk,cx, cy] = PlotTrialSyncSpikes(DATA, times, probes, colors, varargin)

SPKMIN=22;
SPKPEAK=7;
    
    nv = 32;
    dt = 2;
    j=1;
    ctype = 2;
    step = DATA.plot.SpikeMaxV;
    if DATA.plot.syncoverlay
        timemode = 0;
    else
        timemode = 1;
    end
    while j <= length(varargin)
    if strncmpi(varargin{j},'lineoff',6)
        j = j+1;
        lineoff = varargin{j};
    elseif strncmpi(varargin{j},'Probe',4)
        j = j+1;
        probe = varargin{j};
    elseif strncmpi(varargin{j},'Trial',4)
        j = j+1;
        Trial = varargin{j};
    end
    j = j+1;
    end

    if isfield(DATA,'sids') && isfield(DATA,'AllSpikes')
        ai = find(DATA.AllSpikes{probes(1)}.times(DATA.sids{1}) > times(1) ...
            & DATA.AllSpikes{probes(1)}.times(DATA.sids{1}) < times(2));
        for j = 1:length(probes)
            sids{j} = DATA.sids{j}(ai);
            ispks{j} = find(DATA.AllSpikes{probes(j)}.times > times(1) ...
                & DATA.AllSpikes{probes(j)}.times < times(2));
            itimes{j} = DATA.AllSpikes{probes(j)}.times(sids{j});
        end
        ispk = ispks{1};
    else
    for j = 1:length(probes)
        if DATA.spikelist == -1
            spikelist = [0 1 2 3 4];
        else
            spikelist = DATA.spikelist;
        end
        ispks{j} = find(DATA.AllSpikes{probes(j)}.times > times(1) &...
            DATA.AllSpikes{probes(j)}.times < times(2) & ...
            ismember(DATA.AllSpikes{probes(j)}.codes(:,2),spikelist));
        itimes{j} = DATA.AllSpikes{probes(j)}.times(ispks{j});
    end
    iids = [];
    dts{1} = zeros(size(itimes{1}));
    for p = 2:length(ispks)
        ids = [];
        for j = 1:length(itimes{1})
            id = find(abs(itimes{p}-itimes{1}(j)) < dt);
            if length(id)
                ids = [ids id(1)];
                dts{p}(length(ids)) = (itimes{p}(id(1))-itimes{1}(j)) * nv/10;
                iids = [iids j];
            end
        end
        sids{p} = ispks{p}(ids);
    end
    sids{1} = ispks{1}(iids);
    end
    if ~isempty(sids{1})
        if timemode
            set(0,'CurrentFigure',DATA.timefig);
            vh = DATA.tvh;
        else
            set(0,'CurrentFigure',DATA.svfig);
            vh = DATA.svh;
        end
        nc = (length(probes)-1)/2;
    for j = 1:length(probes)
        vs{j} = [];
        xs{j} = [];
        dts{j} = itimes{j} - itimes{1};
       for k = 1:length(sids{j});
           spk = sids{j}(k);
           if DATA.plot.syncoverlay
           vs{j} = [vs{j} DATA.AllSpikes{probes(j)}.values(spk,:)+(j-nc-1)*step NaN];
            xs{j} = [xs{j} [1:nv]-dts{j}(k) NaN];
           else
           vs{j} = [vs{j} DATA.AllSpikes{probes(j)}.values(spk,:) NaN];
            xs{j} = [xs{j} (k-1)*nv + [1:nv]-dts{j}(k) NaN];
            end
                end

                
    if j > length(DATA.svh)
        vh(j) = line('Xdata' , xs{j}, 'Ydata', vs{j});
    else
        if ishandle(DATA.svh(j))
            set(vh(j),'Xdata' , xs{j}, 'Ydata', vs{j});
        end
    end
    end
    if length(xs{1})
        set(gca,'xlim',[1 max(xs{1})]);
    end
    end
    sspk = cat(2,sids{:});
   nspk = length(sids{1});
   title(sprintf('Trial %d (id%d %.2f - %.2f) ed%.3f %d/%d spks',abs(Trial.Trial),...
       Trial.id,Trial.Start(1)./10000,Trial.End(end)./10000,Trial.ed,nspk,length(ispk)));

   cx = [];
   cy = [];
   if DATA.plot.synccluster == 1 %min/min
        [cx, DATA] = GetSpikeVals(DATA,sids{1}, DATA.AllSpikes{probes(1)}.values(sids{1},:), DATA.AllSpikes{probes(1)}.dVdt(sids{1},:),SPKMIN, 0);
        [cy, DATA] = GetSpikeVals(DATA,sids{2}, DATA.AllSpikes{probes(2)}.values(sids{2},:), DATA.AllSpikes{probes(2)}.dVdt(sids{2},:),SPKMIN, 0);
   elseif DATA.plot.synccluster == 4 %PCA1 spk1 vs 2
        cx = DATA.pca(3,ai);
        cy = DATA.pca(4,ai);
   elseif DATA.plot.synccluster == 5 %PCA2 1 vs 2
        cx = DATA.pca(5,ai);
        cy = DATA.pca(6,ai);
   elseif DATA.plot.synccluster == 6 %PCA 1 vs PCA2
        cx = DATA.pca(1,ai);
        cy = DATA.pca(2,ai);
   elseif DATA.plot.synccluster == 7 %PCA vs xcorr
        cx = DATA.pca(1,ai);
        cy = DATA.AllSpikes{probes(1)}.values(sids{1},:) .* DATA.AllSpikes{probes(2)}.values(sids{2},:);
        cy = sum(cy');
   elseif DATA.plot.synccluster == 8 %Current Cluster X, for each probe
        cx  = GetSpikeVals(DATA,sids{1}, DATA.AllSpikes{probes(1)}.values(sids{1},:), DATA.AllSpikes{probes(1)}.dVdt(sids{1},:),DATA.plot.clusterX, 1);
        cy  = GetSpikeVals(DATA,sids{2}, DATA.AllSpikes{probes(2)}.values(sids{2},:), DATA.AllSpikes{probes(2)}.dVdt(sids{2},:),DATA.plot.clusterX, 1);
   elseif DATA.plot.synccluster == 9 %Current Cluster Y, for each probe
        cx  = GetSpikeVals(DATA,sids{1}, DATA.AllSpikes{probes(1)}.values(sids{1},:), DATA.AllSpikes{probes(1)}.dVdt(sids{1},:),DATA.plot.clusterY, 1);
        cy  = GetSpikeVals(DATA,sids{2}, DATA.AllSpikes{probes(2)}.values(sids{2},:), DATA.AllSpikes{probes(2)}.dVdt(sids{2},:),DATA.plot.clusterY, 1);
   elseif DATA.plot.synccluster == 10 %Current Cluster Plot for sum
       V = (DATA.AllSpikes{probes(1)}.values(sids{1},:)+DATA.AllSpikes{probes(2)}.values(sids{2},:))/2;
       dV= ( DATA.AllSpikes{probes(1)}.dVdt(sids{1},:)+ DATA.AllSpikes{probes(2)}.dVdt(sids{2},:))/2;
        cx  = GetSpikeVals(DATA,sids{1}, V, dV, DATA.plot.clusterX, 1);
        cy  = GetSpikeVals(DATA,sids{1}, V, dV, DATA.plot.clusterY, 1);
   else
        [cx, DATA] = GetSpikeVals(DATA,sids{1}, DATA.AllSpikes{probes(1)}.values(sids{1},:), DATA.AllSpikes{probes(1)}.dVdt(sids{1},:),DATA.plot.clusterX, 0);
        [cy, DATA] = GetSpikeVals(DATA,sids{1}, DATA.AllSpikes{probes(1)}.values(sids{1},:), DATA.AllSpikes{probes(1)}.dVdt(sids{1},:),DATA.plot.clusterY, 0);
   end
   if length(cx) & length(cy)
   set(0,'CurrentFigure',DATA.xyfig);
   for j = 0:length(DATA.cluster{probes(1)})+1
       sp = find(DATA.AllSpikes{probes(1)}.codes(sids{1}, ctype) == j);
       plot(cx(sp),cy(sp),...
           '.','color',DATA.spkcolor{j+1},'markersize',DATA.ptsize);
       hold on; %% need this when called from PlotOneTrial
   end
   end
   drawnow;
    
function [DATA, ispk] = APlotTrialSpikes(DATA, times, colors, nclusters, classify, varargin)

j = 1;
Trial = [];
probe = DATA.probe;
lineoff = 0;
step = DATA.plot.SpikeMaxV;
timemode = 0;
nprobes = 1;
ip = 1;
while j <= length(varargin)
    if strncmpi(varargin{j},'lineoff',6)
        j = j+1;
        lineoff = varargin{j};
    elseif strncmpi(varargin{j},'Probes',6)
        j = j+1;
        probe = varargin{j};
    elseif strncmpi(varargin{j},'Probe',4)
        j = j+1;
        probe = varargin{j}(1);
        if length(varargin{j}) > 1
            ip = varargin{j}(2); % # in list
        end
        if length(varargin{j}) > 2
            nprobes = varargin{j}(3);
        end
    elseif strncmpi(varargin{j},'timemode',4)
        timemode = 1;
    elseif strncmpi(varargin{j},'Trial',4)
        j = j+1;
        Trial = varargin{j};
    end
    j = j+1;
end
if DATA.state.recut
    ctype = 2;
else
    ctype = 1;
end
if isfield(DATA,'AllSpikes')
    Spks = DATA.AllSpikes{probe(1)};
elseif DATA.probe == 100
    Spks = DATA.AllData.UstimV;
else
    Spks = DATA.AllData.Spikes;
end

if ~isfield(Spks,'values')
    ispk = [];
    return;
end
splen = size(Spks.values,2);
% try calculating energy for all spikes in Expt in one step.
ispk = find(Spks.times > times(1) &...
        Spks.times < times(2));
if isfield(DATA,'AllClusters')
    return;
end
    if ispk
if isfield(DATA,'sids') 
    syncspk = find(ismember(ispk,DATA.sids{ip}));
    syncspklst = ismember(ispk,DATA.sids{ip});
    if length(probe) == 2
        Spks.values = (DATA.AllSpikes{probe(1)}.values(DATA.sids{1},:)+DATA.AllSpikes{probe(2)}.values(DATA.sids{2},:))/2;
        Spks.times =  DATA.AllSpikes{probe(1)}.times(DATA.sids{1});
        ispk = find(Spks.times > times(1) &...
            Spks.times < times(2));
    end
    if ismember(DATA.syncsign,[3 4 5])
    Spks.codes(ispk,3) = 0;
    Spks.codes(ispk(syncspk),3) = 1;
    ctype = 3;
    end
end

if DATA.probe < 100
        [cx, DATA] = GetSpikeVals(DATA,ispk, Spks.values(ispk,:), Spks.dVdt(ispk,:),DATA.plot.clusterX, classify);
        DATA.Spikes.cx(ispk) = cx;
  %      [cy, DATA] = GetSpikeVals(DATA,ispk, SPKVARE, classify);
        [cy, DATA] = GetSpikeVals(DATA,ispk, Spks.values(ispk,:), Spks.dVdt(ispk,:),DATA.plot.clusterY, classify);
        DATA.Spikes.cy(ispk) = cy;
            dvdt = Spks.dVdt(ispk,:);
        if length(ispk)
        DATA.currentspike = ispk(1);
        end
            adc = Spks.values(ispk,:);
% recut == 2 means that clusters are not set here, but clusters have
% been defined (previous list), so use those properites.
         if DATA.state.recut == 2 && DATA.probe == probe
             DATA = SetSpkCodes(DATA,ispk, DATA.probe,0);
             if isfield(DATA,'AllSpikes') %copy any changes into spks
                 Spks.codes = DATA.AllSpikes{DATA.probe}.codes
             else
                 Spks.codes = DATA.AllData.Spikes.codes;
             end
         end
else
    Spks.codes = DATA.AllData.UstimV.codes;
            adc = Spks.values(ispk,:);
            cx = zeros(size(ispk));
            cy = zeros(size(ispk));
end

         
        for j = [1:nclusters+1]
            vs{j} = [];
            xs{j} = [];
        end
        for spk = 1:length(ispk);
            if DATA.syncsign < 2 & isfield(DATA,'sids')
                j = syncspklst(spk)+1;
            else
                j = Spks.codes(ispk(spk), ctype)+1;
            end
            if DATA.plot.dvdt ==2
                vs{j} = [vs{j} dvdt(spk,:) NaN];
                xs{j} = [xs{j} adc(spk,1:splen-1) NaN];
            elseif DATA.plot.dvdt
                vs{j} = [vs{j} dvdt(spk,:) NaN];
                xs{j} = [xs{j} [1:splen-1] NaN];
            elseif timemode
                vs{j} = [vs{j} adc(spk,:) NaN];
                xs{j} = [xs{j} [1:splen]+(Spks.times(ispk(spk))-times(1)).*timemode NaN];
            elseif DATA.plot.nodc
            vs{j} = [vs{j} adc(spk,:)-mean(adc(spk,:)) NaN];
            xs{j} = [xs{j} [1:splen] NaN];
            else
            vs{j} = [vs{j} adc(spk,:) NaN];
            xs{j} = [xs{j} [1:splen] NaN];
            end
        end
        for j = [1:nclusters+1]
            vs{j} = vs{j}+(ip-(nprobes+1)/2).*step;
        end
        if timemode && isfield(DATA,'timefig')
        set(0,'CurrentFigure',DATA.timefig);
        text(0,(ip-(nprobes+1)/2).*step,sprintf('%d',probe));
        vh = DATA.tvh;
        else
        set(0,'CurrentFigure',DATA.svfig);
        vh = DATA.svh;
        end
        nc = min([nclusters+1 length(DATA.svh)]);
  
    
        for j = 1:nc
            k = j+lineoff;
            if k > length(vh)
                    vh(k) = line('Xdata' , xs{j}, 'Ydata', vs{j});
            elseif ~isempty(xs{j}) 
                if ishandle(vh(k))
                    set(vh(k),'Xdata' , xs{j}, 'Ydata', vs{j});
                else
                    vh(k) = line('Xdata' , xs{j}, 'Ydata', vs{j});
                end
            elseif vh(k) && ishandle(vh(k)) %no spikes, wipe clean
                    set(vh(k),'Xdata' , 0, 'Ydata', 0);
            end
        end
        if ~isempty(Trial)
            nspk = sum(Spks.codes(ispk,2) == DATA.currentcluster);
            title(sprintf('Trial %d (id%d %.2f - %.2f) ed%.3f %d/%d spks',abs(Trial.Trial),...
                Trial.id,Trial.Start(1)./10000,Trial.End(end)./10000,Trial.ed,nspk,length(ispk)));
        end        

        if probe == DATA.probe
        drawnow;
        set(0,'CurrentFigure',DATA.xyfig);
        for j = 0:nclusters
            sp = find(Spks.codes(ispk, ctype) == j);
            plot(cx(sp),cy(sp),...
                '.','color',DATA.spkcolor{j+1},'markersize',DATA.ptsize);
            hold on; %% need this when called from PlotOneTrial
        end
        end
    end
    DATA.minplottime = 0.00;
    if DATA.minplottime > 0.001
        while toc < DATA.minplottime
        end
    end
            
                
function spikelist = WhichClusters(top,varargin)

spikelist = [];

if get(findobj(top,'Tag','UseCluster0'),'value')
    spikelist = [spikelist 0];
end
if get(findobj(top,'Tag','UseCluster1'),'value')
    spikelist = [spikelist 1];
end
if get(findobj(top,'Tag','UseCluster2'),'value')
    spikelist = [spikelist 2];
end
if get(findobj(top,'Tag','UseCluster3'),'value')
    spikelist = [spikelist 3];
end
if get(findobj(top,'Tag','UseCluster4'),'value')
    spikelist = [spikelist 4];
end
if isempty(spikelist)
    spikelist = -1;
end


function [meanrate, proportion] = SumExptSpikes(DATA, expid, cluster)
    cspks = DATA.Expts{expid}.gui.spks;
    ctype = 2;
    j = 1;
    for trial = [DATA.Expts{expid}.Trials]
        if isfield(DATA,'AllClusters')
        ispk = find(DATA.AllClusters(DATA.probe).times(cspks) > trial.Start(1) & DATA.AllClusters(DATA.probe).times(cspks) < trial.End(end)+500);
        ispks(j) = sum(DATA.AllClusters(DATA.probe).codes(cspks(ispk)) == cluster);
        elseif isfield(DATA,'AllSpikes')
        ispk = find(DATA.AllSpikes{DATA.probe}.times(cspks) > trial.Start(1) & DATA.AllSpikes{DATA.probe}.times(cspks) < trial.End(end)+500);
        ispks(j) = sum(DATA.AllSpikes{DATA.probe}.codes(cspks(ispk),ctype) == cluster);
        else
        ispk = find(DATA.AllData.Spikes.times(cspks) > trial.Start(1) & DATA.AllData.Spikes.times(cspks) < trial.End(end)+500);
    ispks(j) = sum(DATA.AllData.Spikes.codes(cspks(ispk),ctype) == cluster);
        end
    aspks(j) = length(ispk);
    dur(j) = trial.End(end)-trial.Start(1);
    j = j+1;
    end
    meanrate = 10000.* mean(ispks)./mean(dur);
    proportion = sum(ispks)./sum(aspks);
    
function [DATA, counts] = CountSpikes(DATA, expid, varargin)

%can be using AllData.Spikes, but have no spikes
    if ~isempty(DATA.AllData.Spikes) && length(DATA.AllData.Spikes.codes) == 0
        counts = 0;
        return;
    end
replot = 0;
j = 1;
while j <= nargin -2
    if strncmp(varargin{j},'replot',3)
        replot = 1;
    end
    j = j+1;
end

nt = 1;
if DATA.state.recut
    ctype = 2;
else
    ctype = 1;
end
if  DATA.state.online == 2
return;
end
if DATA.Expts{expid}.gui.classified == 0
   DATA = SetExptSpikes(DATA, expid, 0);
end

if isfield(DATA,'AllSpikes')
Spks = DATA.AllSpikes{DATA.probe};
else
Spks = DATA.AllData.Spikes;
end

if isempty(Spks)
    counts = 0;
    return;
end
spikelist = WhichClusters(DATA.toplevel);
alli = [];
for trial = [DATA.Expts{expid}.Trials]
    ispk = find(Spks.times > trial.Start(1) & Spks.times < trial.End(end)+500);
    alli = [alli; ispk];
    ispks = find(ismember(Spks.codes(ispk,ctype),spikelist));
    DATA.Expts{expid}.Trials(nt).Spikes = round(Spks.times(ispk(ispks)) - trial.Start(1));
    spks = DATA.Expts{expid}.Trials(nt).Spikes;
    DATA.Expts{expid}.Trials(nt).count = sum(spks > 500);
    ispks = find(~ismember(Spks.codes(ispk,ctype),spikelist));
    DATA.Expts{expid}.Trials(nt).OSpikes = round(Spks.times(ispk(ispks)) - trial.Start(1));
    if DATA.state.recut
        DATA.Expts{expid}.Trials(nt).Ocodes = Spks.codes(ispk(ispks),2);
    else
        DATA.Expts{expid}.Trials(nt).Ocodes = Spks.codes(ispk(ispks),1);
    end
    nt = nt+1;
end
if replot
    GetFigure(DATA.tag.dataplot);
    args = PlotArgs(DATA, DATA.Expts{expid});
    PlotExpt(DATA.Expts{expid},args{:});
    t = get(get(gca,'title'),'String');
    title([t sprintf(' P%d',DATA.probe) sprintf(' Cl %d',spikelist)]);
end
DATA.Expts{expid}.gui.counted = sum(spikelist);
DATA.Expts{expid}.gui.spks = alli;
DATA.spikelist = spikelist;

nc = max(Spks.codes(alli,2));
counts(1) = sum(Spks.codes(alli,2) == 0);
if nc
for j = 1:nc
    counts(j+1) = sum(Spks.codes(alli,2) == j);
end
end
DATA.Expts{expid}.gui.spkcounts = counts;
DATA.Expts{expid}.gui.nclusters = nc;

function nc = CountClusters(Cluster)
    nc = 0;
if isempty(Cluster)
    nc = 0;
else
    for k = 1:size(Cluster,2)
        ncs(k) = 0;
    for j = 1:size(Cluster,1)
        if isfield(Cluster{j,k},'x')
            ncs(k) = j;
        end
    end
    end
    nc = max(ncs);
end

function outname = Expt2FileName(DATA,Expt, cluster)

    [expname, extype, suff] = Expt2Name(Expt);
    it = strmatch(extype,DATA.expstrs,'exact');
    if length(it)
        expname = strrep(expname,extype,DATA.expnames{it(1)});
    end
    if DATA.state.includeprobename
        cs = ['.p' num2str(DATA.probe) 'c'];
    else
        cs = '.c';
    end
    outname = [strrep(DATA.datafilename,'.mat',cs) num2str(cluster) '.' expname suff '.mat'];
    
    
function outname = CombinedName(DATA,eid,cluster, varargin)

probe = DATA.probe;
j = 1;
while j <= length(varargin)
    if strncmpi(varargin{j},'probe',5)
        j = j+1;
        probe = varargin{j};
    end
    j = j+1;
end
    
suff = '';
it = strmatch(DATA.exptypelist{eid(1)},DATA.expstrs,'exact');
if ~isempty(it)
    expname = DATA.expnames{it};
else
    expname = DATA.exptypelist{eid(1)};
end
stimname = strrep(DATA.explist{eid(1)},['.' DATA.exptypelist{eid(1)}],'');
if strfind(stimname,'RC')
    stimname = strrep(stimname,'RC','');
    suff = 'RC';
end
if isempty(strfind(expname,stimname))
    expname = [stimname '.' expname];
end
if DATA.state.includeprobename
    cs = ['.p' num2str(probe) 'c'];
else
    cs = '.c';
end
if DATA.state.online
outname = [DATA.datafilename '/' expname suff cs num2str(cluster) '.mat'];
else
outname = [strrep(DATA.datafilename,'.mat',cs) num2str(cluster) '.' expname suff '.mat'];
end


function SetExptClusters(caller,b)
%DATA = combine('getstate');
DATA = GetDataFromFig(caller);
nc = CountClusters(DATA.cluster);
DATA.Expts{DATA.currentexpt}.gui.ncluster = nc;
DATA.cluster{DATA.currentcluster,DATA.probe}.autocut = 0;

touched = zeros(size(DATA.probelist));
if isfield(DATA,'AllClusters') || isfield(DATA,'AllSpikes') % only save clusters that have been set
for k = 1:nc
    for j = 1:size(DATA.cluster,2)
        if  isfield(DATA.cluster{k,j}, 'touched') &&DATA.cluster{k,j}.touched
        DATA.Expts{DATA.currentexpt}.Cluster{k,j} = DATA.cluster{k,j};
          touched(j) = 1;
        end
    end
end
else
        DATA.Expts{DATA.currentexpt}.Cluster = DATA.cluster;
end
DATA.Expts{DATA.currentexpt}.gui.clustertype = 1;
DATA.Expts{DATA.currentexpt}.gui.classified = 1;
spkvarnames= DATA.spkvarnames;
p = DATA.probe;
for j = 1:length(DATA.Expts)
    if isfield(DATA.Expts{j},'Cluster') 
        enc =  CountClusters(DATA.Expts{j}.Cluster);
        AllClusters{j}.Cluster = DATA.Expts{j}.Cluster(1:enc,:);
        AllClusters{j}.ids = [DATA.Expts{j}.Trials(1).id DATA.Expts{j}.Trials(end).id];
        clustertypes(j) = DATA.Expts{j}.gui.clustertype;
    end
    excludelist{j}  = find([DATA.Expts{j}.Trials.Trial] < 0);
end
if isfield(DATA,'AllSpikes')  %need to save all probes with a new cluster
    for j = find(touched)
        if isfield(DATA.AllSpikes{j},'times')
        f = DATA.AllSpikes{j}.firstspki;
        clid(f:f+size(DATA.AllSpikes{j}.times,1)-1) = DATA.AllSpikes{j}.codes(:,2);
        save(ClusterFile(DATA,'probe',j),'AllClusters','clustertypes','excludelist','clid','spkvarnames');
        end
    end
elseif isfield(DATA,'AllClusters')  %need to save all probes with a new cluster
    for j = find(touched)
        clid = DATA.AllClusters(j).codes(:,2);
        save(ClusterFile(DATA),'AllClusters','clustertypes','excludelist','clid','spkvarnames');
    end
elseif isfield(DATA.AllData.Spikes, 'codes')
clid = DATA.AllData.Spikes.codes(:,2);
save(ClusterFile(DATA),'AllClusters','clustertypes','excludelist','clid','spkvarnames');
else
save(ClusterFile(DATA),'AllClusters','clustertypes','excludelist','clid','spkvarnames');
end
if length(DATA.probelist) > 1
save(ClusterFile(DATA,'allprobes'),'AllClusters','spkvarnames');
end

if DATA.logfid
    fprintf(DATA.logfid,'Cluster set for P%d Expt %d %s\n',DATA.probe,DATA.currentexpt,datestr(now));
end

% now re-do list of su-expts to reflect cut clusters
eid = get(DATA.clst,'value');
DATA = ListSubExpts(DATA,eid,'relist');
set(DATA.toplevel,'UserData',DATA);
cid = findobj('Tag','ClusterIsSet');
set(cid,'value',1);


function DelClusterButton(caller,b)
it = findobj('Tag','Clusterid');
c = get(it,'value');
DeleteCluster(c, caller);

function ClrSpkWin(caller,b)
%DATA = combine('getstate');
if isstruct(caller)
    DATA = caller;
else
    DATA = GetDataFromFig(caller);
end
GetFigure(DATA.tag.clusterxy);
ym = get(gca,'ylim');
xm = get(gca,'xlim');
hold off;
plot(0,0,'+');
set(gca,'ylim',ym);
set(gca,'xlim',xm);
hold on;
DrawClusters(DATA,DATA.cluster, 0);


function cfile = ClusterFile(DATA,varargin)
getonline = 0;
getauto = 0;
allprobes = 0;
probe = DATA.probe;
j = 1;
while j <= length(varargin)
    if strncmpi(varargin{j},'auto',4) %Read Clusters from Online mat file
        getauto = 1;
    elseif strncmpi(varargin{j},'allprobes',4) %Read Clusters from Online mat file
        allprobes = 1;
    elseif strncmpi(varargin{j},'getonline',4) %Read Clusters from Online mat file
        getonline = 1;
    elseif strncmpi(varargin{j},'probe',4) %Read Clusters from Online mat file
        j = j+1;
        probe = varargin{j};
    end
    j = j+1;
end
if DATA.state.online == 0 %%not online data
    if getonline
        [a,b] = splitpath(DATA.datafilename);
        if length(b)
        cfile = [b '/OnlineClusters.mat'];
        else
        cfile = 'OnlineClusters.mat';
        end
    elseif getauto
        cfile = strrep(DATA.datafilename,'.mat','.autocl.mat');
    elseif length(DATA.probelist) > 1 && allprobes
        cfile = strrep(DATA.datafilename,'.mat','.allcl.mat');
    elseif length(DATA.probelist) > 1 
        cfile = strrep(DATA.datafilename,'.mat',['.p' num2str(probe) 'cl.mat']);
    else
        cfile = strrep(DATA.datafilename,'.mat','.cl.mat');
    end
else
    cfile = [DATA.datafilename '/Clusters.mat'];
end

function cfile = CombinerLst(DATA)
if isfield(DATA,'datafilename') %%not online data
    cfile = strrep(DATA.datafilename,'.mat','.combine.mat');
else
    cfile = [DATA.datafilename '/combine.mat'];
end

function DATA = CalcClusterVars(DATA, ispk, varargin)
SPKENERGY=1;
SPKVARE = 2;
noforce  = 1;
j = 1;
probe = DATA.probe;
while j <= length(varargin)
    if isstruct(varargin{j}) & isfield(varargin{j},'values')
        j = j+1;
        Spikes = varargin{j};
    elseif strncmpi(varargin{j},'force',5)
        noforce = 0;
    elseif strncmpi(varargin{j},'probe',5)
        j =j+1;
        probe = varargin{j};
    end
    j = j+1;
end

if isfield(DATA,'AllClusters') && noforce % All calculated and stored, but No ADCs, so
  return;
end

if length(ispk) == 2
    ispk = ispk(1):ispk(2);
end
if ispk
   
    if isfield(DATA,'AllSpikes')
        Spikes = DATA.AllSpikes{probe};
    else
        Spikes = DATA.AllData.Spikes;
    end
    adc = Spikes.values(ispk,:);
    if isfield(DATA.AllData.Spikes,'dVdt')
        energy  = sum(Spikes.dVdt(ispk,:)'.^2);
    else
    energy  = sum(diff(adc').^2);
    end
    svar = var(adc');
    DATA.Spikes.energy(ispk)= energy;
    if DATA.plot.clusterX == SPKENERGY
        DATA.Spikes.cx(ispk)= energy;
    else
        DATA.Spikes.cx(ispk)= GetSpikeVals(DATA, ispk, Spikes.values(ispk,:), Spikes.dVdt(ispk,:),DATA.plot.clusterX, 1);
    end
    DATA.Spikes.vw(ispk) = svar./energy;
    if DATA.plot.clusterY == SPKVARE
        DATA.Spikes.cy(ispk)= DATA.Spikes.vw(ispk);
    else
        DATA.Spikes.cy(ispk)= GetSpikeVals(DATA, ispk, Spikes.values(ispk,:), Spikes.dVdt(ispk,:),DATA.plot.clusterY, 1);
    end
    if isfield(DATA,'AllSpikes')
        lastspk = min([length(DATA.AllSpikes{probe}.times) length(DATA.Spikes.cx)]);
        DATA.AllSpikes{probe}.cx = DATA.Spikes.cx(1:lastspk);
        DATA.AllSpikes{probe}.cy = DATA.Spikes.cy(1:lastspk);
    end
end

function [x,y, DATA] = GetClusterSpace(DATA, Expt)


    x = DATA.plot.clusterX;
    y = DATA.plot.clusterY;
    p = DATA.probe;
    if isfield(Expt,'Cluster') & ~isempty(Expt.Cluster)
        j = 1;
        while j < size(Expt.Cluster,1) && isempty(Expt.Cluster{j,p})
            j = j+1;
        end
        if j <= size(Expt.Cluster,1) & p <= size(Expt.Cluster,2) & ~isempty(Expt.Cluster{j,p}) & isfield(Expt.Cluster{j,p},'params')
            x = Expt.Cluster{j,p}.params(1);
            y = Expt.Cluster{j,p}.params(2);
            DATA.clusterArange = Expt.Cluster{j,p}.Arange;
            DATA.clusterBrange = Expt.Cluster{j,p}.Brange;
            if isfield(Expt.Cluster{j,p},'Erange')
                DATA.clusterErange = Expt.Cluster{j,p}.Erange;
            end
        end
    else
        x = DATA.plot.clusterX;
        y = DATA.plot.clusterY;
    end
       
function set = ClusterIsSet(Expt, probe)

if isfield(Expt,'Cluster') && length(Expt.Cluster) >= probe && ...
        ~isempty(Expt.Cluster{1,probe}) && isfield(Expt.Cluster{1,probe},'x')
    set = 1;
else
    set = 0;
end
   
function ispk = FindSpikes(DATA, times, probe)

if isfield(DATA,'AllSpikes')
    if isempty(DATA.AllSpikes{probe}) | ~isfield(DATA.AllSpikes{probe},'times')
        ispk = [];
        return;
    end
    ispk = find(DATA.AllSpikes{probe}.times > times(1) &...
    DATA.AllSpikes{probe}.times < times(2));
elseif isfield(DATA,'AllClusters')
    ispk = find(DATA.AllClusters(probe).times > times(1) &...
    DATA.AllClusters(probe).times < times(2));
elseif isempty(DATA.AllData.Spikes) || ~isfield(DATA.AllData.Spikes,'times')
    ispk = [];
else
    ispk = find(DATA.AllData.Spikes.times > times(1) &...
    DATA.AllData.Spikes.times < times(2));
end
        

function [DATA, ispk, dprime, details] = SetExptSpikes(DATA, expid, show)

    details = [];
    dprime = 0;
    ispk = [];
    for j = 1:length(DATA.Expts{expid}.Trials)
        times(1) = DATA.Expts{expid}.Trials(j).Start(1)-500;
        times(2) = DATA.Expts{expid}.Trials(j).End(end)+500;
        tspk = FindSpikes(DATA, times, DATA.probe);
        ispk = [ispk; tspk];
    end
DATA.Expts{expid}.gui.spkrange = [min(ispk) max(ispk)];
DATA.Expts{expid}.gui.spks = ispk;
if ischar(show) & strcmp(show,'setrange');
    return;
end

if ~isfield(DATA,'spklist') | isempty(DATA.spklist)
    DATA.spklist = ispk;
end

DATA = CalcClusterVars(DATA,  ispk);
% if a cluster is set for this expt, use it.
% otherwise use the current one
cl = DATA.currentcluster;
if ClusterIsSet(DATA.Expts{expid}, DATA.probe)
    if ~isempty(DATA.Expts{expid}.gui.spkrange) && iscluster(DATA.Expts{expid}.Cluster,cl,DATA.probe) && ...
        DATA.Expts{expid}.Cluster{cl,DATA.probe}.lastspk < DATA.Expts{expid}.gui.spkrange(1)
        DATA.Expts{expid}.Cluster{cl,DATA.probe}.lastspk = DATA.Expts{expid}.gui.spkrange(2);
    end
    DATA.cluster = DATA.Expts{expid}.Cluster;
    
    DATA.Expts{expid}.gui.classified = 1;
elseif size(DATA.cluster,2) < DATA.probe
    DATA.cluster{1,DATA.probe} = NewClusterStruct(DATA);
elseif isfield(DATA.cluster{1,DATA.probe},'x') 
% actually is a cluster defined, but not yet applied to this expt
% make sure spk range is correct
    DATA.Expts{expid}.gui.classified = 2;
    if length(ispk)
    DATA.cluster{1,DATA.probe}.firstspk = ispk(1);
    DATA.cluster{1,DATA.probe}.lastspk = ispk(end);
    else
    DATA.cluster{1,DATA.probe}.firstspk = NaN;
    DATA.cluster{1,DATA.probe}.lastspk = NaN;
    end
end
if DATA.state.recut
    DATA.currentexpt = expid;
    [DATA, dprime, details] = SetSpkCodes(DATA,ispk,DATA.probe,show);
end


function C = NewClusterStruct(DATA)
        C.firstspk = NaN;
        C.lastspk = NaN;

function DATA = DrawClusters(DATA, cluster, setfig)
if setfig
    set(0,'CurrentFigure',DATA.xyfig);
end
p = DATA.probe;
for j = 1:size(cluster,1)
    if p > size(cluster,2) 
        C = [];
    else
        C = cluster{j,p};
    end
    while ~isempty(C)
    if isfield(C,'params')
        color = DATA.spkcolor{j+1};
        if isfield(C,'touched') & C.touched == 0
%            color = color + (1-color)./2;
            color = color./2;
        end
        if C.params(1) == DATA.plot.clusterX & ...
                C.params(2) == DATA.plot.clusterY
            h = DrawCluster(C,color);
            if(h)
                DATA.cluster{j,p}.h = h;
            end
            hold on;
        end
    end
    if isfield(C,'Cluster')
        C = C.Cluster;
    else
        C ={};
    end
    end
end

function h =  DrawCluster(cluster, color)

h =0;
if isempty(cluster) | ~isfield(cluster,'x')
    return;
end
if isfield(cluster,'h') & ishandle(cluster.h)
    delete(cluster.h);
end
tmp.r = [cluster.x(2) cluster.y(2)];
tmp.c = [cluster.x(1) cluster.y(1)];
tmp.xrange = cluster.x(3);
tmp.yrange = cluster.y(3);
tmp.angle = -cluster.angle;
tmp.color = color;
tmp = myellipse(tmp);
h = tmp.lasth;

function DATA = PlaySpikes(DATA, expid)

global mousept;

mode = 2;
cw = DATA.plot.cw;
ch = DATA.plot.ch;
rh = ch+10;
[xyfig, isnew] = GetFigure(DATA.tag.clusterxy);
DATA.xyfig = xyfig;
if isnew
        if ~isfield(DATA,'figpos') | isempty(DATA.figpos{2})
        bp = get(DATA.toplevel,'Position');
        fp = get(xyfig,'Position');
       DATA.figpos{2} =  [bp(1)+bp(3) bp(2)+bp(4)-fp(4) fp(3) fp(4)];
       if sum(DATA.figpos{2}([2 4]))+100 > DATA.gui.scrsz(4)
           DATA.figpos{2}(2) = DATA.gui.scrsz(4) - fp(4) - 100;
       end
        set(xyfig,'Position',DATA.figpos{2});
        end
    bp = [5 5 40 20];
    cp = bp;
    uicontrol(xyfig,'style','pop','string','1|2|3|4|5|6|7','Position',bp,'Tag','Clusterid',...
        'Callback',@@Update);
    cp(2) = cp(2)+rh;
    uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@DensityPlot, ...
'String', 'Dens','Tag','Density', 'Position', cp);
    cp(2) = cp(2)+rh;
    uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@NextList, ...
'String', 'Next', 'Position', cp);
    cp(2) = cp(2)+rh;
    uicontrol(gcf,'style','pushbutton','string','spool','Position',cp,'Tag','SpoolSpikes',...
        'Callback', @@SpoolSpikes);
    cp(2) = cp(2)+rh;
    uicontrol(gcf,'style','pushbutton','string','Optim','Position',cp,'Tag','OptimizeDprime',...
        'Callback', @@OptimizeDprimeHit);

    bp(1) = bp(1) + bp(3) + 10;
    uicontrol(xyfig,'style','pushbutton','string','Set','Position',bp,'Callback', @@SetExptClusters);
    bp(1) = bp(1) + bp(3) + 10;
    bp(3)=cw;
    uicontrol(xyfig,'style','CheckBox','Position',bp,'Tag','ClusterIsSet');
    bp(1) = bp(1) + bp(3) + 10;
    bp(3)=cw*3;
    uicontrol(xyfig,'style','pushbutton','string','Del','Position',bp,'Callback', @@DelClusterButton);
    bp(1) = bp(1) + bp(3) + 10;
    uicontrol(xyfig,'style','pushbutton','string','Clr','Position',bp,'Callback', @@ClrSpkWin);
    bp(1) = bp(1) + bp(3) + 10;
    bp(3)=cw*5;
    uicontrol(xyfig,'style','text','string','Max: X','Position',bp);
    bp(1) = bp(1) + bp(3);
    uicontrol(xyfig,'style','edit','string',sprintf('%.2f',DATA.plot.clusterXrange(2)),'Position',bp,...
    'Callback', @@RescaleClusterPlot,'Tag','ClusterXmax');

    bp(1) = bp(1) + bp(3) + 10;
    bp(3) = cw*1;
    uicontrol(xyfig,'style','text','string','Y','Position',bp);
    bp(1) = bp(1) + bp(3);
    bp(3) = cw*4;
    uicontrol(xyfig,'style','edit','string',sprintf('%.2f',DATA.plot.clusterYrange(2)),'Position',bp,...
    'Callback', @@RescaleClusterPlot,'Tag','ClusterYmax');
    bp(1) = bp(1) + bp(3) + 10;
    bp(3) = cw*1;
    uicontrol(xyfig,'style','text','string','Z','Position',bp);
    bp(1) = bp(1) + bp(3);
    bp(3) = cw*4;
    uicontrol(xyfig,'style','edit','string',sprintf('%.2f',DATA.plot.clusterZrange(2)),'Position',bp,...
    'Callback', @@RescaleClusterPlot,'Tag','ClusterZmax');
    bp(1) = bp(1) + bp(3);
    bp(3) = cw*5;
    uicontrol(xyfig,'style','CheckBox','string','auto','Position',bp,'Tag','AutoScale',...
        'value',DATA.plot.autoscale,'Callback',@@Update);
    bp(1) = bp(1) + bp(3) + 10;
    tmpdat.parentfigtag = DATA.tag.top;
    set(xyfig,'UserData',tmpdat);
end
hold off;
%if isempty(findobj('Tag',DATA.tag.spikev
 %   sfig = figure('Renderer','painters','Tag','DATA.tag.spikev');
[sfig, isnew] = GetFigure(DATA.tag.spikev);
if isnew
   if ~isfield(DATA,'figpos') | length(DATA.figpos) < 3 | isempty(DATA.figpos{3})
        bp = get(DATA.toplevel,'Position');
        fp = get(sfig,'Position');
       DATA.figpos{3} =  [bp(1) bp(2)-fp(4)-80 fp(3) fp(4)];
        set(sfig,'Position',DATA.figpos{3});
    end

    x = 10;
    c = 10;
    bp = [10 10 40 20];
    uicontrol(sfig,'style','pushbutton','string','>>','Position',bp,'Tag','NextTrial',...
        'Callback', @@PlayNextTrial);
    bp(1) = bp(1)+bp(3);
    uicontrol(sfig,'style','pushbutton','string','<<','Position',bp,'Tag','LastTrial',...
        'Callback', @@PlayLastTrial);
    bp(1) = bp(1)+bp(3);
    uicontrol(sfig,'style','pushbutton','string','X','Position',bp,'Tag','CutTrial',...
        'Callback', @@CutTrial);
    bp(1) = bp(1)+bp(3);
    uicontrol(sfig,'style','pop','string','1|2|3','Position',bp,'Tag','ChooseTrial',...
        'Callback', @@SelectTrial);
    bp(1) = bp(1)+bp(3);
    uicontrol(sfig,'style','pushbutton','string','+','Position',bp,'Tag','NextSpike',...
        'Callback', @@PlayNextSpike);
    bp(1) = bp(1)+bp(3);
    bp(3)=c*6;
    uicontrol(sfig,'style','pushbutton','string','spool','Position',bp,'Tag','SpoolSpikes',...
        'Callback', @@SpoolSpikes);
    bp(1) = bp(1) + bp(3);
    
    bp(3)=c*9;
    uicontrol(gcf,'Style', 'checkbox',...
    'String', 'dVdt', 'Tag', 'dVdt', 'Position', bp,'value',DATA.plot.dvdt,...
    'Callback',@@Update);
    bp(1) = bp(1) + bp(3);
    
    bp(3)=c*9;
    uicontrol(gcf,'Style', 'checkbox',...
    'String', 'Stop', 'Tag', 'StopSpool', 'Position', bp,'value',0,...
    'Callback',@@Update);
    tmpdat.parentfigtag = DATA.tag.top;
    set(sfig,'UserData',tmpdat);

    DATA.hline = 0;    
end
    it = findobj(sfig,'Tag','ChooseTrial');
    set(it,'string',sprintf('%d|',[DATA.Expts{expid}.Trials.Trial]),'value',1);
    DATA.svfig = sfig;
if DATA.spooling ~= 2 %2 == spool from current trial
    DATA.currenttrial = 0;
end
DATA.ISIpair = 0;
DATA.currentexpt = expid;
if DATA.test.fastplot
    set(DATA.svfig,'renderer','painters');
    ax = findobj(DATA.svfig,'type','ax');
    set(ax,'DrawMode','fast','XTickMode','manual','YTickMode','manual');
    set(ax,'Xlim',[1 46],'Ylim',[-5 5]);
end
ax = findobj(DATA.svfig,'type','ax');



if DATA.state.uselfp
    DATA.state.lfig = GetFigure('LFP');
    hold off;
    DATA.Expts{expid} = LoadSpike2LFP(DATA.Expts{expid});
end
colors = mycolors;
if DATA.probe == 100
    Spks = DATA.AllData.UstimV;
elseif isfield(DATA,'AllSpikes')
    Spks = DATA.AllSpikes{DATA.probe};
else
    Spks = DATA.AllData.Spikes;
end
tic;
if isfield(Spks,'values')
nsamples = size(Spks.values,2);
else
    nsamples = 0;
end
if size(Spks.codes,2) > 1
nclusters = 1+max(Spks.codes(:,2));
else
nclusters = 1;
end
set(0,'CurrentFigure',xyfig);

if isfield(DATA.plot,'useprobe')
    xprobes = find(DATA.plot.useprobe);
    xprobes = setdiff(xprobes,DATA.probe);
else
    xprobes = [];
end
DATA.xprobes = xprobes;
probes = [DATA.probe xprobes];
nprobes = length(probes);



reclassify = 0;
cid = findobj('Tag','ClusterIsSet');
if DATA.spooling
    DATA.state.recut = 1;
elseif ClusterIsSet(DATA.Expts{expid},DATA.probe) & DATA.state.recut
    DATA.cluster = DATA.Expts{expid}.Cluster;
    DATA.state.recut = 1;
    if DATA.Expts{expid}.gui.clustertype == 2 %% THe online cut
        set(cid,'value',0);
    else
        set(cid,'value',1);
    end
    if ~isfield(DATA.Expts{expid}.gui,'classified') | DATA.Expts{expid}.gui.classified ~= 1
     DATA = SetExptSpikes(DATA,expid,0);
    end
    if length(xprobes) & isfield(DATA,'AllSpikes')
        for j = 1:length(probes)
            if ~isfield(DATA.AllSpikes{probes(j)},'spklist')
                times(1) = DATA.Expts{expid}.Trials(1).Start(1)-500;
                times(2) = DATA.Expts{expid}.Trials(end).End(end)+500;
                DATA.AllSpikes{probes(j)}.spklist = FindSpikes(DATA, times, probes(j));
            end
            DATA = SetSpkCodes(DATA, DATA.AllSpikes{probes(j)}.spklist, probes(j),0);
        end
    end
    
elseif ~isfield(DATA,'cluster')
    DATA.cluster = {};
elseif DATA.state.recut %No cluster yet defined
   DATA.state.recut = 2;
% when inheriting a cluster, don't inherit any spike ranges
  nclusters = 1+max(Spks.codes(:,2));
  p = DATA.probe;
  for j = 1:nclusters
      if j <= size(DATA.cluster,1) & size(DATA.cluster,2) >= p & ~isempty(DATA.cluster{j,p})
      if isfield(DATA.Expts{expid}.gui,'spkrange') & ~isempty(DATA.Expts{expid}.gui.spkrange)
      DATA.cluster{j,p}.firstspk = DATA.Expts{expid}.gui.spkrange(1);
      DATA.cluster{j,p}.lastspk = DATA.Expts{expid}.gui.spkrange(2);
      else
      DATA.cluster{j,p}.firstspk = 1;
      DATA.cluster{j,p}.lastspk = length(Spks.times);
      end
      end
  end
    set(cid,'value',0);
end
nclusters = double(nclusters);
if DATA.plot.synccluster == 0
    ClrSpkWin(DATA);
    DATA = DrawClusters(DATA,DATA.cluster,0);
else
    hold off;
    plot(0,0,'+');
    hold on;
end
if DATA.plot.autoscale == 0
  set(gca,'Xlim',DATA.plot.clusterXrange,'Ylim',DATA.plot.clusterYrange); 
end 

set(0,'CurrentFigure',sfig);
hold off;

    if DATA.spikelist == -1
       spikelist = [0 1 2 3 4];
    else
       spikelist = DATA.spikelist;
    end



x = 32; %should calculate real size..
for k = 0:length(xprobes)
    ids{k+1} = FindSpikes(DATA, DATA.Expts{expid}.Header.trange,probes(k+1));
    if isfield(DATA,'AllSpikes')
        %nclusters needs to be max # used across all probes
        nclusters = max([nclusters max(DATA.AllSpikes{probes(k+1)}.codes(:,2))]);
        text(x,(k-(nprobes-1)/2) * DATA.plot.SpikeMaxV,num2str(probes(k+1)));
        ncut = sum(DATA.AllSpikes{probes(k+1)}.codes(:,2) > 0);
        if ncut
            id = find(ismember(DATA.AllSpikes{probes(k+1)}.codes(ids{k+1},2),spikelist));
%            ids{k+1} = ids{k+1}(id);
        end
        if ~isfield(DATA.AllSpikes{probes(k+1)},'dVdt')
            DATA.AllSpikes{probes(k+1)} = CleanSpikes(DATA.AllSpikes{probes(k+1)});
        end
    end
    for j = 1:nclusters+1
        DATA.svh(j+k*(nclusters+1)) = plot([1:nsamples],[1:nsamples] * 0,'color',DATA.spkcolor{j});
        hold on;
    end
end

if ~isfield(DATA.Expts{expid}.gui,'spks') %haven't loaded this expt yet
    times = [DATA.Expts{expid}.Trials(1).Start(1) DATA.Expts{expid}.Trials(end).End(end)];
    if isfield(DATA,'AllSpikes')
    nspk = sum(DATA.AllSpikes{DATA.probe}.times > times(1) & DATA.AllSpikes{DATA.probe}.times < times(2)); 
    else
    nspk = sum(DATA.AllData.Spikes.times > times(1) & DATA.AllData.Spikes.times < times(2)); 
    end
    if nspk < 10000
        DATA.ptsize = 6;
    elseif nspk < 2000
        DATA.ptsize = 10;
    else
        DATA.ptsize = 4;
    end
elseif length((DATA.Expts{expid}.gui.spks)) > 10000
    DATA.ptsize = 4;
elseif length((DATA.Expts{expid}.gui.spks)) > 1000
    DATA.ptsize = 6;
else
    DATA.ptsize = 10;
end
if DATA.plot.setptsize
        DATA.ptsize = DATA.plot.setptsize;
end

%FindSpikes might list some spikes just past the list recorded in
%Expts.gui.spkrange.
if isfield(DATA,'Spikes')
if max(ids{1}) > length(DATA.Spikes.cx)
    ispk = length(DATA.Spikes.cx):max(ids{1});
    DATA = CalcClusterVars(DATA,  ispk);
end
end

if isfield(DATA.AllData.Spikes,'codes')
id = find(DATA.AllData.Spikes.codes(ids{1},2) > nclusters);
if length(id)
    DATA.AllData.Spikes.codes(ids{1}(id),2) = 0;
end
end

if DATA.plot.dvdt == 2
    set(gca,'Xlim',[-5 5],'Ylim',[-5 5]);
elseif length(xprobes)
    x = length(xprobes) .* DATA.plot.SpikeMaxV/4;
    if length(xprobes) > 3
        x = length(xprobes) .* DATA.plot.SpikeMaxV/2;
    end
    if length(xprobes) 
    set(gca,'Xlim',[1 nsamples+1],'Ylim',[-(DATA.plot.SpikeMaxV+x) DATA.plot.SpikeMaxV+x]);
    end
elseif nsamples > 1        
    set(gca,'Xlim',[1 nsamples],'Ylim',[-DATA.plot.SpikeMaxV DATA.plot.SpikeMaxV]);
end
DATA.nclusters = nclusters;
nt = 1;
allspks = [];
firstspk = 0;
hline = 0;
if ~isfield(DATA,hline)
    DATA.hline = 0;
end

DATA.playingspk = 1;
DATA.nclusters = nclusters;

set(DATA.toplevel,'UserData',DATA);
if isempty(DATA.currentcluster) || length(DATA.cluster) < DATA.currentcluster 
    DATA.currentcluster = 1;
end

Aargs = {}; timemode = 0;
trialdur = DATA.Expts{expid}.Trials(1).End(end) - DATA.Expts{expid}.Trials(1).Start(1);
if isfield(DATA,'AllSpikes') & length(probes) > 1 & DATA.plot.syncoverlay == 0
    Aargs = {Aargs{:} 'timemode'};
    timemode = 1;
end


if timemode
        if  ~isfield(DATA,'timefig')
        DATA.timefig = GetFigure('SpikeTime');
    end
    set(0,'CurrentFigure',DATA.timefig);
    set(gca,'Xlim',[0 trialdur/10]);
    for k = 0:length(xprobes)
        for j = 1:nclusters+1
            DATA.tvh(j+k*(nclusters+1)) = plot([1:46],[1:46] * 0,'color',DATA.spkcolor{j});
            hold on;
        end
    end
end


if length(probes) > 1 && isfield(DATA,'AllSpikes')
    if DATA.plot.synccluster > 0
        DATA.Spikes.cx(1:end) = 0;
        DATA.Spikes.cy(1:end) = 0;
    end
    step = DATA.plot.SpikeMaxV;
%syncsign = -1 show only sychronous spikes with negetive trigger
%syncsign = -1 show only sychronous spikes with negetive trigger
%syncsign = 11 show only sychronous spikes with positive trigger

    
% even if plotting non sync spikes, want to know which are synced
%    if DATA.syncsign < 2
        dt = 2;


        %find synchronous spikes

        for j = 2:length(probes)
            if isfield(DATA,'sids') && sum(ismember(DATA.sids{1},DATA.AllSpikes{probes(1)}.times(ids{1}))) > 100
                aid = DATA.sids{1};
                bid = DATA.sids{2};
            else
            [aid,bid] = FindSync(DATA.AllSpikes{probes(1)}.times(ids{1}),...
                DATA.AllSpikes{probes(j)}.times(ids{j}),dt);
            aid = ids{1}(aid);
            bid = ids{j}(bid);
            end
            dcs(1,1:length(aid)) = mean(DATA.AllSpikes{probes(1)}.values(aid,:),2);
            dcs(j,1:length(bid)) = mean(DATA.AllSpikes{probes(j)}.values(bid,:),2);
            if ismember(DATA.syncsign,[-1 3])
                id = find(DATA.AllSpikes{probes(1)}.values(aid,9) < 0 & ...
                    DATA.AllSpikes{probes(j)}.values(bid,9) < 0);
                aid = aid(id);
                bid = bid(id);
            elseif ismember(DATA.syncsign,[1 4])
                id = find(DATA.AllSpikes{probes(1)}.values(aid,9) > 0 & ...
                    DATA.AllSpikes{probes(j)}.values(bid,9) > 0);
                aid = aid(id);
                bid = bid(id);
            end
            DATA.sids{1} = aid;
            DATA.sids{j} = bid;
            aids{j} = aid;
            if ismember(DATA.plot.synccluster,[3 4 5 6]) % need PCA
                [E, V, DATA.pca] = SpikePCA(DATA.AllSpikes,[probes(1) probes(j)],{aid bid} );
            end
        end
        if length(probes) == 3 %intersection of all three
            [DATA.sids{1}, bi, ci] = intersect(aids{2},aids{3});
            DATA.sids{2} = DATA.sids{2}(bi);
            DATA.sids{3} = DATA.sids{3}(ci);        
        end

        o = (length(probes)-1)/2;
        for j = 1:length(probes)
            if ~isempty(DATA.sids{j})
            mspk(j,:) = mean(DATA.AllSpikes{probes(j)}.values(DATA.sids{j},:),1);
            plot(mspk(j,:)+((j-1-o) * step),':');
            end
        end

end
start = max([DATA.currenttrial 1]);
last = length(DATA.Expts{expid}.Trials);
% negative Trial numbers indicate manual exclusion
uset = find([DATA.Expts{expid}.Trials(start:last).Trial] > 0);
nsync = 0;nspks = 0;
tc = 1;
while tc < length(uset)  %not for loop, so can change tc inside loop
    trial = DATA.Expts{expid}.Trials(uset(tc)).Trial;
    stop = get(findobj(DATA.svfig,'Tag','StopSpool'),'value');
    if stop
        set(findobj(DATA.svfig,'Tag','StopSpool'),'value',0);
        if 0
            DATA.playingspk = 0;
            return;
        else
            tc = length(uset);
            trial = DATA.Expts{expid}.Trials(uset(nt)).Trial;
        end
    end
    if DATA.state.uselfp
    PlotLFP(DATA.state,DATA.Expts{expid}.Trials(uset(nt)),DATA.Expts{expid}.Header.LFPsamplerate);
    end
    if timemode
    set(0,'CurrentFigure',DATA.timefig);
    else
    set(0,'CurrentFigure',sfig);
    end
    hold off;
    itrial = find(DATA.AllData.Trialids == trial);
    if mode == 1
        DATA = PlotTrialSpikes(DATA,itrial,colors, clusters);
    elseif mode == 2
        times(1) = DATA.Expts{expid}.Trials(uset(nt)).Start(1);
        times(2) = DATA.Expts{expid}.Trials(uset(nt)).End(end);
        Trial = DATA.Expts{expid}.Trials(uset(nt));
        Trial.ed = GetEval(DATA.Expts{expid},'ed',DATA.currenttrial);
        if DATA.syncsign < 2 & length(probes) > 1
            [spks, sspks, cx, cy] = PlotTrialSyncSpikes(DATA, times, [DATA.probe xprobes], colors,'Trial',Trial);
            if DATA.plot.synccluster > 0
            DATA.Spikes.cx(sspks(:,1)) = cx;
            DATA.Spikes.cy(sspks(:,1)) = cy;
            end
            nspks = nspks+length(spks);
            nsync = nsync+size(sspks,2);
            if DATA.plot.synccluster == 10
                    [DATA, spks] = APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probes', [probes(1:2)]);
            end

        else
            if length(probes) > 1
                if DATA.plot.syncoverlay
                for j= 1:length(xprobes)
                    APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probe',[xprobes(j) 1+j length(probes)],'lineoff',j*(nclusters+1));
                end
                [DATA, spks] = APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probe', [probes(1) 1 length(probes)]);
                end
                if timemode
                for j= 1:length(xprobes)
                    APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probe',[xprobes(j) 1+j length(probes)],'lineoff',j*(nclusters+1),'timemode');
                end
                [DATA, spks] = APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probe', [probes(1) 1 length(probes)],'timemode');
                end
            else
                [DATA, spks] = APlotTrialSpikes(DATA,times,colors, nclusters,1,'Trial',Trial,'Probe', [probes(1) 1 length(probes)],Aargs{:});
            end
        end
        allspks = [allspks spks'];
        nt = nt+1;
    end
    hold on;
    tc = tc+1;
end
if DATA.plot.showsync
    fprintf('%d/%d (%.3f) spikes Synchronized\n',nsync,nspks,nsync./nspks);
end
            

if DATA.probe == 100;
    DATA.Expts{expid}.MeanPulse = mean(Spks.values(allspks,:));
    plot(DATA.Expts{expid}.MeanPulse);
end
if DATA.state.uselfp  % look for calibration spikes

 GetFigure('LFP');
 hold off;
 CalcLFPPulse(DATA.Expts{expid},DATA.AllData,'plot');
 GetFigure('SpikeV');
end
if isempty(allspks)
    DATA.spkrange(1) = 1;
    DATA.spkrange(2) = 1;
else
    DATA.spkrange(1) = min(allspks);
    DATA.spkrange(2) = max(allspks);
    DATA.spklist = allspks;
end
DATA.Expts{expid}.gui.spkrange = DATA.spkrange;
DATA.Expts{expid}.gui.spks = allspks;
DATA.Expts{expid}.gui.s2clusters = 1+max(Spks.codes(allspks,1));
DATA.s2clusters = DATA.Expts{expid}.gui.s2clusters;
FinishXYPlot(DATA);
set(xyfig, 'KeyPressFcn',@@KeyPressed);
set(xyfig, 'WindowButtonDownFcn',@@ButtonPressed);
set(xyfig, 'WindowButtonMotionFcn',@@ButtonDragged);
set(xyfig, 'WindowButtonUpFcn',@@ButtonReleased);
axis('manual');
ClearMouse;
DATA.densityplot = 0;
xrange = get(gca,'Xlim');
yrange = get(gca,'Ylim');


if DATA.test.fastplot
    set(DATA.xyfig,'renderer','painters');
    ax = findobj(DATA.xyfig,'type','ax');
    set(ax,'DrawMode','fast','XTickMode','manual','YTickMode','manual');
    %set(,'DrawMode','fast');
end
if DATA.state.fixrange
    if length(allspks) > 1000
        prc = 99;
    else
        prc = 95;
    end
    xm = prctile(DATA.Spikes.energy(allspks),prc);
    ym = prctile(DATA.Spikes.vw(allspks),prc);
    if yrange(2) > 2 * ym
        set(gca,'Ylim',[0 ym * 1.5]);
    end
    if xrange(2) > 2 * xm
        set(gca,'Xlim',[0 xm * 1.5]);
    end
end
mousept.xrange = diff(xrange);
mousept.yrange = diff(yrange);
toc;
if isfield(DATA,'AllClusters')
    set(0,'currentfig',DATA.xyfig);
    plot(DATA.Spikes.cx(allspks),DATA.Spikes.cy(allspks),'.','markersize',DATA.ptsize);
    DATA.allexp = DATA.currentexpt;
    DATA = PlotAllProbeXY(DATA,0);
end
if isfield(DATA,'AllSpikes') && nprobes == 2 && DATA.plot.xcorr
    GetFigure('Xcorr');
    xc = CalcXcorr(DATA,DATA.currentexpt,probes(1),probes(2));
end

DATA.playingspk = 0;
SetGui(DATA);


function DATA = GetDataFromFig(a)

    DATA = get(a,'UserData');

    b = a;
    while isempty(DATA) & ~isempty(b)
        b = get(b,'parent');
        DATA = get(b,'UserData');
    end
    if isfield(DATA,'parentfigtag')
        DATA = get(findobj('Tag',DATA.parentfigtag),'UserData');
    end
    
function RescaleClusterPlot(a,b)
    DATA = GetDataFromFig(a);
it = findobj(DATA.xyfig,'Tag','ClusterXmax');
if it
    DATA.plot.clusterXrange(2) = str2num(get(it,'string'));
end

it = findobj(DATA.xyfig,'Tag','ClusterYmax');
if it
    DATA.plot.clusterYrange(2) = str2num(get(it,'string'));
end
it = findobj(DATA.xyfig,'Tag','ClusterZmax');
if it
    DATA.plot.clusterZrange(2) = str2num(get(it,'string'));
end
ax = findobj(DATA.xyfig,'type','ax');

%
%if the user has typed in a value, surely they want to manually scales
DATA.plot.autoscale = 0;
set(findobj(DATA.xyfig,'Tag','AutoScale'),'value',DATA.plot.autoscale);
if DATA.plot.autoscale == 0
    set(ax,'Xlim',DATA.plot.clusterXrange);
    set(ax,'Ylim',DATA.plot.clusterYrange);
end

    
    
if DATA.densityplot
    caxis([0 DATA.plot.clusterZrange(2)]);
end
set(DATA.toplevel,'UserData',DATA);

function SpoolSpikes(a,b)
DATA = GetDataFromFig(a);
DATA.spooling = 1;
if strmatch(get(a,'Tag'),'SpoolSpikes')
    DATA.spooling = 2; %spool from current spike to end
end
DATA = PlaySpikes(DATA,DATA.currentexpt);
set(DATA.toplevel,'UserData',DATA);

function NextList(a,b)
%DATA = combine('getstate');
DATA = GetDataFromFig(a);
playspk = get(findobj(DATA.toplevel,'Tag','ShowSpikes'),'value');


if DATA.playingspk
    set(findobj(DATA.svfig,'Tag','StopSpool'),'value',1);
    return;
end
strs = get(DATA.elst,'string');
val = get(DATA.elst,'value');
if val < length(strs)
    set(DATA.elst,'value',val+1)
    if isfield(DATA,'AllClusters') & playspk == 0
        combine('setexpt',DATA);
        if 0 % need to use setexp to clear cluster.touched, etc
        id = get(DATA.elst,'value');
        DATA.currentexpt = DATA.expid(id(1));
        DATA.allexp = DATA.currentexpt;
        PlotAllProbeXY(DATA);
        end
    else
        combine('setexpt',DATA);
    end
end


function ClearMouse()
global mousept;

mousept.start = [];
mousept.lasth = [];
mousept.angle = 0;
mousept.r = [1 1];
mousept.down = 0;
mousept.mode = 0;


 function  PlotXYDensity(energy,vw)

     if length(vw) < 10
         return;
     end
if length(vw) > 100000
    lprc = 0.01;
    hprc = 99.99;
    sx=3;
    sy=3;
elseif length(vw) > 10000
    lprc = 0.1;
    hprc = 99.9;
    sx=3;
    sy=3;
elseif length(vw) > 1000
    lprc = 1;
    hprc = 99;
    sx=5;
    sy=5;
else
    lprc = 5;
    hprc = 95;
    sx=8;
    sy=8;
end    

erange = [prctile(energy,lprc) prctile(energy,hprc)];
vrange = [prctile(vw,lprc) prctile(vw,hprc)];
erange = get(gca,'Xlim');
vrange = get(gca,'Ylim');
%GetFigure('DensityPlot');
hold off;
nbins = 200;
[x,y] = meshgrid(linspace(erange(1),erange(2),nbins),linspace(vrange(1),vrange(2),nbins));
mode = 2;
tic;
if mode ==1 % add real gaussian to grid for each
    z = zeros(size(x));
    sx = (diff(erange)/100)^2;
    sy = (diff(vrange)/100)^2;
    for j=1:length(energy)
        z = z + exp(-(x-energy(j)).^2/sx - (y-vw(j)).^2/sy);
    end
elseif mode ==2 %build fine 2-D histogram, then smooth
    [gx,gy] = meshgrid(-10:10,-10:10);

    G = exp(-(gx).^2/sx - (gy).^2/sy);
    G = G./sum(G(:));
    z = zeros(size(x));
    vi = 1+floor(nbins * (vw-vrange(1))/diff(vrange));
    ei = 1+floor(nbins * (energy-erange(1))/diff(erange));
    idx = find(ei > 0 & ei <= nbins & vi > 0 & vi <= nbins);
    for j =idx
        z(vi(j),ei(j)) = z(vi(j),ei(j))+1;
    end
    z = conv2(z,G,'same');
end
toc
pcolor(x,y,z);
shading('interp')


function [x,y,z] = CalcDensity(DATA, expspks, mode)

if ismember(DATA.syncsign,[-1 1])
energy = DATA.Spikes.cx(DATA.sids{1});
vw = DATA.Spikes.cy(DATA.sids{1});
elseif isfield(DATA,'AllClusters')
    energy  = DATA.AllClusters(DATA.probe).cx(expspks);
    vw  = DATA.AllClusters(DATA.probe).cy(expspks);
else
energy = DATA.Spikes.cx(expspks);
vw = DATA.Spikes.cy(expspks);
end
DATA.plot.DensitySigma = [3 3];

if length(vw) > 10000
    lprc = 0.01;
    hprc = 99.99;
elseif length(vw) > 10000
    lprc = 0.1;
    hprc = 99.9;
    
elseif length(vw) > 1000
    lprc = 1;
    hprc = 99;
    DATA.plot.DensitySigma = [5 5];
else
    lprc = 5;
    hprc = 95;
    DATA.plot.DensitySigma = [10 10];
end    

if DATA.xyfig == gcf && mode < 3
erange = get(gca,'Xlim');
vrange = get(gca,'Ylim');
else
erange = [prctile(energy,lprc) prctile(energy,hprc)];
vrange = [prctile(vw,lprc) prctile(vw,hprc)];
end
%GetFigure('DensityPlot');
hold off;
nbins = 200;
[x,y] = meshgrid(linspace(erange(1),erange(2),nbins),linspace(vrange(1),vrange(2),nbins));
tic;
if mode ==1 % add real gaussian to grid for each
    z = zeros(size(x));
    sx = (diff(erange)/100)^2;
    sy = (diff(vrange)/100)^2;
    for j=1:length(energy)
        z = z + exp(-(x-energy(j)).^2/sx - (y-vw(j)).^2/sy);
    end
elseif mode ==2 || mode == 3 %build fine 2-D histogram, then smooth
    [gx,gy] = meshgrid(-10:10,-10:10);
    sx= DATA.plot.DensitySigma(1);
    sy= DATA.plot.DensitySigma(2);
    G = exp(-(gx).^2/sx - (gy).^2/sy);
    G = G./sum(G(:));
    z = zeros(size(x));
% ignore spikes where both are set to 0
    idx = find(vw ~=0 | energy ~=0);
    
    vi = 1+floor(nbins * (vw(idx)-vrange(1))/diff(vrange));
    ei = 1+floor(nbins * (energy(idx)-erange(1))/diff(erange));
    idx = find(ei > 0 & ei <= nbins & vi > 0 & vi <= nbins);
    for j =idx
        z(vi(j),ei(j)) = z(vi(j),ei(j))+1;
    end
    z = conv2(z,G,'same');
end
         
function DensityPlot(a,b)
global mousept;

%DATA = combine('getstate');
DATA = GetDataFromFig(a);

if isfield(DATA,'spklist') & length(DATA.spklist) > 10
    expspks = DATA.spklist;
else
    expspks = DATA.spkrange(1):DATA.spkrange(2);
end

    
    figure(DATA.xyfig);
if DATA.densityplot
    DATA.densityplot = 0;
    hold off;
    DATA = DrawXYPlot(DATA,expspks);
%    ClearMouse;
    set(DATA.toplevel,'UserData',DATA);
    SetGui(DATA);
    return;
end

[x,y,z] = CalcDensity(DATA, expspks, 2);

erange = get(gca,'Xlim');
vrange = get(gca,'Ylim');
%GetFigure('DensityPlot');
hold off;
toc
pcolor(x,y,z);
shading('interp')
hold on;
if 0 %code for trackin peak ridge. May help track clusters/auto cut
[a,b] = max(z);
py = smooth(y(b,1),3,'gauss');
plot(x(1,:), py);
base = 0.1;
for j = length(py):-1:1
    dip(j) = a(j)./(base+max(a(j:end)).^2);
end
plot(dip);
end
DATA = DrawClusters(DATA, DATA.cluster, 0);
DATA.densityplot = 1;
it = findobj(DATA.xyfig,'Tag','ClusterZmax');
x = caxis;
set(it,'string',sprintf('%.2f',x(2)));
SetGui(DATA);
set(DATA.toplevel,'UserData',DATA);


function [expname, exptypename, suff] = Expt2Name(Expt)
% take and expt and return a name identifying the
% exptype, of the form rds.dxXce  
SpkDefs;
suff = [];
        stimname = stimnames{Expt.Stimvals.st+1};
    if strcmp(Expt.Stimvals.et,'or') && Expt.Stimvals.ei > 100
        Expt.Stimvals.et = 'dir';
    end
    
    if strmatch(Expt.Stimvals.e2, 'e0')
        if strmatch(Expt.Stimvals.e3, 'e0')
        exptypename = Expt.Stimvals.et;
        else
            exptypename = [Expt.Stimvals.et 'X' Expt.Stimvals.e3];
        end
            
%        expname = [Expt.Stimvals.et];
    else
        exptypename = [Expt.Stimvals.et 'X' Expt.Stimvals.e2];
    end
    if isfield(Expt.Header,'Options') & strfind(Expt.Header.Options,'+cr')
        exptypename = ['C' exptypename];
    end
    if Expt.Header.rc
        suff = 'RC';
    end
    expname = [stimname '.' exptypename];

function DATA = ListExpts(DATA, Expts);

SpkDefs;
explist = {};
na = 1;
nb = 1;

explist{1} = 'All';
explabel{1} = 'All';

exptypelist = [];
na= 2;
for j = 1:length(Expts)
    [expname, exptypename, suff] = Expt2Name(Expts{j});
    expname = [expname suff];
% if this expt is not in the list, add it
    if isempty(strmatch(Expts{j}.Header.expname,explist,'exact'))
        explist{na} = expname;
        if DATA.state.online == 2
            explist{na} = Expts{j}.Header.expname;
%            Expts{j}.Header.expname = expname;
        else
            explist{na} = Expts{j}.Header.expname;
        end
        exptypelist{na} = exptypename;
        DATA.explist = explist;
        DATA.exptypelist = exptypelist;
        cls = '';
        for k = 1:3
            outname = CombinedName(DATA, na,k);
            if exist(outname,'file')
                cls = [cls ' c' num2str(k)];
            end
        end
        if na > length(DATA.allcombineids)
            DATA.allcombineids{na} = [];
        end
        explabel{na} = [explist{na} cls];
        DATA.explist = explist;
        na = na+1;
    else
%        explist{na} = 'unknown';
    end    
end
p  = get(DATA.clst,'Listboxtop');
if p > length(explabel)
    set(DATA.clst,'ListboxTop',1);
end
p  = get(DATA.clst,'value');
if p > length(explabel)
    set(DATA.clst,'value',1);
end
set(DATA.clst,'string',explabel);
DATA.explist = explist;
DATA.exptypelist = exptypelist;

function [id, ok] = CheckListForName(list,name)

fid = fopen(list,'r');
if fid >0 
    ok = 1;
    names = textscan(fid,'%s');
    files = splitpath(names{1});
    id = strmatch(splitpath(name),files);
    fclose(fid);
else
    ok = 0;
    id = [];
end


function CheckLists(DATA)
       
 pairs = {'ORBW' '/bgc/bgc/anal/orbw/lemORBW.lst' ; ...
     'OTRC' '/bgc/bgc/anal/orbw/otrc.lst'};
        
        [a,dp] = splitpath(DATA.datafilename);
        d = dir(dp);
        nf = 0;
        for j = 1:length(d)
            if strfind(d(j).name,'.mat') 
              for k = 1:size(pairs,1)
                if strfind(d(j).name,pairs{k,1})
                    if isempty(CheckListForName(pairs{k,2},d(j).name))
                    nf = nf+1;
                    dat.files{nf} = [dp '/' d(j).name];
                    dat.lists{nf} = pairs{k,2};
                    else
                        fprintf('%s Already in %s\n',d(j).name,pairs{k,2});
                    end
                    dat.nf = nf;
                end
              end
            end
        end
if nf
    SPACE = 10;
    cw=8;
    ch=10;
    figure('Position',[10 10 cw*60, (ch+SPACE) * (nf+2)]);
    fp = get(gcf,'Position');
    bp = [10 10 fp(4) 20];
    for j = 1:nf
        bp = [10 bp(2)+bp(4)+SPACE fp(3) ch * 2];
        uicontrol(gcf,'Style', 'checkbox',...
            'String', [dat.files{j} dat.lists{j}], 'Tag', 'SuffList', 'Position', bp,'UserData',j);
    end
    bp = [10 10 cw * 5 20];
        uicontrol(gcf,'Style', 'pushbutton',...
            'String','go', 'callback',@@cplists);
     set(gcf,'UserData',dat);
    
end


function cplists(caller,b)

    lfig = get(caller,'parent');
    dat = get(lfig,'UserData');
    it = findobj(lfig,'Tag','SuffList');
    for j = 1:length(it)
        go = get(it(j),'value');
        if go
            fprintf('Adding %s to %s\n',dat.files{j},dat.lists{j});
            AddToList(dat.lists{j},dat.files{j});
        end
    end
    close(lfig);
 
function DATA = ListSubExpts(DATA, id, varargin)

setv = 1;
j = 1;
while j <= length(varargin)
    if strncmpi(varargin{j},'relist',4)
        setv = get(DATA.elst,'value');
    end
    j = j+1;
end
suffs = DATA.suffs;
na = 1;
subexplist = {};
expid = [];
nrp = zeros(size(DATA.explist));
for j = 1:length(DATA.Expts);
    eid = strmatch(DATA.Expts{j}.Header.expname,{DATA.explist{id}},'exact');
    if( id == 1 | ~isempty(eid)) & isfield(DATA.Expts{j},'Trials')
        tid = regexp(DATA.Expts{j}.Header.Name,'Expt[0-9]*.mat');
        if ~isempty(tid) %online file
            label = sprintf(' (%s:%d-%d)',DATA.Expts{j}.Header.Name(tid:end-4),...
                DATA.Expts{j}.Trials(1).Trial,...
                DATA.Expts{j}.Trials(end).Trial');
        elseif DATA.show.times
            label = sprintf(' %.1f-%.1f (id %d-%d)',DATA.Expts{j}.Trials(1).Start(1)./10000,...
                DATA.Expts{j}.Trials(end).Start(1)./10000,DATA.Expts{j}.Trials(1).id,DATA.Expts{j}.Trials(end).id);
        else
            label = sprintf(' %d-%d (id %d-%d)',DATA.Expts{j}.Trials(1).Trial,...
                DATA.Expts{j}.Trials(end).Trial,DATA.Expts{j}.Trials(1).id,DATA.Expts{j}.Trials(end).id);
        end
        if DATA.Expts{j}.Header.psych
            label = [label ' P'];
        end
        if DATA.Expts{j}.Header.rc
            label = [label ' RC'];
        end
        label = [label ShowString(DATA,DATA.Expts{j})];
        if id == 1
            expi = strmatch(DATA.Expts{j}.Header.expname, DATA.explist,'exact');
            nrp(expi) = nrp(expi)+1;
            subexplist{na} = [DATA.Expts{j}.Header.expname num2str(na) label];
        else
            subexplist{na} = [DATA.explist{id(eid)} suffs(mod(na-1,length(suffs))+1) label];
            subexplist{na} = [DATA.explist{id(eid)} num2str(na) label];
        end
        DATA.explabels{j} = subexplist{na};
        if DATA.Expts{j}.gui.clustertype == 0
            subexplist{na} = [subexplist{na} '*'];
        elseif DATA.Expts{j}.gui.clustertype == 2
            subexplist{na} = [subexplist{na} '(O)'];
        elseif DATA.Expts{j}.gui.ncluster == 0
            subexplist{na} = [subexplist{na} '(Z)'];            
        end
        expid(na) = j;
        na = na+1;
    elseif strmatch('unknown',{DATA.explist{id}})
        subexplist{na} = [DATA.explist{id} suffs(na)];
        expid(na) = j;
        na = na+1;        
    end
end
p  = get(DATA.elst,'Listboxtop');
if p > length(subexplist)
    set(DATA.elst,'ListboxTop',1);
end
    set(DATA.elst,'string',subexplist,'value',setv);
    DATA.expid = expid;
    DATA.subexplist = subexplist;
    if ~isfield(DATA,'currentexpt')
        DATA.currentexpt = 1;
    end

    
function timerfna(tim, varargin)
    DATA = get(findobj('Tag',get(tim,'Tag')),'UserData');
%DATA = get(findobj('Tag','Combiner'),'UserData');
if DATA.state.autolist
tic;
    combine('relist');
%toc
end

function timerfn(tim, varargin)
    DATA = get(findobj('Tag',get(tim,'Tag')),'UserData');
    d = dir(DATA.datafilename);
    if d.datenum > DATA.lastread || d.bytes > DATA.lastsize;
 %       fprintf('Reading from %d\n',DATA.linesread);
        [Expts, DATA.linesread] = ReadOnlineTxt(DATA.datafilename, DATA);
%        fprintf('Read %d expts\n',length(Expts));
         Expts = CountTxtSpikes(Expts,DATA.probe,DATA.spikelist);
%         fprintf('List\n');
         if length(Expts) > length(DATA.Expts)
             DATA.Expts = Expts;
             DATA = ListExpts(DATA,Expts);
 %            fprintf('listexp\n');
             DATA = combine('listexps',DATA,'Tag',DATA.tag.top);
%             fprintf('Set\n');
             set(DATA.elst,'value',length(get(DATA.elst,'string')))
             fprintf('Replot (%d,%d) at %s\n',length(Expts),DATA.linesread,datestr(now));
         else
             DATA.Expts = Expts;
             fprintf('Replot (%d,%d,%d) at %s\n',length(Expts),length(Expts{end}.Trials),DATA.linesread,datestr(now));
         end
        DATA.lastread = d.datenum;
        DATA.lastsize = d.bytes;
        combine('setexp',DATA,'Tag',DATA.tag.top);
%        fprintf('Expt Set\n');
    end

    
function LoadAllProbes(a,b, varargin)
    DATA = GetDataFromFig(a);
    expid = DATA.currentexpt;
    j = 1; 
    while j <= length(varargin)
        j = j+1;
    end
    times(1) = DATA.Expts{expid}.Trials(1).Start(1)-10000;
    times(2) = DATA.Expts{expid}.Trials(end).End(end) + 10000;
    DATA.allexp = expid;
    Spikes = DATA.AllData.Spikes;
    tic;
    GetFigure(DATA.tag.allprobes);
    if ~isfield(DATA,'ptsize')
        DATA.ptsize = 1;
    end
    for j = 1:length(DATA.probelist)
        if DATA.state.online == 0
            DATA.AllData.Spikes = GetProbeFiles(DATA, DATA.probelist(j),'trange',times/10000);
        else
            filename = ['C:' DATA.Expts{DATA.currentexpt}.Header.Name];
            if DATA.probelist(j) > 16
                filename = strrep(filename,'/Expt','A/Expt');
            end
            [DATA.AllData.Spikes]= GetProbeSpikes(DATA.AllData, filename , DATA.probevars{j});
        end
        if isempty(DATA.AllData.Spikes) | isempty(DATA.Expts{expid}.gui.spks)
        DATA.clustervals(j).x = [];
        DATA.clustervals(j).y = [];
        DATA.clustervals(j).spkrange = [0 0 ];
        else
        DATA = SetExptSpikes(DATA, DATA.currentexpt, 0);
        ispk = DATA.Expts{expid}.gui.spks;
        DATA.clustervals(j).x = DATA.Spikes.cx(ispk);
        DATA.clustervals(j).y = DATA.Spikes.cy(ispk);
        DATA.clustervals(j).spkrange = [ispk(1) ispk(end)];
        subplot(6,4,j);
        if DATA.densityplot
        PlotXYDensity(DATA.Spikes.cx(ispk),DATA.Spikes.cy(ispk));
        else
        plot(DATA.Spikes.cx(ispk),DATA.Spikes.cy(ispk),'.','markersize',DATA.ptsize);
        end
        title(sprintf('%d: %d',j,length(ispk)));
        end
    end
    subplot(6,4,2);
    text(1,1.5,sprintf('Expt %d',DATA.currentexpt),'units','norm');
    toc
    DATA.AllData.Spikes = Spikes;  %% Don't change main probe array
    set(DATA.toplevel,'UserData',DATA);

function DATA = GetAllProbeFig(DATA)
    if isfigure(DATA.figs.allprobes)
        GetFigure(DATA.figs.allprobes);
    else
        [DATA.figs.allprobes, isnew] = GetFigure(DATA.tag.allprobes);
        dat.parentfigtag = DATA.tag.top;
        set(DATA.figs.allprobes,'UserData',dat);
        if isnew
            bp = [10 10 DATA.plot.cw*7 20];
                uicontrol(DATA.figs.allprobes,'Style', 'checkbox',...
        'String', 'Density', 'Tag', 'AllDensity', 'Position', bp,'value',0,...
        'Callback',@@Update);

         abp = bp;
         bp(2) = bp(2)+DATA.plot.ch * 2.2;
         uicontrol(DATA.figs.allprobes,'Style', 'pushbutton','String','Set','Position',bp,'Callback', @@SetExptClusters);
         bp(1) = bp(1)+bp(3);
         bp(3) = DATA.plot.cw * 6;
         uicontrol(DATA.figs.allprobes,'Style', 'pushbutton', 'Callback', @@NextList, ...
             'String', 'Next', 'Position',bp);
         bp = abp;
       for j = 1:length(DATA.probelist)
           bp(1) = bp(1)+bp(3);
           if j < 10
               bp(3) = DATA.plot.cw * 3;
           else
               bp(3) = DATA.plot.cw * 4;
           end
         uicontrol(DATA.figs.allprobes,'Style', 'checkbox',...
        'String', sprintf('%d',j), 'Tag', sprintf('MarkProbe%d',j), 'Position', bp,'value',0,...
        'Callback',@@Update);
       end
       bp(1) = bp(1)+bp(3);
       bp(3) = DATA.plot.cw * 5;
       
       uicontrol(DATA.figs.allprobes,'Style', 'pushbutton',...
        'String', 'Mark', 'Position', bp,'value',0,...
        'Callback',@@MarkProbes,'UserData',dat);
        end
    end

function MarkProbes(a,b)
    DATA = GetDataFromFig(a);
    for j = 1:length(DATA.probelist)
        it = findobj(get(a,'parent'),'Tag',sprintf('MarkProbe%d',j));
        if length(it) == 1 && get(it,'value') > 0
            DATA.markexp(DATA.currentexpt,j) = 1;
            DATA.plot.useprobe(j) = 1;
        else
            DATA.plot.useprobe(j) = 0;
        end
    end
    imagesc(DATA.markexp);
    set(DATA.toplevel,'UserData',DATA);
    

function LoadAllProbeParams(a,b, varargin)
    DATA = GetDataFromFig(a);
    expid = DATA.currentexpt;
    j = 1; 
    while j <= length(varargin)
        j = j+1;
    end
    DATA.allexp = expid;
    Spikes = DATA.AllData.Spikes;
    tic;
    DATA = GetAllProbeFig(DATA);
    if ~isfield(DATA,'ptsize')
        DATA.ptsize = 1;
    end
    for j = 1:length(DATA.probelist)
        set(DATA.toplevel,'name',sprintf('Loading %d',DATA.probelist(j)));
        drawnow;
        if DATA.state.online == 0
            DATA.AllData.Spikes = GetProbeFiles(DATA, DATA.probelist(j));
        else
            filename = ['C:' DATA.Expts{DATA.currentexpt}.Header.Name];
            if DATA.probelist(j) > 16
                filename = strrep(filename,'/Expt','A/Expt');
            end
            [DATA.AllData.Spikes]= GetProbeSpikes(DATA.AllData, filename , DATA.probevars{j});
        end
        nspk = length(DATA.AllData.Spikes.times);
        DATA = CalcClusterVars(DATA,  1:nspk,'force');
        DATA.AllClusters(j).cx = DATA.Spikes.cx(1:nspk);
        DATA.AllClusters(j).cy = DATA.Spikes.cy(1:nspk);
        DATA.AllClusters(j).times = DATA.AllData.Spikes.times;
        DATA.AllClusters(j).codes = DATA.AllData.Spikes.codes(:,2);
    end
    DATA.AllData.Spikes = Spikes;  %% Don't change main probe array
    set(DATA.toplevel,'UserData',DATA);
    NotBusy(DATA);
    
    
function DATA = LoadAllProbeSpikes(a,b, varargin)
    if isstruct(a)
        DATA = a;
    else
        DATA = GetDataFromFig(a);
    end
    expid = DATA.currentexpt;
    times(1) = DATA.Expts{expid}.Trials(1).Start(1)-10000;
    times(2) = DATA.Expts{expid}.Trials(end).End(end) + 10000;
    DATA.allexp = expid;
    DATA.AllData.Spikes = [];
    probelist = DATA.probelist;
    j = 1;
    while j <= length(varargin)
%        'select' load just selected probes for selected expt range
        if strncmpi(varargin{j},'select',5)
            AddProbeList(DATA);
            if ~isfield(DATA.plot,'useprobe')
                return;
            end
            probelist = find(DATA.plot.useprobe);
            if isempty(probelist)
                return;
            end
            if sum(probelist == DATA.probe) == 0
                DATA.probe = probelist(1);
            end
            eid = DATA.exabsid;
            times(1) = DATA.Expts{eid(1)}.Trials(1).Start(1) - 10000;
            times(2) = DATA.Expts{eid(end)}.Trials(end).End(end) - 10000;
%            DATA.probe = max(probelist);
        end
        j = j+1;
    end
    tic;
    DATA = GetAllProbeFig(DATA);
    if ~isfield(DATA,'ptsize')
        DATA.ptsize = 1;
    end
    if isfield(DATA,'AllClusters') %% Can't have both
        DATA = rmfield(DATA,'AllClusters');
    end
    for j = 1:length(probelist)
        set(DATA.toplevel,'Name',sprintf('Loading probe %d',probelist(j)));
        drawnow;
        if DATA.state.online == 0
            DATA.AllSpikes{probelist(j)} = GetProbeFiles(DATA, probelist(j),'trange',times/10000,'nodv');
        else
            filename = ['C:' DATA.Expts{DATA.currentexpt}.Header.Name];
            if DATA.probelist(j) > 16
                filename = strrep(filename,'/Expt','A/Expt');
            end
            DATA.AllSpikes{probelist(j)} = GetProbeSpikes(DATA.AllData, filename , DATA.probevars{probelist(j)});
        end
    end
    toc
    tic
    if DATA.state.recut
        DATA = ReClassifyAll(DATA);
    end
    
    toc;
%   DATA.AllData.Spikes = Spikes;  %% Don't change main probe array
    set(DATA.toplevel,'UserData',DATA);
    AddProbeList(DATA);
    if isfield(DATA,'currentexpt') & ismember(DATA.probe, probelist)
        id = find(probelist == DATA.probe);
        if id < length(probelist)
            id = probelist(id+1);
        elseif id > 1
            id = probelist(id-1);
        else
            id = DATA.probe;
        end
        xc = CalcXcorr(DATA,DATA.currentexpt,DATA.probe,id);
    end


function xc = CalcXcorrDC(DATA, eids, sa, sb)
    dt = 2;
    colors = 'bmr';
    fprintf('Calculating DC Cross Correlation %d,%d\n',sa,sb);
    tic;
    for j = 1:length(eids)
        Expt =  DATA.Expts{eids(j)};
        trange = [Expt.Trials(1).Start(1) Expt.Trials(end).End(end)];
        if DATA.syncsign > 0
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
            DATA.AllSpikes{sa}.values(:,9) > 0);
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
            DATA.AllSpikes{sb}.values(:,9) > 0);
        elseif DATA.syncsign < 0
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
            DATA.AllSpikes{sa}.values(:,9) < 0);
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
            DATA.AllSpikes{sb}.values(:,9) < 0);
        else 
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2));
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2));
        end

        [ai,bi] = FindSync(DATA.AllSpikes{sa}.times(aid),...
                DATA.AllSpikes{sb}.times(bid),dt);
            dcs(1,:) = mean(DATA.AllSpikes{sa}.values(aid(ai),24:end),2);
            dcs(2,:) = mean(DATA.AllSpikes{sb}.values(bid(bi),24:end),2);
    end
    scatter(dcs(1,:),dcs(2,:),'.');
    
function DATA = ReClassifyAll(DATA, varargin)
% apply defind clusters to all expts/probes
% useful if saved list of classification codes is missing/ wrong
if 0
    [DATA, ispk] = SetExptSpikes(DATA, DATA.currentexpt,'setrange');
    DATA = SetSpkCodes(DATA, ispk, DATA.probe, 0);
end
    oldprobe = DATA.probe;
    for k = 1:length(DATA.probelist)
        if ~isempty(DATA.AllSpikes{k})
        DATA.probe = k;
        DATA = CalcClusterVars(DATA, 1:length(DATA.AllSpikes{k}.times));
        for j = 1:length(DATA.Expts)
            [DATA, ispk] = SetExptSpikes(DATA, j,'setrange');
            DATA = SetSpkCodes(DATA, ispk, DATA.probe, 0);
        end
        end
    end
    DATA.probe = oldprobe;
    
    
    
function xc = CalcXcorrV(DATA, eids, sa, sb)
    dt = 2;
    pts = 24:32;
    colors = 'bmr';
    fprintf('Calculating V Cross Correlation %d,%d\n',sa,sb);
    tic;
    for j = 1:length(eids)
        Expt =  DATA.Expts{eids(j)};
        trange = [Expt.Trials(1).Start(1) Expt.Trials(end).End(end)];
        if DATA.syncsign > 0
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
            DATA.AllSpikes{sa}.values(:,9) > 0);
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
            DATA.AllSpikes{sb}.values(:,9) > 0);
        elseif DATA.syncsign < 0
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
            DATA.AllSpikes{sa}.values(:,9) < 0);
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
            DATA.AllSpikes{sb}.values(:,9) < 0);
        else 
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2));
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2));
        end
        [ai,bi] = FindSync(DATA.AllSpikes{sa}.times(aid),...
                DATA.AllSpikes{sb}.times(bid),dt);
            dcs(1,:,:) = DATA.AllSpikes{sa}.values(aid(ai),:);
            dcs(2,:,:) = DATA.AllSpikes{sb}.values(bid(bi),:);
    end
    if ~isempty(pts)
        a = mean(dcs(1,:,pts),3);
        b = mean(dcs(2,:,pts),3);
        scatter(a(:),b(:),'.');
    else
        scatter(dcs(1,:),dcs(2,:),'.');
    end
    

    
    function xc = CalcXcorr(DATA, eids, sa, sb)
    dt = [-1000:5:1000];
    sign = DATA.syncsign;
    colors = 'bmr';
    if DATA.spikelist(1) >= 0
        spikelist = DATA.spikelist;
    else
       spikelist = [0:4];
    end
    xc = [];
    fprintf('Calculating Cross Correlation %d,%d\n',sa,sb);
    tic;
    for j = 1:length(eids)
        Expt =  DATA.Expts{eids(j)};
        trange = [Expt.Trials(1).Start(1) Expt.Trials(end).End(end)];
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2));
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2));

        isspk = [0 0];
        if sum(DATA.AllSpikes{sa}.codes(aid,2)) == 0 %% no clusters cut
            aspikelist = 0;
        else
            aspikelist = spikelist;
            isspk(1) = 1;
        end
        if sum(DATA.AllSpikes{sb}.codes(bid,2)) == 0 %% no clusters cut
            bspikelist = 0;
        else
            bspikelist = spikelist;
            isspk(2) = 1;
        end
        
        for t = 1:length(Expt.Trials)
            durs(t) = Expt.Trials(t).End(end) - Expt.Trials(t).Start(1);
        end
        ptimes = 0:10:mean(durs);
        for t = 1:length(Expt.Trials)
        trange = [Expt.Trials(t).Start(1)-0.1 Expt.Trials(t).End(end)+0.1];
        if sign == 1 %use only positive triggers
        aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
            DATA.AllSpikes{sa}.values(:,9) > 0 & ismember(DATA.AllSpikes{sa}.codes(:,2),aspikelist));
        at = DATA.AllSpikes{sa}.times(aid);
        bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
            DATA.AllSpikes{sb}.values(:,9) > 0 & ismember(DATA.AllSpikes{sb}.codes(:,2),bspikelist));
        bt = DATA.AllSpikes{sb}.times(bid);
        elseif sign < 0 %use only negative triggers
            aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ...
                DATA.AllSpikes{sa}.values(:,9) < 0 & ismember(DATA.AllSpikes{sa}.codes(:,2),aspikelist));
            at = DATA.AllSpikes{sa}.times(aid);
            bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ...
                DATA.AllSpikes{sb}.values(:,9) < 0 & ismember(DATA.AllSpikes{sb}.codes(:,2),aspikelist));
            bt = DATA.AllSpikes{sb}.times(bid);
        else
            aid = find(DATA.AllSpikes{sa}.times > trange(1) & DATA.AllSpikes{sa}.times < trange(2) & ismember(DATA.AllSpikes{sa}.codes(:,2),aspikelist));
            at = DATA.AllSpikes{sa}.times(aid);
            bid = find(DATA.AllSpikes{sb}.times > trange(1) & DATA.AllSpikes{sb}.times < trange(2) & ismember(DATA.AllSpikes{sb}.codes(:,2),aspikelist));
            bt = DATA.AllSpikes{sb}.times(bid);
        end
        dts = [];
        if length(at) & length(bt)
          for k = 1:length(at)
              dts(k,:) = hist(at(k) - bt,dt);
          end
          xc(t,:) = sum(dts,1);
          psth{1}(t,:) = hist(at-Expt.Trials(t).Start(1),ptimes);
          psth{2}(t,:) = hist(bt-Expt.Trials(t).Start(1),ptimes);
        end
        counts(t,:) = [length(at) length(bt)];
        end
    end
    if length(xc)
    xc = sum(xc);
    psth{1} = sum(psth{1},1);
    psth{2} = sum(psth{2},1);
    fprintf('%d,%d spikes, took %.2f (%s)\n',sum(psth{1}),sum(psth{2}),toc,datestr(now));
    if sa == sb
        xc(find(dt == 0)) = 0;
    end
    bar(dt(2:end-1)./10,xc(2:end-1),1,colors(sum(isspk)+1));
    end

function SpoolAllProbeClusters(a,b)
    if isstruct(a)
        DATA = a;
    else
        DATA = GetDataFromFig(a);
    end
    for j = 1:length(DATA.Expts)
        DATA.allexp = j;
        PlotAllProbeXY(DATA);
        drawnow;
    end
    
function DATA = PlotAllProbeXY(a,b)

    if isstruct(a)
        DATA = a;
    else
    DATA = GetDataFromFig(a);
    end
    cx = [];
    cy = [];
    DATA = GetAllProbeFig(DATA);
    set(gcf, 'KeyPressFcn',@@KeyPressed);
set(gcf, 'WindowButtonDownFcn',@@ButtonPressed);
set(gcf, 'WindowButtonMotionFcn',@@ButtonDragged);
set(gcf, 'WindowButtonUpFcn',@@ButtonReleased);
    densityplot = GetCheck('AllDensity',DATA.figs.allprobes);
    [nr,nc] = Nsubplots(length(DATA.probelist));
    if length(DATA.probelist) == 24
        nr = 6;
        nc = 4;
    end
    times = [DATA.Expts{DATA.allexp}.Header.trange];
    DATA.ptsize = 1;
    oldprobe = DATA.probe;
    for j = 1:length(DATA.probelist)
        DATA.probe = DATA.probelist(j);
        p = DATA.probe;
        if isfield(DATA,'AllSpikes') 
            ispk = FindSpikes(DATA, times, DATA.probelist(j));
            if length(ispk)
            DATA = CalcClusterVars(DATA,  ispk,'probe',DATA.probelist(j));
%            DATA.AllSpikes{p}.cx = DATA.Spikes.cx;
%            DATA.AllSpikes{p}.cy = DATA.Spikes.cy;
            cx = DATA.Spikes.cx(ispk);
            cy = DATA.Spikes.cy(ispk);
            DATA.clustervals(j).spkrange = [ispk(1) ispk(end)];
            DATA.AllSpikes{j}.spklist = ispk;
            end
        elseif isfield(DATA,'AllClusters')
            ispk = find(DATA.AllClusters(j).times > times(1) &...
                DATA.AllClusters(j).times < times(2));
            cx = DATA.AllClusters(j).cx(ispk);
            cy = DATA.AllClusters(j).cy(ispk);
            DATA.AllClusters(j).spklist = ispk;
        else
            ispk = DATA.clustervals(j).spkrange(1):DATA.clustervals(j).spkrange(2);
            cx = DATA.clustervals(j).x;
            cy = DATA.clustervals(j).y;
        end
        subplot(nr,nc,j);
        hold off;
        if densityplot
            PlotXYDensity(cx,cy);
        else
            SetSpkCodes(DATA,ispk,DATA.probe,2);
%            plot(cx,cy,'.','markersize',1);
        end
        set(gca,'UserData',DATA.probelist(j));
        hold on;
        if iscluster(DATA.cluster,1,p)
            DATA = DrawClusters(DATA, DATA.cluster,0);
            [xr, yr] = ClusterRange(DATA.cluster,p);
        else
            xr = [0 0];
            yr = [0 0];
        end
        if DATA.plot.autoscale && length(cx)
            %or max cluster
            DATA.plot.clusterYrange = [min(cy) max([prctile(cy,99.5).*1.1 yr(2)])];
            DATA.plot.clusterXrange = [min(cx) max([prctile(cx,99.5).*1.1 xr(2)])];
        end
            set(gca,'Ylim', DATA.plot.clusterYrange,'Xlim',DATA.plot.clusterXrange);
           
        title(sprintf('%d: %d',j,length(ispk)));
    end
    DATA.probe = oldprobe;
    subplot(nr,nc,1);
    text(2,1.4,sprintf('Expt %d ids %d-%d, Trials %d-%d',DATA.allexp,DATA.Expts{DATA.allexp}.Trials(1).id,...
        DATA.Expts{DATA.allexp}.Trials(end).id,DATA.Expts{DATA.allexp}.Trials(1).Trial,...
        DATA.Expts{DATA.allexp}.Trials(end).Trial),'units','norm');

function [xr, yr] = ClusterRange(C, p)
    
    for j = 1:size(C,1)
        if isfield(C{j,p},'x') & C{j,p}.x(2) > 0
        xh(j) = C{j,p}.x(1)+C{j,p}.x(2);
        xl(j) = C{j,p}.x(1)-C{j,p}.x(2);
        yh(j) = C{j,p}.y(1)+C{j,p}.y(2);
        yl(j) = C{j,p}.y(1)-C{j,p}.y(2);
        else
            xh(j) = 0;
            xl(j) = 0;
            yl(j) = 0;
            yh(j) = 0;
        end
    end
    xr = [min(xl) max(xh)];
    yr = [min(yl) max(yh)];
        
function DATA = AddMultiProbeGUI(DATA)

if ~isempty(findobj(DATA.toplevel,'Tag','MultiProbeMenu'))
    return;
end
DATA.show.ed = 1;
if 0
cw = DATA.plot.cw;
    ch = DATA.plot.ch;
SPACE = cw;
bp(1) = SPACE;
bp(2) = DATA.gui.toprow+ch+SPACE;
bp(3) = cw.*10;
bp(4) = ch * 1.5;
uicontrol(DATA.toplevel,'Style', 'pushbutton', 'Callback', @@CombineAll, ...
'String', 'Combine All', 'Tag','CombineAll','Position', bp);
bp(1) = bp(1)+bp(3)+SPACE;
uicontrol(DATA.toplevel,'Style', 'pushbutton', 'Callback', @@ReCombineAll, ...
'String', 'ReCombine All', 'Tag','ReCombineAll','Position', bp);
end
hm = uimenu(DATA.toplevel,'Label','Nchannel','Tag','MultiProbeMenu');
uimenu(hm,'Label','&Load All Spks','Callback',@@LoadAllProbeSpikes);
uimenu(hm,'Label','&Load Selected Spks','Callback',{@@LoadAllProbeSpikes,'select'});
uimenu(hm,'Label','&Load All Cluster Params','Callback',@@LoadAllProbeParams);
uimenu(hm,'Label','&Plot All Spks','Callback',@@LoadAllProbes);
uimenu(hm,'Label','&RePlot All Spks','Callback',@@PlotAllProbeXY);
uimenu(hm,'Label','&Combine All','Callback',@@CombineAll);
uimenu(hm,'Label','&Recombine All','Callback',@@ReCombineAll);
uimenu(hm,'Label','&Recombine All LFPs','Callback',{@@ReCombineAll 'lfponly'});
uimenu(hm,'Label','&Recombine All spks','Callback',{@@ReCombineAll 'spkonly'});
uimenu(hm,'Label','&Recombine One probe','Callback',{@@ReCombineAll 'oneprobe'});
uimenu(hm,'Label','&Recombine Check List','Callback',{@@ReCombineAll 'listonly'});
uimenu(hm,'Label','&Spike Shape','Callback', @@CalcSpikeShapes);
uimenu(hm,'Label','->One Probe','Callback', {@@SetProbeHit 'ReloadProbe'});
uimenu(hm,'Label','->CellList','Callback', @@MakeCellList);
uimenu(hm,'Label','CrossCorr','Callback', @@xcorrhit);
    


function MakeCellList(a,b, varargin)
    DATA = GetDataFromFig(a);
    
wsc = DATA.wsc;
SPACE = 3 * wsc(1);
VSPACE = 5 * wsc(2);
ch = DATA.plot.ch;
cw = DATA.plot.cw;
tag = DATA.tag.celllist;

cntrl_box = findobj('Tag',tag,'Name','Cell List');
if ~isempty(cntrl_box)
    figure(cntrl_box);
    return;
end
if ~isfield(DATA,'figpos') | isempty(DATA.figpos{1})
   bp = get(DATA.toplevel,'Position');    
   DATA.figpos{1} =  [bp(1)+bp(3) bp(2)-ch*50 cw*40 ch*5]
end
dat.parentfigtag = DATA.tag.top;
% standard figure. Will Plot Map
cntrl_box = figure('Menubar', 'none',...
    'NumberTitle', 'off', 'Tag',tag,'Name','Cell List','UserData',dat);

bp = [10 10 cw*4 ch*2];
uicontrol(gcf,'Style', 'pushbutton', 'Callback', {@@AddCellToList, 'Tag' DATA.tag.top},...
'String', 'Add', 'Position', bp);

bbp = [10 bp(2)+ch*2 cw*4 ch*2];
uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@NextList,...
'String', 'Next', 'Position', bbp);
bbp(2) = bbp(2)+ch*2;

uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@MakeCellTemplate,...
'String', 'Tmplt', 'Position', bbp);

bbp(2) = bbp(2)+ch*2;
uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@SaveCellList,...
'String', 'Save', 'Position', bbp);


for j = 1:length(DATA.probelist)
    pstrs{j} = num2str(DATA.probelist(j));
end
bp(1) = bp(1)+bp(3)+SPACE;
    uicontrol(gcf,'Style', 'Text','String', 'Cell','Position', bp);
bp(1) = bp(1)+bp(3)+SPACE;
bp(3) = cw*5;
    uicontrol(gcf,'Style', 'pop',...
        'String', '1|2|3|4|5|6|7|8|9|10|11|12|13', 'Tag', 'CellNumber', 'Position', bp,'value',1,...
        'callback',@@SetCellNum);

bp(1) = bp(1)+bp(3)+SPACE;
    uicontrol(gcf,'Style', 'Text','String', 'Probe','Position', bp);
bp(1) = bp(1)+bp(3)+SPACE;
    uicontrol(gcf,'Style', 'pop',...
        'String', pstrs, 'Tag', 'CellProbeAdd', 'Position', bp,'value',DATA.probe);

    bp(1) = bp(1)+bp(3)+SPACE;
    uicontrol(gcf,'Style', 'Text','String', 'Quality','Position', bp);
bp(1) = bp(1)+bp(3)+SPACE;
bp(3) = cw*5;
    uicontrol(gcf,'Style', 'pop',...
        'String', 'Nothing|MU|MU+|Poor|OK|Good|VGood|Excellent', 'Tag', 'CellQuality', 'Position', bp,'value',1);

    bp(1) = bp(1)+bp(3)+SPACE;
    uicontrol(gcf,'Style', 'Text','String', 'Plot','Position', bp);
    bp(1) = bp(1)+bp(3)+SPACE;
bp(3) = cw*5;
    uicontrol(gcf,'Style', 'pop',...
        'String', 'Quality|Number|One Cell|Cells', 'Tag', 'PlotType', 'Position',bp, 'callback', @@RePlotCellList);
    PlotCellList(DATA);

function SetCellNum(a,b)
cell = get(a,'value');
RePlotCellList(a,b);



function MakeCellTemplate(a,b)
DATA = GetDataFromFig(a); 
cn = 1;
eid = get(DATA.elst,'value');
exps = DATA.expid(eid);
t(1) = DATA.Expts{exps(1)}.Trials(1).Start(1);
t(2) = DATA.Expts{exps(end)}.Trials(end).End(end);
spkt = DATA.AllData.Spikes.times;
ispk = find(DATA.AllData.Spikes.times > t(1) & DATA.AllData.Spikes.times < t(2)...
    & DATA.AllData.Spikes.codes(:,2) == cn);
mnspk = mean(DATA.AllData.Spikes.values(ispk,:));
subplot(2,1,1);
plot(mnspk);
subplot(2,1,2);

it = findobj(get(a,'parent'),'Tag','CellNumber');
if ~isempty(it)
    cell = get(it(1),'value');
else 
    cell = 1;
end
DATA.Templates(cell,:) = mnspk;
tmpl = DATA.AllData.Spikes.values * mnspk';
for j = length(DATA.Expts):-1:1
    for k = length(DATA.Expts{j}.Trials):-1:1
     ispk = find(spkt > DATA.Expts{j}.Trials(k).Start(1) & spkt < DATA.Expts{j}.Trials(k).End(end));
     if length(ispk)
         score(DATA.Expts{j}.Trials(k).Trial) = max(tmpl(ispk));
     end
    end
end
set(DATA.toplevel,'UserData',DATA);

%SaveCellList(DATA);
plot(score(find(score > 0)));

function RePlotCellList(a,b);
DATA = GetDataFromFig(a); 

itype =  1;
plotstrs = {'qual' 'bynum' 'onecell' 'joincell'};
it = findobj(get(a,'parent'),'Tag','PlotType');
if ~isempty(it)
   itype = get(it(1),'value');
end
DATA.plot.cellplot = itype;
PlotCellList(DATA,plotstrs{itype});
set(DATA.toplevel,'UserData',DATA);

function AddCellToList(a,b, varargin)

    
DATA = GetDataFromFig(a); 

itype =  1;
plotstrs = {'qual' 'bynum' 'oncecell' 'joincell'};

it = findobj(get(a,'parent'),'Tag','CellProbeAdd');
if ~isempty(it)
    probe = get(it(1),'value');
end
it = findobj(get(a,'parent'),'Tag','CellNumber');
if ~isempty(it)
    cell = get(it(1),'value');
end
it = findobj(get(a,'parent'),'Tag','CellQuality');
if ~isempty(it)
    quality = get(it(1),'value');
end
it = findobj(get(a,'parent'),'Tag','PlotType');
if ~isempty(it)
   itype = get(it(1),'value');
end

[a,b] = TrialRange(DATA);
if quality <= 1
DATA.CellList(cell,a:b) = 0;
else
DATA.CellList(cell,a:b) = probe;
end
DATA.CellQuality(cell,a:b) = quality;
DATA.CellListCluster(cell,a:b) = DATA.currentcluster;
DATA.cellid = cell;
set(DATA.toplevel,'UserData',DATA);
%SaveCellList(DATA);

PlotCellList(DATA,plotstrs{itype});

function [a,b] = TrialRange(DATA)
    eid = get(DATA.elst,'value');
    exps = DATA.expid(eid);
    if DATA.currenttrial > 1
        a = DATA.Expts{exps(1)}.Trials(DATA.currenttrial).Trial;
    else
        a = DATA.Expts{exps(1)}.Trials(1).Trial;
    end
    b = DATA.Expts{exps(end)}.Trials(end).Trial;
    
    
function SaveCellList(a,b)
    if isstruct(a)
        DATA = a;
    else
        DATA = GetDataFromFig(a);
    end
    CellList = DATA.CellList;
    CellQuality = DATA.CellQuality;
    CellListCluster = DATA.CellListCluster;
    Templates = DATA.Templates;
    if ~isfield(DATA,'cellfile')
        DATA.cellfile = strrep(DATA.datafilename,'.mat','.cells.mat');
    end
    save(DATA.cellfile,'CellList','CellQuality', 'Templates','CellListCluster');
    set(DATA.toplevel,'UserData',DATA);

        
function PlotCellList(DATA, varargin)
    
QUALITY = 1;
CELLNUM=2;
ONECELL=3;
JOINCELL=4;
cell = 1;

if isfield(DATA.plot,'cellplot')
    plottype = DATA.plot.cellplot;
else
plottype = QUALITY;
end

j = 1;
while j <= length(varargin)
    if strncmpi(varargin{j},'bynumber',4)
        plottype = CELLNUM;
    elseif strncmpi(varargin{j},'onecell',4)
        plottype = ONECELL;
    elseif strncmpi(varargin{j},'joincell',4)
        plottype = JOINCELL;
    end
    j = j+1;
end

if ~isfield(DATA,'CellList') | isempty(DATA.CellList)
    return;
end
it = findobj('Tag','CombinerCellList');
it = findobj(it, 'Tag','CellNumber');
if ~isempty(it)
    cell = get(it(1),'value');
end

if plottype == QUALITY
    if(size(DATA.CellQuality,2) < size(DATA.CellList,2))
        DATA.CellQuality(end,size(DATA.CellList,2)) = 0;
    end
    im = zeros(length(DATA.probelist),size(DATA.CellList,2));
    for j = 1:size(DATA.CellList,1)
        id = find(DATA.CellList(j,:) > 0);
        ind = sub2ind(size(im), DATA.CellList(j,id),id);
        if plottype == QUALITY & isfield(DATA,'CellQuality')
            im(ind) = DATA.CellQuality(j,id);
        else
        im(ind) = j;
        end
    end
    hold off;
    imagesc(im);
    hold on;
    DATA.CellList(find(DATA.CellList == 0)) = NaN;
    plot(DATA.CellList','linewidth',2);
    legend(num2str([1:size(DATA.CellList,1)]'),'location','NorthWest')
    [a,b] = TrialRange(DATA);
    plot([a a],[1 length(DATA.probelist)],'w:');
    plot([b b],[1 length(DATA.probelist)],'w:');
elseif plottype == CELLNUM
    DATA.CellList(find(DATA.CellList == 0)) = NaN;
    hold off;
    plot(DATA.CellList','linewidth',2);
    set(gca,'ylim',[min(DATA.CellList(:))-1 max(DATA.CellList(:))+1]);
    legend(num2str([1:size(DATA.CellList,1)]'),'location','SouthWest')
elseif plottype == ONECELL
    trials = find(DATA.CellList(cell,:) > 0);
    hold off;
    plot(trials,DATA.CellList(cell,trials),'o-');
elseif plottype == JOINCELL
    hold off;
    colors = mycolors;
    mid = (size(DATA.CellList,1)-1)/2;
    for j = 1:size(DATA.CellList,1)
    trials = find(DATA.CellList(j,:) > 0);
    plot(trials,DATA.CellList(j,trials)+0.05*(j-mid),'o-','color',colors{j});
    hold on;
    end
    [a,b] = TrialRange(DATA);
    plot([a a],[1 length(DATA.probelist)],'k:');
    plot([b b],[1 length(DATA.probelist)],'k:');
        
    legend(num2str([1:size(DATA.CellList,1)]'),'location','SouthWest')
    hold off;
    set(gca,'ylim',[min(DATA.CellList(:))-1 max(DATA.CellList(:))+1]);
end

        
function AddProbeList(DATA)
% Add A list of probes for multiple probe recording.
%
ch = DATA.plot.ch;
cw = DATA.plot.cw;
wsiz = [DATA.plot.cw*40,DATA.plot.ch*40];

ival = 1;

it =  findobj(DATA.toplevel,'Tag','UseProbe1');
if ~isempty(it)
    return;
end
for j = 1:length(DATA.probelist)
    bp = [wsiz(1) ch * j * 1.5 cw*4 ch];
    uicontrol(DATA.toplevel,'Style', 'checkbox',...
        'String', num2str(j), 'Tag', sprintf('UseProbe%d',j), 'Position', bp,'value',ival,...
        'Callback',@@Update);
end
    bp = [wsiz(1) ch * (j+1) * 1.5 cw*4 ch];
    uicontrol(DATA.toplevel,'Style', 'checkbox',...
        'String', 'sync', 'Tag', 'ShowSync', 'Position', bp,'value',0,...
        'Callback',@@Update);
ws = get(DATA.toplevel,'position');
ws(3) = ws(3) + cw * 4;
set(DATA.toplevel,'position',ws);

function DATA = BuildGUI(DATA)

scrsz = get(0,'Screensize');
DATA.gui.scrsz = scrsz;
cw= scrsz(3)/140;
ch= scrsz(4)/60;
if scrsz(3) > 2000
    cw = 10;
elseif scrsz(3) > 1900
    cw = 10;
end
if scrsz(4) > 1200
    ch = 10;
end
if scrsz(4) == 1200
    ch = 8;
elseif scrsz(4) > 1100
    ch = 10;
end
DATA.plot.cw = cw;
DATA.plot.ch = ch;
wsiz = [cw*40,ch*40];
SPACE = ch;

cntrl_box = figure('Position', [100 scrsz(4)-(wsiz(2)+ch*4) wsiz(1) wsiz(2)],...
    'NumberTitle', 'off', 'Tag',DATA.tag.top,'Name',DATA.tag.top);
bp = [10 10 cw*38 ch * 10];
DATA.elst = uicontrol(gcf, 'Style','listbox',...
    'Callback', ['combine(''setexpt'',''Tag'',''' DATA.tag.top ''');'],'Tag','subexptlist',...
    'Position',bp,'Max',3,'Min',1);
bp = [10 bp(2)+bp(4)+SPACE cw*7 ch * 2];
uicontrol(gcf,'Style', 'pushbutton', 'Callback', ['combine(''combine'',''Tag'',''' DATA.tag.top ''');'],...
'String', 'Combine', 'Position', bp);

bp = [bp(1)+bp(3)+SPACE/2 bp(2) cw*5 ch * 2];
uicontrol(gcf,'Style', 'pushbutton', 'Callback', ['combine(''Save'',''Tag'',''' DATA.tag.top ''');'],...
'String', 'Save', 'Position', bp);
bp = [bp(1)+bp(3)+SPACE/2 bp(2) cw*5 ch * 2];
uicontrol(gcf,'Style', 'pushbutton', 'Callback', ['combine(''SaveLFP'',''Tag'',''' DATA.tag.top ''');'],...
'String', 'SaveLFP', 'Position', bp);


bp = [SPACE bp(2)+bp(4)+SPACE cw*30 ch * 2];
DATA.saveitem = uicontrol(gcf,'Style','Edit','String','Save As','Position',bp);

bp = [10 bp(2)+bp(4)+SPACE cw*38 ch * 10];
DATA.clst = uicontrol(gcf, 'Style','listbox',...
    'Callback', ['combine(''listexps'',''Tag'',''' DATA.tag.top ''');'],'Tag','explist',...
    'Position',bp,'Max',3,'Min',1);

bp = [10 bp(2)+bp(4)+SPACE cw*9 ch * 2];
uicontrol(gcf,'Style','Text','String','Data File','Position',bp);
bp = [bp(1)+bp(3)+SPACE bp(2) cw*30 ch * 2];
uicontrol(gcf,'Style','Edit','String',DATA.datafilename,'Position',bp,'Callback',['combine(''newfile''''Tag'',''' DATA.tag.top ''');'],...
    'Tag','FileName');

bp = [10 bp(2)+bp(4)+SPACE cw*6 ch * 2];
uicontrol(gcf,'Style', 'checkbox',...
'String', 'ShowN', 'Tag', 'ShowN', 'Position', bp);

bp(1) = bp(1) + bp(3) + SPACE;
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Spikes', 'Tag', 'ShowSpikes', 'Position', bp);
bp(1) = bp(1) + bp(3) + SPACE;
uicontrol(gcf,'Style', 'checkbox',...
'String', 'SpkXY', 'Tag', 'SpkXY', 'Position', bp,'value',DATA.state.showspkxy,...
'Callback',@@Update);

bp(1) = bp(1) + bp(3) + SPACE;
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Recut', 'Tag', 'Recut', 'Position', bp,'value',DATA.state.recut,...
'Callback',@@Update);

bp(1) = bp(1) + bp(3) + SPACE;
bp(3) = cw*7;
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Auto', 'Tag', 'AutoPlot', 'Position', bp,'value',DATA.state.autoplot,...
'Callback',@@Update);

bp = [10 bp(2)+bp(4)+SPACE cw*6 ch * 2];
uicontrol(gcf,'Style', 'pop',...
'String', 'Mean|Seq:time|Seq:Trials|Seq:Id|Seq:Edit', 'Tag', 'PlotSeq', 'Position', bp,'value',DATA.state.plotseq+1,...
'Callback',@@Update);

bp = [bp(1)+bp(3)+SPACE bp(2) cw*6 ch * 2];
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Recount', 'Tag', 'Recount', 'Position', bp,'value',DATA.state.recount,...
'Callback',@@Update);
bp = [bp(1)+bp(3)+SPACE bp(2) cw*6 ch * 2];
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Psych', 'Tag', 'PlotPsych', 'Position', bp,'value',DATA.state.plotpsych,...
'Callback',@@Update);
bp = [bp(1)+bp(3)+SPACE bp(2) cw*6 ch * 2];
uicontrol(gcf,'Style', 'checkbox',...
'String', 'Combined', 'Tag', 'PlotCombined', 'Position', bp,'value',DATA.state.plotcombined,...
'Callback',@@Update);



bp = [10 bp(2)+bp(4)+SPACE cw*3 ch * 2];
uicontrol(gcf,'Style', 'checkbox',...
'String', '0', 'Tag', 'UseCluster0', 'Position', bp,'Callback',{@@SetClusters, DATA.tag.top});

bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'checkbox',...
'String', '1', 'Tag', 'UseCluster1', 'Position', bp,'Callback',{@@SetClusters, DATA.tag.top});

bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'checkbox',...
'String', '2', 'Tag', 'UseCluster2', 'Position', bp,'Callback',{@@SetClusters, DATA.tag.top});
bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'checkbox',...
'String', '3', 'Tag', 'UseCluster3', 'Position', bp,'Callback',{@@SetClusters, DATA.tag.top});
bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'checkbox',...
'String', '4', 'Tag', 'UseCluster4', 'Position', bp,'Callback',{@@SetClusters, DATA.tag.top});
bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'pushbutton', 'Callback', @@FitButton, ...
'String', 'Fit', 'Tag','FitButton','Position', bp);
bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'pushbutton', 'Callback', 'combine(''setexpplot'')', ...
'String', 'Plot', 'Tag','PlotButton','Position', bp);
bp(1) = bp(1)+bp(3);
bp(3) = cw*5;
uicontrol(gcf,'Style', 'checkbox',...
'String', 'LFP', 'Tag', 'UseLFP', 'Position', bp,'Callback',@@Update);

bp(1) = bp(1)+bp(3);
uicontrol(gcf,'Style', 'pop','String',DATA.probenames,'Position', bp,...
      'Tag','ProbeId','Callback',@@SetProbeHit,'value',1);

bp = [10 bp(2)+bp(4)+SPACE cw*38 ch * 2];
uicontrol(gcf,'Style','Edit','String','Comments','Position',bp,'callback',@@AddComment);

DATA.gui.toprow = bp(2);

  hm = uimenu(gcf,'Label','Mark');
  uimenu(hm,'Label','&Mark','Callback','combine(''Mark'')');
  uimenu(hm,'Label','&relist','Callback','combine(''relist'')');
  uimenu(hm,'Label','&Options','Callback','combine(''options'')');
  uimenu(hm,'Label','&ShowVals','Callback','combine(''showvals'')');
  uimenu(hm,'Label','&To Front','Callback','combine(''winfront'')');
  uimenu(hm,'Label','&Update RF','Callback','combine(''rfupdate'')');
  uimenu(hm,'Label','&Next CEell','Callback','combine(''nextcell'')');
  uimenu(hm,'Label','&Update Lists','Callback','combine(''checklists'')');
  uimenu(hm,'Label','&Comments','Callback','combine(''Comments'')');
  uimenu(hm,'Label','Save Comments','Callback','combine(''SaveComments'')');
  uimenu(hm,'Label','&Close','Callback',['combine(''Close'',''Tag'',''' DATA.tag.top ''');']);
  cm = uimenu(gcf,'Label','&Cluster');
  uimenu(cm,'Label','&AutoCut','Callback','combine(''autocut'')');
  uimenu(cm,'Label','&AutoCluster','Callback','combine(''autocluster'')');
  uimenu(cm,'Label','&AutoCluster All','Callback','combine(''allautocluster'')');
  uimenu(cm,'Label','&DDF','Callback','combine(''plotddf'')');
  uimenu(cm,'Label','&FixMains','Callback','combine(''fixmains'')');
  uimenu(cm,'Label','&ClearAll','Callback','combine(''clearallclusters'')');
  set(gcf,'Menubar','none');
DATA.toplevel = cntrl_box;

function CalcSpikeShapes(a,b, varargin)
%
% caluclate mean spike waveform for biggest spikes
% for each expt,probe
DATA = GetDataFromFig(a);
rebuild = DATA.state.forcebuild;

probelist = DATA.probelist;
TrialVar.cx = [];
outname = strrep(DATA.datafilename,'.mat','spks.mat');
if exist(outname,'file') & ~rebuild
    load(outname);
    DATA.MeanSpike = MeanSpike;
    DATA.TrialVar = TrialVar;
    DATA.TemplateScores = TemplateScores;
else

    for p = 1:length(probelist)
        if p ~= DATA.probe
            DATA = SetProbe(DATA, probelist(p));
        end
        DATA = CalcMeanSpike(DATA,1:length(DATA.Expts));
    end
    SaveSpikeShape(DATA);
end

GetFigure('SpikeShape');
subplot(2,1,1);
imagesc(std(DATA.MeanSpike.v,[],3)');
subplot(2,1,2);
id = find(sum(DATA.TrialVar.cx) > 0);
imagesc(abs(DATA.TrialVar.cx(:,id)));
set(DATA.toplevel,'UserData',DATA);
GetFigure('ClusterShape');
PlotSpikeShapes(DATA.MeanSpike,'auto');

    
function SaveSpikeShape(DATA)
outname = strrep(DATA.datafilename,'.mat','spks.mat');
for j = 1:length(DATA.Expts)
    DATA.MeanSpike.eds(j) = DATA.Expts{j}.Stimvals.ed;
end
MeanSpike = DATA.MeanSpike;
TrialVar = DATA.TrialVar;
TemplateScores = DATA.TemplateScores;

save(outname,'MeanSpike','TrialVar','TemplateScores');
        
        
function AddComment(a,b)
    DATA = GetDataFromFig(a);
    n = 1;
    if isfield(DATA.Comments,'Offline')
        n = length(DATA.Comments.Offline)+1;
    end
    cfile = strrep(DATA.datafilename,'.mat','.txt');
    oid = fopen(cfile,'a');
    DATA.Comments.Offline{n} = get(a,'string');
    set(a,'string','');
    fprintf(oid,'%s\n',DATA.Comments.Offline{n});
    fclose(oid);
    set(DATA.toplevel,'UserData',DATA);
    
    
        
function DATA = CalcMeanSpike(DATA,expid)

    p = DATA.probe;
    if isfield(DATA,'AllSpikes')
        Spks = DATA.AllSpikes{p};
    else
        Spks = DATA.AllData.Spikes;
    end
    for j = 1:size(DATA.Templates,1)
        scores(j,:) = Spks.values * DATA.Templates(j,:)';
    end
    for eid = expid;
        [DATA, ispk] = SetExptSpikes(DATA, eid,0);
        if length(ispk) > 100
            if length(ispk) > 10000
                xid = find(DATA.Spikes.cx(ispk) > prctile(DATA.Spikes.cx(ispk),99.9));
            else
                v = sort(DATA.Spikes.cx(ispk),'descend');
                xid = find(DATA.Spikes.cx(ispk) > v(100));
            end
            DATA.MeanSpike.v(eid,p,:) = mean(Spks.values(ispk(xid),:));
            DATA.MeanSpike.sd(eid,p,:) = std(Spks.values(ispk(xid),:));
        end
        trials = [DATA.Expts{eid}.Trials.Trial];
        for j = 1:length(DATA.Expts{eid}.Trials)
            times = [DATA.Expts{eid}.Trials(j).Start(1) DATA.Expts{eid}.Trials(j).End(end)];
            tspk = find(Spks.times(ispk) > times(1) & ...
                Spks.times(ispk) < times(2));
            cspk = find(Spks.codes(ispk(tspk),2) > 0);
            if isempty(cspk)
                sv = sort(DATA.Spikes.cx(tspk));
                if length(sv) > 5
                    DATA.TrialVar.cx(p,trials(j)) = -mean(sv(end-5:end));
                else
                    DATA.TrialVar.cx(p,trials(j)) = -mean(DATA.Spikes.cx(tspk));
                end
            else
                cspk = ispk(tspk(cspk));
                DATA.TrialVar.cx(p,trials(j)) = mean(DATA.Spikes.cx(cspk));
            end
            if length(tspk)
                DATA.TemplateScores(p,:,trials(j)) = max(scores(:,ispk(tspk)),[],2);
            end
        end
        if isfield(DATA.Expts{eid},'Cluster') & size(DATA.Expts{eid}.Cluster,2)>= p & isfield(DATA.Expts{eid}.Cluster{1,p},'dprime')
            DATA.MeanSpike.dprimes(p,eid) = DATA.Expts{eid}.Cluster{1,p}.dprime;
            spks = find(Spks.codes(ispk,2) == 1);
            DATA.MeanSpike.Cluster(eid,p,:) = mean(Spks.values(ispk(spks),:));
            DATA.MeanSpike.autocut(p,eid) = 0;
        else
            DATA = AutoCut(DATA, eid, 1,'noplot');
            spks = find(Spks.codes(ispk,2) == 1);
            DATA.MeanSpike.Cluster(eid,p,:) = mean(Spks.values(ispk(spks),:));
            if length(ispk) < 10
            DATA.MeanSpike.dprimes(p,eid) = NaN;
            else
            DATA.MeanSpike.dprimes(p,eid) = DATA.Expts{eid}.Cluster{1,p}.dprime;
            end
            DATA.MeanSpike.autocut(p,eid) = 1;
        end
    end

function ReCombineAll(a,b, varargin)
%
% go through all Expts. If a combined expt exists, use this list, then
% reccombine

j = 1;
lfponly = 0;
listonly = 0;
oneprobe = 0;
while j <= length(varargin)
    if strncmpi(varargin{j},'lfponly',5)
        lfponly = 1;
    elseif strncmpi(varargin{j},'listonly',5)
        listonly = 1;
        oneprobe = 1;
    elseif strncmpi(varargin{j},'oneprobe',5)
        oneprobe = 1;
        lfponly = -1;
    elseif strncmpi(varargin{j},'spkonly',5)
        lfponly = -1;
    end
    j = j+1;
end

if isstruct(a)
    DATA = a;
else
    DATA = GetDataFromFig(a);
end
if ~isfield(DATA,'Templates')
    load('StdTemplate.mat');
    DATA.Templates = Templates;
end

spikelist = WhichClusters(DATA.toplevel);
if spikelist == -1 %no clusters selected
    it = findobj(DATA.toplevel,'Tag','UseCluster1');
    set(it,'value',1);
    spikelist = WhichClusters(DATA.toplevel);
end
DATA.state.includeprobename = 1;
lfpfile = strrep(DATA.datafilename,'.mat','.lfp.mat');
if listonly == 0  && lfponly >= 0
fprintf('Loading %s ... ',lfpfile);
tic;
load(lfpfile);
fprintf(' Took %.1f\n',toc);
end
probedone = DATA.probe;
chk = 0;

if oneprobe | lfponly > 0
    probelist = probedone;
    oneprobe = 1;
else
    probelist = DATA.probelist;
end

d = dir(fileparts(DATA.datafilename));
str = ['.p' num2str(probedone) 'c1.'];
nf = 0;
for j = 1:length(d)
    if strfind(d(j).name,str)
       nf = nf+1;
       filenames{nf} = d(j).name;
       xfile(nf) = 1;
    end
end

if nf > 0
for j = 2:length(DATA.exptypelist)
%    DATA = ListSubExpts(DATA,j);
    [dp, poutname] = fileparts(CombinedName(DATA,j,DATA.spikelist(1),'probe',probedone));
    id = strmatch(poutname,filenames);
    if length(id)
        xfile(id) = 0;
    end
end
xid = find(xfile); %files with no match
else
    xfile  = zeros(size(DATA.exptypelist));
end

for p = 1:length(probelist)
    if listonly == 0 && oneprobe == 0
        if probelist(p) ~= DATA.probe
            DATA = SetProbe(DATA, probelist(p));
        end
    end

    for j = 2:length(DATA.exptypelist)+sum(xfile)
        if j <= length(DATA.exptypelist)
            set(DATA.clst,'value',j);
            DATA = ListSubExpts(DATA,j);
            poutname = CombinedName(DATA,j,DATA.spikelist(1),'probe',probedone);
            outname = CombinedName(DATA,j,DATA.spikelist(1));
            set(DATA.saveitem,'string',outname);
            if ~isempty(DATA.allcombineids{j})
                DATA.combineids = DATA.allcombineids{j};
                fprintf('%s',DATA.exptypelist{j})
                fprintf(',%d',DATA.combineids);
                fprintf('\n');
            else
                DATA.combineids = [];
            end
        else
            poutname = [dp '/' filenames{xid(j-length(DATA.exptypelist))}];
            outname = regexprep(poutname,'\.p[0-9]*c[0-9]\.',sprintf('.p%dc1.',probelist(p)))
            set(DATA.saveitem,'string',outname);
            DATA.combineids = [];
        end
        if isempty(DATA.combineids)
            if exist(poutname,'file')
                load(poutname);
                Expt.Header.Name = BuildName(Expt.Header.Name);
                DATA.Expt = Expt;
                if isfield(Expt.Header,'Combineids')
                    DATA.combineids = Expt.Header.Combineids;
                    DATA.allcombineids{j} = DATA.combineids;
                    fprintf('%s',splitpath(poutname))
                    fprintf(',%d',DATA.combineids);
                    fprintf('\n');
                else
                    DATA.combineids = [];
                    fprintf('%s no combineids',splitpath(poutname));
                    if DATA.logfid
                        fprintf(DATA.logfid,'%s no combineids',splitpath(poutname))
                    end
                end
            else
                DATA.combineids = [];
            end
        end
        if length(DATA.combineids)
            DATA.extype = j;
            id = find(ismember(DATA.expid,DATA.combineids));
            if isempty(id) %ids from a saved file, may not match list in GUI
                DATA.expid = DATA.combineids;
                id = find(ismember(DATA.expid,DATA.combineids));
            end

            if ~isempty(id)
                if listonly
                    fprintf('Expts ');
                    fprintf('%d ',id);
                    fprintf('of %d\n',length(DATA.expid));
                else
                    set(DATA.elst,'value',id);
                    if lfponly > 0
                        DATA.Expt = CombinePlot(DATA, 0);
                        combine('savelfp',DATA,LFP);
                    else
                        [Expt, DATA] = CombinePlot(DATA, chk);
                        %             Expt.Header.SpkStats = GetSpkStats(DATA);
                        drawnow;
                        nspk = sum([Expt.Trials.count]);
                        if j > length(DATA.exptypelist)
                            file = strrep(poutname,['.p' num2str(probedone)],['.p' num2str(probelist(p))]);
                            c = '*'
                        else
                            file = CombinedName(DATA,j,1);
                            c = '';
                        end
                        save(file,'Expt');
                        fprintf('Saved %d spikes (Expts %s) to %s\n',nspk,sprintf(' %d',DATA.combineids),file);
                        if DATA.logfid
                            fprintf(DATA.logfid, '%s,Saved %d spikes (Expts%s%s) to %s\n',datestr(now),nspk,c,sprintf(' %d',DATA.combineids),file);
                        end
                        nspk = Expt.Header.nspk;
                        nc = length(Expt.Header.nspk)-1;
                        cl = 1;
                        spikelist = DATA.spikelist;
                        while cl < nc
                            cl = cl+1;
                            if nspk(cl+1) > 10
                                DATA.spikelist = cl;
                                SetClusterCheck(DATA);
                                [Expt, DATA] = CombinePlot(DATA, chk);
                                if j > length(DATA.exptypelist)
                                    file = strrep(poutname,['.p' num2str(probedone) 'c1'],['.p' num2str(probelist(p)) 'c' num2str(cl)]);
                                    c = '*'
                                else
                                    file = CombinedName(DATA,j,cl);
                                    c = '';
                                end
                                save(file,'Expt');
                            end
                        end
                        DATA.spikelist = spikelist;
                        SetClusterCheck(DATA);
                        if p ==1  && lfponly == 0
                            DATA.Expt = Expt;
                            combine('savelfp',DATA,LFP);
                        end
                        %                CombineAll(a,DATA);
                    end
                end
            end
        end
    end
%Calculate spike shape AFTER combining, so that autocuts are
%shown
    DATA = CalcMeanSpike(DATA,1:length(DATA.Expts));
    if oneprobe ==0 && lfponly < 1
        SaveSpikeShape(DATA);
    end
end
set(DATA.toplevel,'UserData',DATA);

function spkstats = GetSpkStats(DATA)

% summary stats for a probe by expt, to try and track drift
spkstats = [];
ids = get(DATA.elst,'value');
exid = get(DATA.clst,'value');
if isfield(DATA,'AllSpikes')
    Spks = DATA.AllSpikes{DATA.probe};
else
    Spks = DATA.AllData.Spikes;
end
for j = 1:length(ids)
    Expt =  DATA.Expts{DATA.expid(ids(j))};
    mins = min(Spks.values(Expt.gui.spks,:)');
    maxs = max(Spks.values(Expt.gui.spks,:)');
    if length(mins) > 10 && length(maxs) > 10
    spkstats.max(j,:) = prctile(maxs,[50 90 99]);
    spkstats.min(j,:) = prctile(maxs,[50 10 1]);
    spkstats.h(j,:) = prctile(maxs-mins,[50 90 99]);
    spkstats.k(j) = moment(maxs-mins,3);
    else
        spkstats.max(j,:) = [0 0 0];
        spkstats.min(j,:) = [0 0 0];
        spkstats.h(j,:) = [0 0 0];
        spkstats.k(j) = 0;
    end
    if isempty(Expt.gui.spks)
            spkstats.trange(j,:) = [0 0];
    else
        spkstats.trange(j,:) = [min(Spks.times(Expt.gui.spks)) ...
            max(Spks.times(Expt.gui.spks))];
        ispk = Expt.gui.spks;
        if ~isfield(DATA,'Spikes') || max(ispk) > length(DATA.Spikes.cx) || sum(DATA.Spikes.cx(ispk)) == 0
            DATA = CalcClusterVars(DATA,ispk);
        end
            if length(ispk) > 10000
                xid = find(DATA.Spikes.cx(ispk) > prctile(DATA.Spikes.cx(ispk),99.9));
            elseif length(ispk) > 100
                v = sort(DATA.Spikes.cx(ispk),'descend');
                xid = find(DATA.Spikes.cx(ispk) > v(100));
            else
                xid = 1:length(ispk);
            end
            spkstats.V = mean(Spks.values(ispk(xid),:));
            xid = find(Spks.codes(ispk,2) == 1);
            if length(xid)
                spkstats.cV = mean(Spks.values(ispk(xid),:));
            end
    end
end



function CombineAll(a,DATA, checkonce)
%
%Combine all probes, for one expt
%Don't redo LFP here. Too slow.
if nargin < 3
    checkonce = 1;
end

if ~isstruct(DATA)
    DATA = GetDataFromFig(a);
end
DATA.state.includeprobename = 1;
    eid = get(DATA.clst,'value');
    outname = DATA.outname;
    DATA.extype = eid;
for j = 1:length(DATA.probelist)
    DATA = SetProbe(DATA, DATA.probelist(j));
    if j == checkonce
        chk = 1;
    else
        chk = 0;
    end
    Expt = CombinePlot(DATA, chk);
%    Expt.Header.SpkStats = GetSpkStats(DATA);
    drawnow;
    nspk = sum([Expt.Trials.count]);
    file = regexprep(outname,'\.p[0-9]*c1\.',['.p' num2str(DATA.probelist(j)) 'c1.']);
%    file = CombinedName(DATA,eid,1);
    save(file,'Expt');
    fprintf('Saved %d spikes to %s\n',nspk,file);
    if DATA.logfid
        fprintf(DATA.logfid, '%s,Saved %d spikes (Expts%s) to %s\n',datestr(now),nspk,sprintf(' %d',Expt.Header.Combineids),file);
    end
end
DATA.Expt = Expt;
if DATA.state.online == 0
%combine('savelfp',DATA);
end
    
function FitButton(a,b)

DATA = GetDataFromFig(a);
[DATA.Expt, plotres] = PlotCombined(DATA, DATA.Expt);
fit = FitExpt(plotres,'plot');
DATA = AddFitToData(DATA, plotres, fit);
set(DATA.toplevel,'UserData',DATA);

function DATA = AddFitToData(DATA, plotres, fit)
type = strmatch(plotres.type{1},{'Op' 'Pp'});
if ~isempty(type)
    if type(1) == 1
        DATA.fitvals.Op = fit.mean;
        DATA.fitvals.Opw = fit.sd;
        DATA.fitvals.OpRo = GetEval(DATA.Expt,'Ro');
        DATA.Expt.fits.Op = fit;
    elseif type(1) == 2
        DATA.fitvals.Pp = fit.mean;
        DATA.fitvals.PpRo = GetEval(DATA.Expt,'Ro');
        DATA.fitvals.Ppw = fit.sd;
        DATA.Expt.fits.Pp = fit;
    end
end

        
        function cntrl_box = setshow(DATA, tag)
wsc = DATA.wsc;
SPACE = 3 * wsc(1);
VSPACE = 5 * wsc(2);
h = 220 * wsc(2);
w = 350 * wsc(1);
scrsz = get(0,'Screensize');
cw = DATA.plot.cw;
ch = DATA.plot.ch;
SpkDefs;
   bp(1) = SPACE;
   bp(2) = ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   dat.parentfigtag = DATA.tag.top;
cntrl_box = figure('Position', [200 scrsz(4)-(h+30)*wsc(2) w*wsc(1) h*wsc(2)], 'Menubar', 'none',...
    'NumberTitle', 'off', 'Tag',tag,'Name','Showvals','UserData',dat);
  
fn = fields(DATA.show);
for j = 1:length(fn)
    id = strmatch(fn{j},CodeNames.Codes);
    if length(id)
        str = CodeNames.Label{id};
    else
        str = fn{j};
    end
        uicontrol(gcf,'Style', 'CheckBox','String',str,'Position', bp,...
   'Tag',fn{j},'Callback',@@ShowUpdate,'value',DATA.show.(fn{j}));
bp(2) = bp(2)+ch+SPACE;
end

function str = vec2str(x)
          str = [int2str(x(1)) ':' int2str(x(end))];

function cntrl_box = setoptions(DATA, tag)

wsc = DATA.wsc;
SPACE = 3 * wsc(1);
VSPACE = 5 * wsc(2);
h = 220 * wsc(2);
w = 350 * wsc(1);
ch = DATA.plot.ch;
cw = DATA.plot.cw;
scrsz = get(0,'Screensize');

cntrl_box = findobj('Tag',tag,'Name','Options');
if ~isempty(cntrl_box)
    figure(cntrl_box);
    return;
end
if ~isfield(DATA,'figpos') | isempty(DATA.figpos{1})
   bp = get(DATA.toplevel,'Position');    
   DATA.figpos{1} =  [bp(1)+bp(3) bp(2) w*wsc(1) h*wsc(2)]
end
dat.parentfigtag = DATA.tag.top;
cntrl_box = figure('Position', DATA.figpos{1} , 'Menubar', 'none',...
    'NumberTitle', 'off', 'Tag',tag,'Name','Options','UserData',dat);


top = num2str(DATA.toplevel); 
bp(1) = SPACE;
bp(2) = ch+VSPACE;
bp(3) = cw*9;
bp(4) = ch+VSPACE;
   cw = 10 * wsc(1);
   ch = 11 * wsc(2);
   bh = 18*wsc(2);
   bp(1) = SPACE;
   bp(2) = ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   if ~isfield(DATA.plot,'acov')
       DATA.plot.acov = 0;
       DATA.plot.collapse = 0;
       DATA.plot.flip = 0;
   end
   uicontrol(gcf,'Style', 'CheckBox','String','Limit Range','Position', bp,...
      'Tag','FixRange','Callback',@@Update,'value',DATA.state.fixrange);
   bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','ShowEM','Position', bp,...
      'Tag','ShowEM','Callback',@@Update,'value',DATA.plot.showem);


   bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Flip','Position', bp,...
      'Tag','Flip','Callback',@@Update,'value',DATA.plot.flip);
   bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Collapse 1','Position', bp,...
      'Tag','Collapse1','Callback',@@Update,'value',DATA.plot.collapse);
   bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Acov','Position', bp,...
      'Tag','Acov','Callback',@@Update,'value',DATA.plot.acov);
   bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','ISIH','Position', bp,...
      'Tag','ISIH','Callback',@@Update,'value',DATA.plot.showISI);
   bp(1) = bp(1)+bp(3)+SPACE;
   uicontrol(gcf,'Style', 'pushbutton','String','Plot ISIH','Position', bp,...
      'Callback','combine(''PlotISI'')');

  bpa = bp;
  % second column of checkboxes 
  bh = 18*wsc(2);
   bp(1) = SPACE+bp(3);
   bp(2) = ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','dV vs V','Position', bp,...
      'Tag','PhasePlot','Callback',@@Update,'value',(DATA.plot.dvdt == 2));
   bp(2) = bp(2)+ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Remove DC','Position', bp,...
      'Tag','RemoveDC','Callback',@@Update,'value',DATA.plot.nodc);

   bp(2) = bp(2)+ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Auto relist','Position', bp,...
      'Tag','AutoList','Callback',@@Update,'value',DATA.state.autolist);

  bp(2) = bp(2)+ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','AutoFit','Position', bp,...
      'Tag','AutoFit','Callback',@@Update,'value',DATA.state.autofit);
  bp(2) = bp(2)+ch+VSPACE;
   bp(3) = cw*9;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Condense RC','Position', bp,...
      'Tag','Condense','Callback',@@Update,'value',DATA.plot.condenseRC);

  % third column of checkboxes 
  bp(1) = bp(1)+bp(3) + SPACE;
  bp(2) = ch+VSPACE;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','.pN in name','Position', bp,...
      'Tag','NameProbe','Callback',@@Update,'value',DATA.state.includeprobename);

  bp(2) = bp(2)+ch+VSPACE;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Plot F1','Position', bp,...
      'Tag','PlotMod','Callback',@@Update,'value',DATA.plot.plotmod);

  bp(2) = bp(2)+ch+VSPACE;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Auto Advance','Position', bp,...
      'Tag','AutoNext','Callback',@@Update,'value',DATA.state.autonext);
  
  bp(2) = bp(2)+ch+VSPACE;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Hide Spikes','Position', bp,...
      'Tag','NoSpikes','Callback',@@Update,'value',DATA.state.nospikes);
  
  bp(2) = bp(2)+ch+VSPACE;
   bp(4) = ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','Force rebuild','Position', bp,...
      'Tag','ForceBuild','Callback',@@Update,'value',DATA.state.forcebuild);

  % fourth column of checkboxes 
  bp(1) = bp(1)+bp(3) + SPACE;
  bp(2) = ch+VSPACE;
   bp(4) = ch+VSPACE;
   if ~isfield(DATA.state, 'optimizeclusters')
       DATA.state.optimizeclusters = 0;
   end
   uicontrol(gcf,'Style', 'CheckBox','String','Opimize','Position', bp,...
      'Tag','OptimizeClusters','Callback',@@Update,'value',DATA.state.optimizeclusters);
  bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'CheckBox','String','xCorr','Position', bp,...
      'Tag','ShowxCorr','Callback',@@Update,'value',DATA.plot.xcorr);
   uicontrol(gcf,'Style', 'CheckBox','String','+hash','Position', bp,...
      'Tag','AddHash','Callback',@@Update,'value',DATA.plot.addhash);
  %back to left side
  bp = bpa;
   
   bp(1) = SPACE;
  bp(2) = bp(2)+ch+VSPACE;
   uicontrol(gcf,'Style', 'pop','String',DATA.spkvarnames,'Position', bp,...
      'Tag','ClusterX','Callback',@@Update,'value',DATA.plot.clusterX);
   
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.clusterXrange(1)),'Position', bp,...
      'Tag','ClusterXmin','Callback',@@Update);


  bp(2) = bp(2)+ch+VSPACE;
   bp(1) = SPACE;
   bp(3) = cw*9;
   uicontrol(gcf,'Style', 'pop','String',DATA.spkvarnames,'Position', bp,...
      'Tag','ClusterY','Callback',@@Update,'value',DATA.plot.clusterY);

  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.clusterYrange(1)),'Position', bp,...
      'Tag','ClusterYmin','Callback',@@Update);

  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
    uicontrol(gcf,'Style', 'text','string','AutoCut','Position',bp);

  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
 uicontrol(gcf,'Style', 'pop','String','Centiles|By Density|Test|None','Position', bp,...
      'Tag','AutoCutMode','Callback',@@Update,'value',DATA.plot.autoclustermode+1);

  bp(2) = bp(2)+ch+VSPACE;
   bp(1) = SPACE;
  uicontrol(gcf,'Style', 'text','string','Pt Range A','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',vec2str(DATA.clusterArange),'Position', bp,...
      'Tag','ClusterArange','Callback',@@Update);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw;
  uicontrol(gcf,'Style', 'text','string','B','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',vec2str(DATA.clusterBrange),'Position', bp,...
      'Tag','ClusterBrange','Callback',@@Update);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw;
  uicontrol(gcf,'Style', 'text','string','E','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',vec2str(DATA.clusterErange),'Position', bp,...
      'Tag','ClusterErange','Callback',@@Update);

  bp(2) = bp(2)+ch+VSPACE;
   bp(1) = SPACE;
   uicontrol(gcf,'Style', 'text','string','N Min','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.nmin),'Position', bp,...
      'Tag','Nmin','Callback',@@Update);

  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.nminrc),'Position', bp,...
      'Tag','RCNmin','Callback',@@Update);

    bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'text','string','CP','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'pop','String','None|CP-time|CP trials|CP-hist|CP-EM|Psych Only|Psych Smooth','Position', bp,...
      'Tag','ShowCP','Callback',@@Update,'value',DATA.plot.showcp+1);

    bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'text','string','PtSz','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5; 
  uicontrol(gcf,'Style', 'pop','String','Auto|1|2|3|4|5|6|7|8', 'Position',bp,...
      'Tag','SetPtSize','Callback',@@Update,'value',DATA.plot.setptsize+1);

  
  
  bp(2) = bp(2)+ch+VSPACE;
   bp(1) = SPACE;
   uicontrol(gcf,'Style', 'text','string','sdfw','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.sdfw),'Position', bp,...
      'Tag','Sdfw','Callback',@@Update);

    bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'text','string','MLFP','Position',bp);
   if ~isfield(DATA.plot,'lfpplot');
       DATA.plot.lfpplot = 0;
   end
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5; 
  uicontrol(gcf,'Style', 'pop','String','None|Default|Stack|Image|Blank|RC|Movie|OneStim|monocs|Eig|Var|BlankVar|Frameresp', 'Position',bp,...
      'Tag','LFPPlot','Callback',@@Update,'value',DATA.plot.lfpplot+1);
  

  bp(2) = bp(2)+ch+VSPACE;
  bp(3) = cw * 18;
   bp(1) = SPACE;
   uicontrol(gcf,'Style', 'text','string','Spike Display MaxV','Position',bp);
  bp(1) = bp(1)+bp(3)+SPACE;
  bp(3) = cw * 5;
  if ~isfield(DATA.plot,'SpikeMaxV')
      DATA.plot.SpikeMaxV = 5;
  end
  if ~isfield(DATA.plot,'SpikeMinV')
      DATA.plot.SpikeMinV = -5;
  end
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.SpikeMinV),'Position', bp,...
      'Tag','SpikeMaxV','Callback',@@Update);
  bp(1) = bp(1)+bp(3)+SPACE;
   uicontrol(gcf,'Style', 'edit','string',num2str(DATA.plot.SpikeMaxV),'Position', bp,...
      'Tag','SpikeMaxV','Callback',@@Update);
  
  if isfield(DATA,'AllSpikes')
      bp(1) = SPACE;
      bp(2) = bp(2)+ch+VSPACE;
      bp(3) = cw * 5;
%       bp(1) = SPACE;
      uicontrol(gcf,'Style', 'text','string','Sync','Position',bp);

      bp(1) = bp(1)+bp(3)+SPACE;
      bp(3) = cw * 5;
      uicontrol(gcf,'Style', 'pop','String','Neg|Either|Pos|None|PlotbyNeg|PlotByPos|PlotByAll', 'Position',bp,...
      'Tag','SyncSign','Callback',@@Update,'value',DATA.syncsign+2);
      bp(1) = bp(1)+bp(3)+SPACE;
      bp(3) = cw * 5;
   uicontrol(gcf,'Style', 'CheckBox','String','Overlay','Position', bp,...
      'Tag','SyncOverlay','Callback',@@Update,'value',DATA.plot.syncoverlay)
      bp(1) = bp(1)+bp(3)+SPACE;
      bp(3) = cw * 5;
      uicontrol(gcf,'Style', 'pop','String','None|Min|Max|Energy|PCA1-1|PCA2-2|PCA1-2|Xcorr-PCA|CX-CX|CY-CY|Sum|test', 'Position',bp,...
      'Tag','SyncCluster','Callback',@@Update,'value',DATA.plot.synccluster+1);
  end


  
  function ShowUpdate(a,b)

DATA = GetDataFromFig(a);
fn = fields(DATA.show);
for j = 1:length(fn)
    DATA.show.(fn{j}) = GetShow(DATA,fn{j});
end
set(DATA.toplevel,'UserData',DATA);

function [value, it] = GetShow(DATA,tag)
it = findobj(DATA.showid, 'Tag',tag);
if ~isempty(it) 
    value = get(it(1),'value');
else
    value = 0;
end

function SetClusterCheck(DATA)
     SetCheck('UseCluster1',ismember(1,DATA.spikelist));
     SetCheck('UseCluster2',ismember(2,DATA.spikelist));
     SetCheck('UseCluster3',ismember(3,DATA.spikelist));
     SetCheck('UseCluster4',ismember(4,DATA.spikelist));

  

function SetGui(DATA);
    SetCheck('Recut',DATA.state.recut > 0); %% in case it is 2
    SetCheck('Recount',DATA.state.recount);
    SetClusterCheck(DATA);
    if isfigure(DATA.xyfig)
    it = findobj(DATA.xyfig,'Style', 'pushbutton', 'Tag','Density');
    if it
        if DATA.densityplot
            set(it,'String','Pts');
        else
            set(it,'String','Dens');
        end
    
    ax = findobj(DATA.xyfig,'Type','axes');
    if DATA.plot.autoscale
        set(ax,'Ylimmode','auto','Xlimmode','auto');
        DATA.plot.clusterXrange  = get(ax(1),'Xlim');
        DATA.plot.clusterYrange  = get(ax(1),'Ylim');
        SetField(DATA.xyfig,'ClusterXmax',DATA.plot.clusterXrange(2));
        SetField(DATA.xyfig,'ClusterYmax',DATA.plot.clusterYrange(2));
    else
        set(ax,'Ylim', DATA.plot.clusterYrange,'Xlim',DATA.plot.clusterXrange);
    end
    end
    end
    if isfigure(DATA.optionfig)
    SetField(DATA.optionfig,'ClusterXmin',DATA.plot.clusterXrange(1));
    SetField(DATA.optionfig,'ClusterYmin',DATA.plot.clusterYrange(1));
    end


function SetClusters(a,b,tag)
DATA = get(findobj('Tag',tag),'UserData');
DATA.spikelist = WhichClusters(DATA.toplevel);
if DATA.state.online == 2
    DATA.Expts = CountTxtSpikes(DATA.Expts,DATA.probe,DATA.spikelist);
end
if DATA.state.autoplot
    combine('setexpt','Tag', tag);
end
set(DATA.toplevel,'UserData',DATA);

function xcorrhit(a,b, varargin);
DATA = GetDataFromFig(a);

function SetProbeHit(a,b, varargin)

DATA = GetDataFromFig(a);
if DATA.playingspk
    set(findobj(DATA.svfig,'Tag','StopSpool'),'value',1);
    return;
end
f = get(a);
if isfield(f,'Value')
    id = get(a,'value');
    DATA.probe= DATA.probelist(id);
end

j = 1;
while j <= length(varargin)
    if strcmp('ReloadProbe',varargin{j})
        if isfield(DATA,'AllSpikes')
        DATA = rmfield(DATA,'AllSpikes');
        end
        if isfield(DATA,'AllClusters')
            DATA = rmfield(DATA,'AllClusters');
        end
        if isfield(DATA,'sids')
            DATA = rmfield(DATA,'sids');
        end
    end
    j = j+1;
end
if isfield(DATA,'AllSpikes')
    [DATA, DATA.spklist] = SetExptSpikes(DATA,DATA.currentexpt,'setrange');
    nloaded = 0;
    for j = 1:length(DATA.AllSpikes)
        if isfield(DATA.AllSpikes{j},'codes') & length(DATA.AllSpikes{j}.codes) > 10
            nloaded = nloaded+1;
        end
    end
elseif DATA.probe == 100
    set(DATA.toplevel,'UserData',DATA);
    return;
else
    DATA = SetProbe(DATA, DATA.probe);
    nloaded = 1;
end
DATA.outname = regexprep(DATA.outname,'.p[0-9]*c([0-9]).',sprintf('.p%dc$1.',DATA.probe));
set(DATA.saveitem,'string',DATA.outname);
set(DATA.toplevel,'UserData',DATA);
playspk = get(findobj(DATA.toplevel,'Tag','ShowSpikes'),'value');
%
% if > 3 probes are laoded, don't spool through them every time the probe
% hit is changed. 
if (DATA.state.autoplot | playspk) & nloaded < 4
    DATA = combine('setexp', DATA);
else
    GetFigure(DATA.xyfig);
    DATA = CalcClusterVars(DATA,  DATA.spklist);
    DATA.Expts{DATA.currentexpt}.gui.spks = DATA.spklist;
    hold off;
    DrawXYPlot(DATA, DATA.spklist);
end
set(DATA.toplevel,'UserData',DATA);


function DATA = SetProbe(DATA, probe)

    DATA.probe = probe;
set(DATA.toplevel,'Name',sprintf('Loading Probe %d...',DATA.probe));
drawnow;
fprintf('Loading Probe %d...',DATA.probe);
tic;
if ~isfield(DATA,'currentexpt')
    DATA.currentexpt = 1;
end
if isfield(DATA,'AllClusters')
    DATA.Spikes.cx = DATA.AllClusters(probe).cx;
    DATA.Spikes.cy = DATA.AllClusters(probe).cy;
    DATA.AllData.Spikes.times = DATA.AllClusters(probe).times;
    DATA.AllData.Spikes.codes = zeros(length(DATA.AllClusters(probe).times),4);
    for j = 1:length(DATA.Expts)
        DATA.Expts{j}.gui.classified = 0;
    end
else
DATA = LoadSpikes(DATA, DATA.currentexpt);
DATA = LoadClusters(DATA,ClusterFile(DATA));
end
fprintf('took %.2f\n',toc);
NotBusy(DATA);

function filename = GetProbeFilename(DATA, eid, probe)

id = find(DATA.probelist == probe);
        if DATA.state.online == 0
            if length(id) > 1
            else
            if DATA.probelist(id) > 16
                filename = strrep(DATA.datafilename,'.mat',sprintf('A.p%s.mat',DATA.probevars{id}(3:end)));
            else
                filename = strrep(DATA.datafilename,'.mat',sprintf('.p%s.mat',DATA.probevars{id}(3:end)));
            end
            end
        else
            filename = ['C:' DATA.Expts{eid}.Header.Name];
            if DATA.probelist(id) > 16
                filename = strrep(filename,'/Expt','A/Expt');
            end
        end

        
    function DATA = LoadSpikes(DATA, eid)

    if ~isfield(DATA,'probes')
        return;
    end
        id = find([DATA.probes.probe] == DATA.probe);
% with online data, where part way through there is a change in the list of
% available probes, so use DATA.probelist
      if DATA.state.online
          id = find([DATA.probelist] == DATA.probe);
      else
 %DATA.probes.probes, unlike DATA.probelist,  will have mulitple entries if the data are split across
 % multiple files (offline only)
        id = find([DATA.probes.probe] == DATA.probe);
      end
        if DATA.state.online == 0
            if length(id) > 1 || length(DATA.probes) > 2 %KLUDGE Need to detect new files with only 1 expt
                DATA.AllData.Spikes = GetProbeFiles(DATA,DATA.probe);
            else
                if DATA.probelist(id) > 16
                    filename = strrep(DATA.datafilename,'.mat',sprintf('A.p%s.mat',DATA.probevars{id}(3:end)));
                else
                    filename = strrep(DATA.datafilename,'.mat',sprintf('.p%s.mat',DATA.probevars{id}(3:end)));
                end
                [d, a,b]  = fileparts(filename);
                filename = [d '/Spikes/' a b];
                [DATA.AllData.Spikes]= GetProbeSpikes(DATA.AllData, filename, DATA.probevars{id});
            end
            DATA.spklist = [];
            for j = 1:length(DATA.Expts)
                DATA = SetExptSpikes(DATA, j, 'setrange');
            end
            DATA.spklist = DATA.Expts{DATA.currentexpt}.gui.spks;
            DATA = SetExptSpikes(DATA, eid, 0);
        else
            filename = ['C:' DATA.Expts{eid}.Header.Name];
            if DATA.probelist(id) > 16
                filename = strrep(filename,'/Expt','A/Expt');
            end
            [DATA.AllData.Spikes]= GetProbeSpikes(DATA.AllData, filename , DATA.probevars{id});
            DATA.spklist = [];
            DATA = SetExptSpikes(DATA, eid, 0);
            DATA = CountSpikes(DATA,eid);

            %  DATA = SetSpkCodes(DATA, [1:length(DATA.AllData.Spikes.times)], 0)
        end

function Spikes = GetProbeFiles(DATA, probe, varargin)
%GetProbeFiles loads up spikes that are spli across files.
% given a time range (in sec, not tics) only loads files needed for that
% range
    trange = [];
    nodv = 0;
j = 1;
while j <= length(varargin)
    if strncmpi(varargin{j}, 'trange',3)
        j = j+1;
        trange = varargin{j};
    elseif strncmpi(varargin{j}, 'nodv',3)
        nodv = 1;
    end
    j = j+1;
end
    id = find([DATA.probes.probe] == probe);
    [dp,pref] = fileparts(DATA.datafilename);
    Spk.times = [];
    Spk.values = [];
    Spk.codes = [];
    [a,sid] = sort([DATA.probes(id).first]);
    sid = id(sid);
    if length(trange) > 1
%fid is files that are past the point we need
        fid = find([DATA.probes(sid).first] > trange(2));
        if isempty(fid)
            fid = length(sid)+1;
        end
        lid = find([DATA.probes(sid).last] < trange(1));
        if isempty(lid) %need first file
            sid = sid(1:fid(1)-1);
        elseif fid(1) == lid(end)+1
            sid = sid(fid(1));
        else
            sid = sid(lid(end)+1:fid(1)-1);
        end
        fprintf('Spike file %d\n',sid);
    end
    for j = 1:length(sid)
    filename = [dp '/Spikes/' DATA.probes(sid(j)).filename];
    if exist(filename,'file')
        a = load(filename);
        chname = DATA.probes(sid(j)).var;
        if isempty(Spk.times)
            Spk = a.(chname);
        else
            Spk.times = [Spk.times; a.(chname).times];
            Spk.codes = [Spk.codes; a.(chname).codes];
            Spk.values = [Spk.values; a.(chname).values];
            if size(a.(chname).times,1) > size(a.(chname).values,1)
                fprintf('Some Missing Spike values in %s\n',filename);
                if DATA.logfid
                    fprintf(DATA.logfid,'Some Missing Spike values in %s\n',filename);
                end
            end
        end
    else
        fprintf('No file %s\n',filename);
    end    
    end

if ~isempty(Spk.values) 
    if size(Spk.values,1) < length(Spk.times)
        fprintf('Some Missing Spike values in %s\n',pref);
    end
    
    if nodv == 0
    Spikes = CleanSpikes(Spk,'bufl',10000); 
    else
        Spikes = Spk;
    end
    Spikes.times = Spikes.times .* 10000;
    if isfield(DATA.probes, 'firsti')
        Spikes.firstspki = DATA.probes(sid(1)).firsti;
    end
    cfile = ClusterFile(DATA,'probe',probe);
    if exist(cfile,'file')
        load(cfile);
        lastspk = DATA.probes(sid(end)).firsti+DATA.probes(sid(end)).nspk-1;
        if length(clid) < lastspk
            lastspk = length(clid);
            nspk = 1+lastspk-Spikes.firstspki;
        Spikes.codes(1:nspk,2) = clid(Spikes.firstspki:lastspk);
        else
        Spikes.codes(:,2) = clid(Spikes.firstspki:lastspk);
        end
        Spikes.codes = Spikes.codes(:,1:2);
    end
else
    fprintf('No Spike values %s\n',filename);
    Spikes = [];
end



function Spikes = GetProbeSpikes(All, filename, varname)
    if exist(filename,'file')
    load(filename);
    else
        fprintf('No file %s\n',filename);
        Spikes = [];
        return;
    end
    if exist(varname,'var')
%        Spikes = eval(varname);
    Spikes = eval(['CleanSpikes(' varname ', ''bufl'',10000);']);        
    Spikes.times = Spikes.times .* 10000;
    else
        fprintf('No data for %s in %s\n',varname,filename);
        Spikes = [];
    end

function Update(a,b)

DATA = GetDataFromFig(a);
DATA = combine('getstate');
caller = get(a,'Tag');

if strcmp(caller,'AllDensity')
    PlotAllProbeXY(DATA);
    return;
end

if DATA.xyfig & get(a, 'Parent') == DATA.xyfig
    DATA.plot.autoscale = GetCheck('AutoScale',DATA.xyfig);
    it = findobj(DATA.xyfig,'Tag','Clusterid');
    DATA.currentcluster = get(it,'value');
        ax = findobj(DATA.xyfig,'Type','axes');
    if DATA.plot.autoscale
        set(ax,'Ylimmode','auto','Xlimmode','auto');
        DATA.plot.clusterXrange  = get(ax,'Xlim');
        DATA.plot.clusterYrange  = get(ax,'Ylim');
        SetField(DATA.xyfig,'ClusterXmax',DATA.plot.clusterXrange(2));
        SetField(DATA.xyfig,'ClusterYmax',DATA.plot.clusterYrange(2));
    else
        set(ax,'Ylim', DATA.plot.clusterYrange,'Xlim',DATA.plot.clusterXrange);
    end
else
DATA.plot.dvdt = GetCheck('dVdt');
DATA.plot.nodc = GetCheck('RemoveDC');
dvv = GetCheck('PhasePlot');
if DATA.plot.dvdt && dvv
    DATA.plot.dvdt = 2;
end

DATA.state.recut = GetCheck('Recut');
DATA.state.showspkxy = GetCheck('SpkXY');
DATA.state.recount = GetCheck('Recount');
DATA.state.plotpsych = GetCheck('PlotPsych');
DATA.state.plotcombined = GetCheck('PlotCombined');
DATA.plot.plotmod = GetCheck('PlotMod');
DATA.plot.showsync = GetCheck('ShowSync');
DATA.state.showspikes = GetCheck('ShowSpikes');
[DATA.state.autoplot, h] = GetCheck('AutoPlot');
DATA.state.autonext = GetCheck('AutoNext');
DATA.state.nospikes = GetCheck('NoSpikes');
DATA.state.optimizeclusters = GetCheck('OptimizeClusters');
DATA.spikelist = WhichClusters(DATA.toplevel);
DATA.state.uselfp = get(findobj(DATA.toplevel,'Tag','UseLFP'),'value');
DATA.state.forcebuild = GetCheck('ForceBuild');

DATA.state.plotseq = get(findobj(DATA.toplevel,'Tag','PlotSeq'),'value')-1;
if isempty(DATA.plot.autoclustermode)
    DATA.plot.autoclustermode = 1;
end
for j = DATA.probelist
    DATA.plot.useprobe(j) = GetCheck(['UseProbe' num2str(j)]);
end

if DATA.state.online %%no LFP available
    DATA.state.uselfp = 0;
end
id = regexp(DATA.outname,'\.c[0-9]\.');
if id & DATA.spikelist >= 0
    DATA.outname(id+2) = num2str(DATA.spikelist(1));
    set(DATA.saveitem,'string',DATA.outname);
end
it = findobj('Tag',DATA.tag.options);
if ~isempty(it)
    DATA.plot.autoclustermode = get(findobj(it,'Tag','AutoCutMode'),'value')-1;
    DATA.state.fixrange = GetCheck('FixRange');
    DATA.plot.showem = GetCheck('ShowEM',it);
    DATA.plot.showcp = get(findobj(it,'Tag','ShowCP'),'value')-1;
    DATA.plot.condenseRC = GetCheck('Condense',it);
    DATA.plot.clusterX = get(findobj(it,'Tag','ClusterX'),'value');
    DATA.plot.clusterY = get(findobj(it,'Tag','ClusterY'),'value');
    DATA.plot.clusterXrange(1) = GetField('ClusterXmin',it);
    DATA.plot.clusterYrange(1) = GetField('ClusterYmin',it);
    DATA.clusterArange = GetField('ClusterArange',it);
    DATA.clusterBrange = GetField('ClusterBrange',it);
    DATA.clusterErange = GetField('ClusterErange',it);
    DATA.plot.nmin = GetField('Nmin',it);
    DATA.plot.nminrc = GetField('RCNmin',it);
    DATA.plot.sdfw = GetField('Sdfw',it);
    DATA.plot.SpikeMaxV = GetField('SpikeMaxV',it);
    DATA.plot.DensitySigma = [3 3];
    DATA.plot.addhash = GetCheck('AddHash',it);
    DATA.plot.xcorr = GetCheck('ShowxCorr',it);
    if length(DATA.plot.clusterX) > 1 || length(DATA.plot.clusterY) > 1
        fprintf('ClusterX/Y is too big');
    end
    DATA.plot.acov = GetCheck('Acov',it);
    DATA.state.includeprobename = GetCheck('NameProbe',it);
    DATA.state.autofit = GetCheck('AutoFit',it);
    DATA.plot.flip = GetCheck('Flip',it);
    DATA.plot.collapse = GetCheck('Collapse1',it);
    DATA.plot.showISI = GetCheck('ISIH',it);
    [DATA.state.autolist, h] = GetCheck('AutoList');
    DATA.plot.setptsize = get(findobj(it,'Tag','SetPtSize'),'value')-1;
    DATA.plot.lfpplot = get(findobj(it,'Tag','LFPPlot'),'value')-1;
    if isfield(DATA,'AllSpikes')
    a = get(findobj(it,'Tag','SyncSign') ,'value')-2;
    if ~isempty(a)
        DATA.syncsign = a;
        DATA.plot.synccluster = get(findobj(it,'Tag','SyncCluster') ,'value')-1;
    end
    DATA.plot.syncoverlay = GetCheck('SyncOverlay',it);
    end
end
end
set(DATA.toplevel,'UserData',DATA);

if strmatch(caller,{'PlotSeq' 'Psych'})
    PlotCombined(DATA,DATA.Expt);
elseif strmatch(caller,{'LFPPlot'}) & isfield(DATA,'LFP')
    ShowLFPPlot(DATA);
end
    if strmatch(caller,{'ClusterX' 'ClusterY'})
        if isfield(DATA,'spklist') && ~isempty(DATA.spklist)
        expspks = DATA.spklist;
    else
        expspks = DATA.spkrange(1):DATA.spkrange(2);
        end
    GetFigure(DATA.xyfig);
    hold off;
    DATA = CalcClusterVars(DATA, expspks);
    if DATA.plot.setptsize
        DATA.ptsize = DATA.plot.setptsize;
    end
    DrawXYPlot(DATA,expspks);
    end

% used to read
%if DATA.state.autoplot & a ~= h & ~ DATA.state.showspikes
% but h is not set. What was this?

if DATA.state.autoplot & ~ DATA.state.showspikes
    combine('setexp');
end
    
function SetField(parent, tag, value, varargin)
if isfigure(parent)
    it = findobj(parent,'Tag', tag);
else
    it = findobj('Tag', tag);
end
if it
    set(it,'string',num2str(value));
end

function value = GetField(tag, varargin)

if nargin == 2 & isfigure(varargin{1})
    it = findobj(varargin{1},'Tag',tag);
else    
    it = findobj('Tag',tag);
end
if ~isempty(it) 
    value = str2num(get(it(1),'string'));
else
    value = NaN;
end

function [value, it] = GetCheck(tag, varargin)

if nargin == 2 & isfigure(varargin{1})
    it = findobj(varargin{1},'Tag',tag);
else    
    it = findobj('Tag',tag);
end
if ~isempty(it) 
    value = get(it(1),'value');
else
    value = 0;
end

function [success] = SetCheck(tag, value,  varargin)

if nargin == 3 & isfigure(varargin{1})
    it = findobj(varargin{1},'Tag',tag);
else    
    it = findobj('Tag',tag);
end
if ~isempty(it) 
    set(it(1),'value',value);
    success = 1;
else
    success = 0;
end
    
function args = PlotArgs(DATA, Expt)

if isfield(DATA.tag,'rcfiga')
    args = {'rcfiga' DATA.tag.rcfiga 'figb' DATA.tag.rcfigb};
else
    args = {};
end
psych = get(findobj('Tag','PlotPsych','Parent',DATA.toplevel),'value');
if ~isfield(Expt.Trials,'RespDir') %% no psych here
    psych = 0;
end
seq = get(findobj('Tag','PlotSeq','Parent',DATA.toplevel),'value')-1;
on = get(findobj('Tag','ShowN','Parent',DATA.toplevel),'value');

if on
    args = {args{:} 'shown'};
end
on = get(findobj('Tag','PlotSeq','Parent',DATA.toplevel),'value')-1;
if psych & seq
        args = {args{:} 'psychnoplot' 'cpseq'};
else
    if psych
        args = {args{:} 'psych'};
    end
    if seq == 1
        args = {args{:} 'seqt'};
    elseif seq == 2
        args = {args{:} 'sequence'};
    end
end
if DATA.plot.showcp == 1
    args = {args{:} 'cpt'};
elseif DATA.plot.showcp == 2
    args = {args{:} 'cp'};
elseif DATA.plot.showcp == 3
    args = {args{:} 'cphist'};
elseif DATA.plot.showcp == 4
    args = {args{:} 'cpt' 'emdiff' DATA.em 'emskip' DATA.plot.emskip};
end

if DATA.plot.showem
    args = {args{:} 'eyem'};
end
if DATA.plot.addhash
    args = {args{:} 'showmu'};
end

if DATA.plot.condenseRC
    args = {args{:} 'condense'};
end

if DATA.state.uselfp
    args = {args{:} 'lfpt'};
end

if DATA.plot.nminrc > 0
    args = {args{:} 'rcnmin' DATA.plot.nminrc};
end
if DATA.plot.nmin > 0
    args = {args{:} 'nmin' DATA.plot.nmin};
end
if DATA.plot.sdfw > 0 
    args = {args{:} 'sdfw' DATA.plot.sdfw};
end

if ~DATA.plot.condenseRC && Expt.Stimvals.st == 4 && strcmp(Expt.Stimvals.et,'Ol')
        args = {args{:} 'twoslice'};
end

if strfind(Expt.Header.expname,'tfXip')
    args = {args{:} 'sxcx'};
end

if DATA.plot.collapse
    args = {args{:} 'collapse' 2};
end
if DATA.plot.flip
    args = {args{:} 'flip'};
end
if DATA.plot.acov
    args = {args{:} 'acov'};
end
if DATA.plot.plotmod
    args = {args{:} 'mod'};
end

    
function mousept = myellipse(mousept, finish)


%
%
% mousept modes
%  1 draw ellipse
%  2 re-size both dimensions
%  3 rotate
%  4 move ellipse
%  5 change left edge (move center and h radius)
if nargin > 1
    start = mousept.start;
else
    mousept.mode = 4;
end
if mousept.mode == 1
    a = (finish(1,1)-start(1,1))/2;
    b = (finish(2,2)-start(2,2))/2;
    mousept.r = abs([a b]);
    mousept.c = [finish(1,1)+start(1,1) finish(2,2)+start(2,2)]/2;
elseif mousept.mode == 2
    a = (finish(1,1)-mousept.c(1));
    b = (finish(2,2)-mousept.c(2));
    mousept.r = abs([a b]);
elseif mousept.mode == 3
    
    dy = (finish(2,2)-mousept.c(2))./mousept.yrange;
    dx = (finish(1,1)-mousept.c(1))./mousept.xrange;
    t = -dy/dx;
    mousept.angle = atan(-dy/dx);
    a = mousept.r(1);
    b = mousept.r(2);
%   [a,b] = exy(mousept.angle,mousept.r(1),mousept.r(2));
%    fprintf('%.3f %.3f %.3f\n',mousept.angle,a,b);
%    a = (mousept.r(1) * cos(mousept.angle)) + mousept.ratio * mousept.r(1) * sin(mousept.angle)
%    b = (mousept.r(2) * cos(mousept.angle)) - (mousept.r(2) * sin(mousept.angle)/mousept.ratio)
    %b = mousept.r(2);
elseif mousept.mode == 4  %% move ellipse
    a = mousept.r(1);
    b = mousept.r(2);
elseif mousept.mode == 5  %% move ellipse
    a = mousept.r(1);
    b = mousept.r(2);
    mousept.c(1) = finish(1,1)-mousept.offset(1);
    mousept.c(2) = finish(2,2)-mousept.offset(2);
elseif mousept.mode == 6 %% move R boundary
    a = (finish(1,1)-mousept.c(1));
    mousept.c(1) = mousept.c(1) + (a-mousept.r(1))/2;
    mousept.r(1) = abs(finish(1,1) - mousept.c(1));
    b = mousept.r(2);
    a = mousept.r(1);
elseif mousept.mode == 7 %% move L boundary
    a = abs(mousept.c(1) - finish(1,1));
    mousept.c(1) = mousept.c(1) - (a-mousept.r(1))/2;
    mousept.r(1) = abs(finish(1,1) - mousept.c(1));
    b = mousept.r(2);
    a = mousept.r(1);
elseif mousept.mode == 8 %% move Top boundary
    b = (finish(2,2)-mousept.c(2));
    mousept.c(2) = mousept.c(2) + (b-mousept.r(2))/2;
    mousept.r(2) = abs(finish(2,2) - mousept.c(2));
    b = mousept.r(2);
    a = mousept.r(1);
elseif mousept.mode == 9 %% move Bottom boundary
    b = abs(finish(2,2)-mousept.c(2));
    mousept.c(2) = mousept.c(2) - (b-mousept.r(2))/2;
    mousept.r(2) = abs(finish(2,2) - mousept.c(2));
    b = mousept.r(2);
    a = mousept.r(1);

else
    a = mousept.r(1);
    b = mousept.r(2);
end

a = a./mousept.xrange;
b = b./mousept.yrange;
sn = sin(mousept.angle);
cn = cos(mousept.angle);
%sn = sin(pi/4);
%cn = cos(pi/4);
x = linspace(0,a);
y =  sqrt(b.^2 - (x.*b/a).^2);
x = [x fliplr(x) -x fliplr(-x)];
y = [y fliplr(-y) -y fliplr(y)];
xr = mousept.xrange .* (x .* cn + y .*sn) + mousept.c(1);
yr = mousept.yrange .* (y .* cn - x .*sn) + mousept.c(2);
mousept.lasth = plot(real(xr),real(yr),'color',mousept.color);

function KeyPressed(a, ks)
global mousept;

get(a);
mousept.mode;
if strmatch(ks.Key,'delete') & mousept.mode == 5
    DeleteCluster(mousept.cluster, a);
elseif ks.Key == 'n'
    NewCluster(a);
end

function NewCluster(a)
DATA = GetDataFromFig(a);
j = size(DATA.cluster,1);
while isempty(DATA.cluster{j,DATA.probe}) & j > 1
    j = j-1;
end
newc = j+1;
it = findobj('Tag','Clusterid');
set(it,'value',newc);

function DeleteCluster(cl,callfig)
DATA = GetDataFromFig(callfig);

p = get(gca,'UserData');
if isempty(p)
p = DATA.probe;
end
if ~isempty(DATA.cluster{cl,p}) & isfield(DATA.cluster{cl,p},'h') &  ishandle(DATA.cluster{cl,p}.h)
    delete(DATA.cluster{cl,p}.h);
end
DATA.cluster{cl,p} = [];
DATA.cluster{cl,p}.touched = 1; %records active deletion. Will be copied to Expt
if isfield(DATA.Expts{DATA.currentexpt}.gui,'spkrange')
    ispk = DATA.Expts{DATA.currentexpt}.gui.spkrange;
    ispk = [ispk(1):ispk(2)];
    if isfield(DATA,'AllSpikes')
    spks = find(DATA.AllSpikes{DATA.probe}.codes(ispk,2) == cl);
    DATA.AllSpikes{DATA.probe}.codes(ispk(spks),2) = 0;
    else
    spks = find(DATA.AllData.Spikes.codes(ispk,2) == cl);
    DATA.AllData.Spikes.codes(ispk(spks),2) = 0;
    end
    PlotSpikeXY(DATA,ispk(spks),DATA.spkcolor{1});
% Shouldn't need this. not deleting all clusters. And if we were would
% imply that we are setting not clusters
% DATA.Expts{DATA.currentexpt}.gui.classified = 0;
end
set(DATA.toplevel,'UserData',DATA);
if cl > 1
    newc = cl-1;
elseif size(DATA.cluster,1) > cl & ~isempty(DATA.cluster{cl+1,DATA.probe})
    newc = cl+1
else
    newc = 1;
end
it = findobj('Tag','Clusterid');
set(it,'value',newc);

function FigButtonReleased(src, data)
global mousept;
mousept.mode = strmatch(get(gcf,'SelectionType'),{'normal' 'alternate'  'extend'  'open'});
mousept.down = 0;
mousept.lasth = 0;
DATA = GetDataFromFig(src);
ExcludeTrials(DATA, mousept);

function ExcludeTrials(DATA, mousept)
    if DATA.state.plotseq == 2
        id = find([DATA.Expt.Trials.Trial] > mousept.start(1,1) & ...
            [DATA.Expt.Trials.Trial] < mousept.finish(1,1));
        ex = [DATA.Expt.Trials(id).Trial];
        if isfield(DATA.Expt,'ExcludeCluster')
            DATA.Expt.ExcludeCluster{1} = union(DATA.Expt.ExcludeCluster{1}, ex);
        else
            DATA.Expt.ExcludeCluster{1} = ex;
        end
    end

        
    hold off;    
    DATA.Expt = PlotCombined(DATA, DATA.Expt);
    set(DATA.toplevel,'UserData',DATA);

function mousept = myrect(mousept, finish)
    start = mousept.start;
    mousept.finish = finish;
    mousept.siz = finish-start;
    if mousept.mode == 1 % horizontal line
        mousept.lasth = plot([start(1,1) finish(1,1)],[start(2,2) start(2,2)],'r');
    else
        mousept.lasth = plot([start(1,1) finish(1,1)],[start(2,2) finish(2,2)],'r');
    end

function FigButtonPressed(src, data)
global mousept;
set(src, 'WindowButtonMotionFcn',@@FigButtonDragged);

mousept.mode = strmatch(get(gcf,'SelectionType'),{'normal' 'alternate'  'extend'  'open'});
mousept.down = 1;
mousept.lasth = 0;
mousept.drags = 0;
hold on; %othewise drawing ellipse deletes data
if mousept.mode == 1
    mousept.start = get(gca,'CurrentPoint');
end
mousept.l = mousept.start;
mousept.siz = [0 0];

function FigButtonDragged(src, data)
global mousept;

if mousept.down
    pt = get(gca,'CurrentPoint');
    if mousept.lasth & ishandle(mousept.lasth)
        delete(mousept.lasth);
    end
    mousept= myrect(mousept,pt);
%   plot(pt(1,1),pt(2,2),'+');
    mousept.drags = mousept.drags+1;
end

function ButtonPressed(src, data)
global mousept;

DATA = GetDataFromFig(src);

it = findobj('Tag','Clusterid');
if ~isempty(it)
    mousept.cluster = get(it,'value');
else
    mousept.cluster = 1;
end

mousept.drags = 0;

mousept.color = DATA.spkcolor{mousept.cluster+1};
mousept.lasth = 0;
lastkey = get(gcf,'CurrentCharacter');

% don't want the axis rescaling as we draw the ellipse
set(gca,'Xlimmode','Manual','Ylimmode','Manual');

oldmode = mousept.mode;
mousept.mode = strmatch(get(gcf,'SelectionType'),{'normal' 'alternate'  'extend'  'open'});
mousept.down = 1;
p = get(gca,'UserData');
mousept.xrange = diff(get(gca,'Xlim'));
mousept.yrange = diff(get(gca,'Ylim'));

if isempty(p)
p = DATA.probe;
end
if mousept.cluster <= size(DATA.cluster,1) && p <= size(DATA.cluster,2)
    C = DATA.cluster{mousept.cluster,p};
else
    C.h = 0;
end
mousept;
hold on; %othewise drawing ellipse deletes data
if mousept.mode == 1
    mousept.start = get(gca,'CurrentPoint');

    if size(DATA.cluster,1) >= mousept.cluster & size(DATA.cluster,2) >= p &...
            isfield(DATA.cluster{mousept.cluster,p},'h')
        for j = 1:size(DATA.cluster,1)
            distance(j) = DistanceToCluster(DATA.cluster{j,p},mousept.start(1,1:2));
        end
        if(min(distance) > 1.05) % pressed outside = start over
            if ishandle(C.h)
            delete(C.h);
            end
        else  %% pressed inside; select this cluster, move if mouse moves
            [d, cl]= min(distance);
           mousept.cluster = cl;
            C = DATA.cluster{cl,p};
            if ~isempty(it)
                set(it,'value',cl);
            end
            DATA.cluster{cl,p}.h = DrawCluster(DATA.cluster{cl,p}, DATA.spkcolor{cl+1});
            mousept.mode = 5;
            mousept.c = [DATA.cluster{cl,p}.x(1) DATA.cluster{cl,p}.y(1)];
            mousept.r = [DATA.cluster{cl,p}.x(2) DATA.cluster{cl,p}.y(2)];
            DATA.cluster{cl,p}.touched = 1;
            mousept.offset = mousept.start(1,1:2) - mousept.c;
            set(DATA.cluster{cl,p}.h,'linewidth',2);
            if oldmode == 5 %second press in ellipse - move it
                mousept.down = 1;
                mousept.lasth = DATA.cluster{cl,p}.h;
            else
                mousept.down = 0;  %%ignore drag, release
            end
            set(DATA.toplevel,'UserData',DATA);
        end
    else
        p
    end
elseif mousept.mode == 2 %R button
     if isfield(C,'h') & C.h & ishandle(C.h) 
         delete(C.h); 
     end
     cl = mousept.cluster;
     mousept.c = [DATA.cluster{cl,p}.x(1) DATA.cluster{cl,p}.y(1)];
     mousept.r = [DATA.cluster{cl,p}.x(2) DATA.cluster{cl,p}.y(2)];
    mousept.start = get(gca,'CurrentPoint');
     if mousept.start(1,1) > mousept.c(1) + mousept.r(1)
         mousept.mode = 6;
     elseif mousept.start(1,1) < mousept.c(1) - mousept.r(1)
         mousept.mode = 7;
     elseif mousept.start(2,2) > mousept.c(2) + mousept.r(2)
         mousept.mode = 8;
     elseif mousept.start(2,2) < mousept.c(2) - mousept.r(2)
         mousept.mode = 9;
     end
     fprintf('Start %.2f,%.2f C %.2f,%.2f, R%.2f %.2f, mode %d\n',...
         mousept.start(1,1),mousept.start(2,2),mousept.c(1),mousept.c(2),mousept.r(1),mousept.r(2),mousept.mode);
elseif mousept.mode == 3 % R button
     if ishandle(C.h) delete(C.h); end

end


function distance = DistanceToCluster(C, pos);
   
if isempty(C) | ~isfield(C,'x');
    distance = NaN;
    return;
end
xy = pos - [C.x(1) C.y(1)];
xy = xy ./ [C.x(3) C.y(3)];
cn = cos(-C.angle);
sn = sin(-C.angle);
p(1) = xy(1) * cn + xy(2) * sn;
p(2) = xy(2) * cn - xy(1) * sn;

distance = p./[C.x(2)./C.x(3) C.y(2)./C.y(3)];
distance = sum(distance.^2);

function PlotSpikeXY(DATA, spkid, color)
plot(DATA.Spikes.cx(spkid),DATA.Spikes.cy(spkid),'.',...
    'color',color,'markersize',DATA.ptsize);

function ClassifySpikes(mousept,src,varargin)

DATA = GetDataFromFig(src);
cl = mousept.cluster;
p = get(gca,'UserData');
if isempty(p)
p = DATA.probe;
end

DATA.currentcluster = cl;
C.x = [mousept.c(1) mousept.r(1) mousept.xrange];
if C.x(2) == 0 & isfield(DATA.cluster{cl,p},'x')
    C.x(2) = DATA.cluster{cl,p}.x(2);
end
C.y = [mousept.c(2) mousept.r(2) mousept.yrange];
if C.y(2) == 0 & isfield(DATA.cluster{cl,p},'y')
    C.y(2) = DATA.cluster{cl,p}.y(2);
end
C.angle = -mousept.angle;
C.h = mousept.lasth;
C.params = [DATA.plot.clusterX DATA.plot.clusterY];
C.Arange = DATA.clusterArange;
C.Brange = DATA.clusterBrange;
C.Erange = DATA.clusterErange;


if isfield(DATA,'AllClusters')
   expspks = DATA.AllClusters(p).spklist;
elseif isfield(DATA,'AllSpikes') & isfield(DATA.AllSpikes{p},'spklist')
   expspks = DATA.AllSpikes{p}.spklist;
elseif isfield(DATA,'spklist') && ~isempty(DATA.spklist)
   expspks = DATA.spklist;
else
    expspks = DATA.spkrange(1):DATA.spkrange(2);
end
C.firstspk = expspks(1);
C.lastspk = expspks(end);
if DATA.currenttrial > 1
    DATA.cluster{cl,p}.Cluster = C;
    DATA.cluster{cl,p}.lastspk = C.firstspk-1;
else
    DATA.cluster{cl,p} = C;
end
DATA.cluster{cl,p}.touched = 1;
DATA.newcluster(mousept.cluster) = 1;
%mousept.lasth
colors = mycolors;

if mousept.mode ~= 5   || strcmp(get(src,'tag'),'AllProbeSpikes')
[DATA, dprime, nc] = SetSpkCodes(DATA,expspks,p,2);
if length(nc) > 1
    fprintf('%s: %d Clusters for Probe %d\n',DATA.explabels{DATA.currentexpt},length(nc),p);
end
end
DATA.state.recut = 1;
SetGui(DATA);
if isfield(DATA,'AllClusters')
id = find(DATA.AllClusters(p).codes(expspks) == 0);
elseif isfield(DATA,'AllSpikes')
id = find(DATA.AllSpikes{p}.codes(expspks,2) == 0);
else
id = find(DATA.AllData.Spikes.codes(expspks,2) == 0);
end
if ~DATA.densityplot
% done by SetSpkCodes 
%    PlotSpikeXY(DATA, expspks(id), DATA.spkcolor{1});
end
if DATA.state.autoplot
    DATA = CountSpikes(DATA, DATA.currentexpt,'replot');
else
    DATA = CountSpikes(DATA, DATA.currentexpt);
end
DATA.Expts{DATA.currentexpt}.gui.classified = 2;

p = get(gca,'UserData');
if isempty(p)
DATA.Expts{DATA.currentexpt}.Cluster = DATA.cluster;
end
if DATA.plot.showISI
    GetFigure('ISI');
    isis = CalcISI(DATA.Expts{DATA.currentexpt}.Trials);
    id = find(isis < 1000)
    hist(isis(id),100);
end

set(DATA.toplevel,'UserData',DATA);

function dp = CalcClusterdp(DATA, cl)
    expspks = DATA.Expts{DATA.currentexpt}.gui.spks;
    if length(expspks) < 10
        dp = 0;
        return;
    end
    if isfield(DATA,'AllSpikes')
        id = find(DATA.AllSpikes{DATA.probe}.codes(expspks,2) == cl-1);
        nid = find(DATA.AllSpikes{DATA.probe}.codes(expspks,2) ~= cl-1);
    else
    id = find(DATA.AllData.Spikes.codes(expspks,2) == cl-1);
    nid = find(DATA.AllData.Spikes.codes(expspks,2) ~= cl-1);
    end
    rx = std(DATA.Spikes.cx(expspks(id)));
    cx = mean(DATA.Spikes.cx(expspks(id)));
    ry = std(DATA.Spikes.cy(expspks(id)));
    cy = mean(DATA.Spikes.cy(expspks(id)));
    dx = DATA.Spikes.cx(expspks(id))- mean(DATA.Spikes.cx(expspks(id)));
    dy = DATA.Spikes.cy(expspks(id))- mean(DATA.Spikes.cy(expspks(id)));
    dc = abs(dx+i*dy);
    dx = DATA.Spikes.cx(expspks)- mean(DATA.Spikes.cx(expspks(id)));
    dy = DATA.Spikes.cy(expspks)- mean(DATA.Spikes.cy(expspks(id)));
    d = abs(dx+i*dy);
    [s, did] = sort(d);
    dc = d;
    dc(id) = 0;
    d(nid) = 0;
% need to order these somehow first before doing fpos/drate
% ? rank order d before setting id, nid to zero.

%detection rate
    drate = cumsum(dc(did)) ./ sum(dc);
%false positive rate
fpos = cumsum(d(did)) ./ sum(d);
%area gives ROC
dp = trapz(fpos,drate);


function DATA = DrawXYPlot(DATA, expspks)
    
    ho = ishold;
    if ~isfield(DATA,'nclusters')
        DATA.nclusters = 0;
    end
    if DATA.state.recut
        ctype = 2;
    else
        ctype = 1;
    end
    if ~isfield(DATA,'ptsize')
        DATA.ptsize = 1;
    end
    if isfield(DATA,'AllSpikes')
    expspks = DATA.Expts{DATA.currentexpt}.gui.spks;
    if ~isfield(DATA,'nclusters')
        DATA.nclusters = 0;
    end
    for j = 1:DATA.nclusters+1
        id = find(DATA.AllSpikes{DATA.probe}.codes(expspks,ctype) == j-1);
        PlotSpikeXY(DATA, expspks(id), DATA.spkcolor{j});
        hold on;
    end
    else
    expspks = DATA.Expts{DATA.currentexpt}.gui.spks;
    for j = 1:DATA.nclusters+1
        id = find(DATA.AllData.Spikes.codes(expspks,ctype) == j-1);
        PlotSpikeXY(DATA, expspks(id), DATA.spkcolor{j});
        hold on;
    end
    end
    hold on;
    DATA = DrawClusters(DATA, DATA.cluster, 0);
        CalcClusterdp(DATA,1);
    FinishXYPlot(DATA);
    if ~ho
        hold off;
    end
    
function PlotDDF(DATA)
    cspks = DATA.Expts{DATA.currentexpt}.gui.spks;
    plottype = 0;
    nclusters = size(DATA.cluster,1);
    p = DATA.probe;
    for cl = nclusters:-1:1
        id = find(DATA.AllData.Spikes.codes(cspks,2) == cl);
        nid = find(DATA.AllData.Spikes.codes(cspks,2) ~= cl);
        sx = std(DATA.Spikes.cx(cspks(id)));
        sy = std(DATA.Spikes.cy(cspks(id)));
        mx = mean(DATA.Spikes.cx(cspks(id)));
        my = mean(DATA.Spikes.cy(cspks(id)));
        if p <= size(DATA.cluster,2)
        C = DATA.cluster{cl,p};
        x = (DATA.Spikes.cx(cspks) - mx)./sx;
        y = (DATA.Spikes.cy(cspks) - my)./sy;
        xr = x .* cos(C.angle) + y .* sin(C.angle);
        yr = y .* cos(C.angle) - x .* sin(C.angle);
        d = sqrt(((yr.^2 + xr.^2)));
        dprime = (mean(d(id)) - mean(d(nid)))./sqrt(mean([var(d(id)) var(d(nid))]));
        x = (DATA.Spikes.cx(cspks) - C.x(1))./C.x(2);
        y = (DATA.Spikes.cy(cspks) - C.y(1))./C.y(2);
        ddf = sqrt((y).^2 + (x).^2);
        GetFigure('DDF');
        if plottype == 1
        hold off;
        plot(xr(id),yr(id),'r.');
        hold on;
       plot(xr(nid),yr(nid),'.');
       axis('image');
        elseif plottype == 2
       hist(ddf,500);
        else
            hold off;
        [y,x] = smhist(ddf,'sd',0.1,'xval',[0:0.1:10]);
        plot(x,y);
        hold on;
        [y,x] = smhist(ddf(id),'sd',0.1,'xval',[0:0.1:10]);
        plot(x,y,'r');
        ddfprime = (mean(ddf(id)) - mean(ddf(nid)))./sqrt(mean([var(ddf(id))  var(ddf(nid))]));

        x = (DATA.Spikes.cx(cspks) - C.x(1))./C.x(3);
        y = (DATA.Spikes.cy(cspks) - C.y(1))./C.y(3);
        xr = x .* cos(C.angle) + y .* sin(C.angle);
        yr = y .* cos(C.angle) - x .* sin(C.angle);
        ddf = (yr./C.y(2)*C.y(3)).^2 + (xr./C.x(2)*C.x(3)).^2;
        drprime = (mean(ddf(id)) - mean(ddf(nid)))./sqrt(mean([var(ddf(id))  var(ddf(nid))]));
        
        [y,x] = smhist(d,'sd',0.1,'xval',[0:0.1:10]);
        plot(x,y,':');
        hold on;
        [y,x] = smhist(d(id),'sd',0.1,'xval',[0:0.1:10]);
        plot(x,y,'r:');
        end
        title(sprintf('D = %.4f (%.4f,%.4f)',-dprime,-drprime,-ddfprime))
        id = cspks(find(d < 1));
        ddf = (yr./C.y(2)*C.y(3)).^2 + (xr./C.x(2)*C.x(3)).^2;
        end
    end
        
function FinishXYPlot(DATA)
    if DATA.plot.autoscale == 0
        set(gca,'Xlim',DATA.plot.clusterXrange,'Ylim',DATA.plot.clusterYrange);
    end
    xlabel(DATA.spkvarnames{DATA.plot.clusterX});
    ylabel(DATA.spkvarnames{DATA.plot.clusterY});
    it = findobj(DATA.xyfig, 'Tag','Clusterid');
    if isempty(it)
        c = 1;
    else
        c = get(it,'value');
    end
    if ~isempty(DATA.explabels{DATA.currentexpt})
        expname = DATA.explabels{DATA.currentexpt};
        expname = DATA.Expts{DATA.currentexpt}.Header.expname;
     else
        expname = DATA.Expts{DATA.currentexpt}.Header.expname;
    end
    if DATA.currenttrial > 1
        expname = [expname sprintf('from %d',DATA.Expts{DATA.currentexpt}.Trials(DATA.currenttrial).Trial)];
    end
    p = DATA.probe;
    str = '';
 
    if isfield(DATA,'cluster') & iscluster(DATA.cluster,c,p)
        if isfield(DATA.cluster{c,p},'dprime')
            str = sprintf('d=%.2f',DATA.cluster{c,p}.dprime);
        end
       
    title(sprintf('%s: C%d %sX%s %s Probe%d',expname,c,DATA.spkvarnames{DATA.cluster{c,p}.params(1)},DATA.spkvarnames{DATA.cluster{c,p}.params(2)},str,DATA.probe)); 
    else
    title(sprintf('%s: C%d',expname,c)); 
    end

function res = iscluster(C,c,p)
    if isempty(C) | size(C,1) < c | size(C,2) < p | isempty(C{c,p})
        res = 0;
    elseif ~isfield(C{c,p},'params') | ~isfield(C{c,p},'x')
        res = 0;
    else
        res = 1;
    end

function [DATA, dprime, details] = SetSpkCodes(DATA, expspks, probe, show)

dprime = 0;
details.nc = 0;
if isfield(DATA,'AllClusters')
  DATA.AllClusters(probe).codes(expspks) = 0;
  Cx = DATA.AllClusters(probe).cx;
  Cy = DATA.AllClusters(probe).cy;
elseif isfield(DATA,'AllSpikes')
  DATA.AllSpikes{probe}.codes(expspks,2) = 0;
  if isfield(DATA.AllSpikes{probe},'cx')
      Cx = DATA.AllSpikes{probe}.cx;
      Cy = DATA.AllSpikes{probe}.cy;
  else
      Cx = DATA.Spikes.cx;
      Cy = DATA.Spikes.cy;
  end
elseif isfield(DATA,'Spikes')
  Cx = DATA.Spikes.cx;
  Cy = DATA.Spikes.cy;
    DATA.AllData.Spikes.codes(expspks,2) = 0;
else
    return; % No spikes
end

%
%really want to limit this to spike in the current scope;id = find(DATA.Spks.cluster == 0);

if ~isfield(DATA,'cluster')
 nclusters = 0;
 DATA.cluster = {};
end
nclusters = size(DATA.cluster,1);
p = probe;
if nclusters >1
%    fprintf('%s: %d Clusters for Probe %d\n',DATA.explabels{DATA.currentexpt},nclusters,p);
end
sumplot = 0;
details.maxx = max(Cx(expspks));
details.maxy = max(Cy(expspks));
for cl = nclusters:-1:1
    cspks = expspks;
    nspk = 0;
    if p > size(DATA.cluster,2)
        C = [];
    else
        C = DATA.cluster{cl,p};
    end
    if isfield(C,'Cluster') && ~isempty(C.Cluster) 
        splitlist = 1;
    else
        splitlist = 0;
    end
    while ~isempty(C) & isfield(C,'x')
        if ~isfield(C,'lastspk')  & ~isempty(DATA.spklist)
            C.lastspk = DATA.spklist(end);
        end
        if ~isfield(C,'firstspk') & ~isempty(DATA.spklist)
            C.firstspk = DATA.spklist(1);
        elseif isfield(C,'firstspk') & C.firstspk > 0 & splitlist
            cspks = expspks(find(expspks >= C.firstspk & expspks <= C.lastspk));
        end
    x = (Cx(cspks) - C.x(1))./C.x(3);
    y = (Cy(cspks) - C.y(1))./C.y(3);
    xr = x .* cos(C.angle) + y .* sin(C.angle);
    yr = y .* cos(C.angle) - x .* sin(C.angle);
    d = (yr./C.y(2)*C.y(3)).^2 + (xr./C.x(2)*C.x(3)).^2;
    id = find(d <= 1);
    nid = find(d > 1);
    nspk = nspk + length(id);
    dprime = (mean(d(nid))-mean(d(id)))./sqrt(mean([var(d(nid)) var(d(id))]));
    tic;
    if length(nid) > 10000
        pcrit = 1;
    elseif length(nid) > 1000
        pcrit = 10;
    elseif length(nid) > 200
        pcrit = 20;
    else
        pcrit = 50;
    end
    %    sy = ((yr-mean(yr(id)))./std(yr(id)));
%    sx = ((xr-mean(xr(id)))./std(xr(id)));
    sy = ((yr-mean(yr(id)))./std(yr));
    sx = ((xr-mean(xr(id)))./std(xr));
    sd = abs(sx+i*sy);
    o = [0:pi/40:pi];
    for j = 1:length(o)
        d = sx .* cos(o(j)) + sy.* sin(o(j));
        a = prctile(abs(d(nid)),pcrit);
        tid = find(abs(d(nid))< a);
        ds{j} = d;
%
%        dprimes(j) = abs(mean(d(nid(tid)))-mean(d(id)))./sqrt(mean([var(d(nid(tid))) var(d(id))]));
         dprimes(j) = abs(mean(d(nid))-mean(d(id)))./sqrt(mean([var(d(nid)) var(d(id))]));
%        dprimes(j) = abs(mean(d(nid))-mean(d(id)))./std(d(nid));
    end
    [dprime, maxi] = max(dprimes);
    details.truedprime = abs(mean(d(nid))-mean(d(id)))./sqrt(mean([var(d(nid)) var(d(id))]));
    debug = 0;
    if debug
        [a,b] = smhist(ds{maxi}(id),'sd',0.1);
        [c,d] = smhist(ds{maxi},'sd',0.1);
        [e,f] = smhist(ds{maxi}(tid),'sd',0.1);
        of = gcf;
        GetFigure('DDF');
        hold off;
        plot(b,a);
        hold on;
        plot(d,c,'r');
        plot(f,e,'g');
        title(sprintf('Spks %d/%d/%d',length(ds{maxi}),length(id),length(tid)));
        figure(of);
    end
    details.nc(cl) = length(id);

    if isfield(DATA,'AllClusters')
        DATA.AllClusters(probe).codes(cspks(id)) = cl;
    elseif isfield(DATA,'AllSpikes')
        DATA.AllSpikes{probe}.codes(cspks(id),2) = cl;
    else
        DATA.AllData.Spikes.codes(cspks(id),2) = cl;
    end
    DATA.cluster{cl,p}.dprime = dprime;
    if isfield(C,'Cluster')
        C = C.Cluster;
    else
        C = {};
    end
    if ~DATA.densityplot & show
        if ~isfield(DATA,'ptsize')
            DATA.ptsize = 1;
        end
        plot(Cx(cspks(id)),Cy(cspks(id)),'.',...
            'color',DATA.spkcolor{cl+1},'markersize',DATA.ptsize);
        sumplot = sumplot + length(id);
        if sumplot
            hold on;
        end
        if isfield(DATA,'explabels')
    title(sprintf('%s dprime %.2f %d/%dspks',DATA.explabels{DATA.currentexpt},dprime,length(id),length(cspks))); 
        end
    end
    end
    DATA.cluster{cl,p}.nspk = nspk;
end
    if ~DATA.densityplot & show > 1 %show unclassified also
    if isfield(DATA,'AllClusters')
        id = DATA.AllClusters(probe).codes(cspks) == 0;
    elseif isfield(DATA,'AllSpikes')
        id = DATA.AllSpikes{probe}.codes(cspks,2) == 0;
    else
        id = DATA.AllData.Spikes.codes(cspks,2) == 0;
    end
        id = cspks((find(id)));
        plot(Cx(id),Cy(id),'.','color',DATA.spkcolor{1},'markersize',DATA.ptsize);
        hold on;

    end


function ButtonReleased(src, data)
global mousept;

%mousept
if mousept.down == 0 %do nothing
   % delete(mousept.lasth);
   % mousept.lasth = 0;
% Even if touching a cluster in AllProbeSpikes may need to
% classify the spikes. Will not have happened during spooling.
   if ~strcmp(get(src,'tag'),'AllProbeSpikes')
    return;
   end
end
mousept.down = 0;
pt = get(gca,'CurrentPoint');
    if mousept.lasth & ishandle(mousept.lasth)
        delete(mousept.lasth);
    end
  mousept= myellipse(mousept,pt);
  ClassifySpikes(mousept, src);
  if mousept.mode == 5
      set(mousept.lasth,'linewidth',2);
  end
%mousept.drags

function ButtonDragged(src, data)

global mousept;

if mousept.down
    pt = get(gca,'CurrentPoint');
    if mousept.lasth && ishandle(mousept.lasth)
        delete(mousept.lasth);
    end
    mousept= myellipse(mousept,pt);
%    plot(pt(1,1),pt(2,2),'+');
    mousept.drags = mousept.drags+1;
end


function Expts = CheckSaccades(Expts, emfile)

load(emfile);
saccth = 10;

for j = 1:length(Expts)
    crate = Expt.Header.CRrates(1) * 10000;
    for k = 1:length(Expts{j}.Trials)
        if strfind(Expts{j}.Trials(k).OptionCode,'+2a')
            bs = Expts{j}.Trials(k).TrialStart;
            es = Expts{j}.Trials(k).End(end);
            [tdiff, emt] = min(abs([Expt.Trials.Start] - bs));
            if tdiff < 160
                maxi = min([length(Expt.Trials(emt).lh) length(Expt.Trials(emt).rh) length(Expt.Trials(emt).lv) length(Expt.Trials(emt).rv)]);
                ch = (Expt.Trials(emt).lh(1:maxi)+Expt.Trials(emt).rh(1:maxi))/2;
                cv = (Expt.Trials(emt).lv(1:maxi)+Expt.Trials(emt).rv(1:maxi))/2;
                dv = smooth(diff(cv),5);
                dh = smooth(diff(ch),5);
                v = 10000 * sqrt(dv.^2+dh.^2)./crate;
                first = (bs -Expt.Trials(emt).ftime)/crate;
                last =  (es -Expt.Trials(emt).ftime)/crate;
                times = ftime + [1:length(cv)] .*crate;
                saccs = find(v > 10);
                id = find(saccs > last);
                if ~isempty(id)
                    [rate, pk] = max(v(saccs(id)));
                    pk = id(pk);
                    sv(1) = mean(cv(first:saccs(pk)-10));
                    sv(2) = mean(cv(saccs(pk)+10:end));
                    sh(1) = mean(ch(first:saccs(pk)-10));
                    sh(2) = mean(ch(saccs(pk)+10:end));
                    saccsize = abs(diff(sh) + i* diff(sv));
                    sacdir = atan2(diff(sv),diff(sh));
                end
            end
        end
    end
end


function name = BuildName(name)

if isempty([strfind(name,'/') strfind(name,'\')])
    name = [pwd '/' name];
end
id = strfind(name,':');
if id
    if isunix
        name = ['/bgc' name(id(1)+1:end)];
        name = strrep(name,'\','/');
    else
        name = name(id(1)+1:end);
    end
else
    name = name;
end


function [aid, bid, n] = FindSync(at,bt,dt,varargin)
%from two lists of times, find events synchronous witthin dt
n = 0;
k = 1;
aid = [];
bid = [];
if isempty(at) || isempty(bt)
    return;
end
if length(bt) < 101
    bts = [1:length(bt)];
else
    bts = [1:101];
end
nb = length(bt);
for j = 1:length(at)
    t = bt(bts)-at(j);
    while(t(end) < 0 & bts(end) < nb)
        if bts(end)+100 > nb
            bts = bts(end):nb;
        else
            bts = bts+100;
        end
        t = bt(bts)-at(j);
    end
    [a,b] = min(abs(t));
    if a <= dt
        n = n+1;
        aid(n) = j;
        bid(n) = bts(b);
    end
end

function [E,V, pc] = SpikePCA(spk, probes, ids)

if length(probes) == 2
    spks = [spk{probes(1)}.values(ids{1},:) spk{probes(2)}.values(ids{2},:)];
         [E,V] = eig(cov(spks));
        pc(1,:) = (E(:,end)'-mean(E(:,end))) * spks';
        pc(2,:) = (E(:,end-1)'-mean(E(:,end-1))) * spks';
        pc(3,:) = (E(1:32,end)'-mean(E(1:32,end-1))) * spks(:,1:32)';
        pc(4,:) = (E(33:end,end)'-mean(E(33:end,end-1))) * spks(:,33:end)';
        pc(5,:) = (E(1:32,end-1)'-mean(E(1:32,end-1))) * spks(:,1:32)';
        pc(6,:) = (E(33:end,end-1)'-mean(E(33:end,end-1))) * spks(:,33:end)';
end
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
    'OpXip' 'PpXip' 'me' 'OlXOr' 'ce'};
d41 1
a41 1
    'OD' 'OPIP' 'PPIP' 'OD' 'BOP' 'CE'};
d65 1
d135 1
d658 1
d661 9
d826 3
a828 1
               DATA.state.includeprobename = 1;
d1951 5
a1955 1
    DATA.autocut = 1;
d1966 1
a1966 1
                | isempty(Clusters{nb}{1,DATA.probe}) | ~isfield(Clusters{nb}{1,DATA.probe},'x'))
d1970 2
d2057 5
a2061 1
    PlotCombined(DATA, Expt);
d2064 2
a2065 1
    
d2074 1
a2074 1
 if ismember(DATA.plot.showcp,[5 6])
d2080 1
a2080 1
     GetFigure('Psych');
d2082 1
a2082 1
     if DATA.plot.showcp == 5
d3276 1
d3280 1
a3280 1
    
d6287 4
a6304 1
set(DATA.toplevel,'UserData',DATA);
d6306 2
a6307 1
function cntrl_box = setshow(DATA, tag)
d6477 2
d6510 1
a6510 1
 uicontrol(gcf,'Style', 'pop','String','Centiles|By Density|Test','Position', bp,...
a7003 1
DATA.plot.xcorr = GetCheck('ShowxCorr');
a7013 1
DATA.plot.autoclustermode = get(findobj(DATA.toplevel,'Tag','AutoCutMode'),'value')-1;
d7024 1
a7024 1
id = regexp(DATA.outname,'.c[0-9].');
d7031 1
d7048 2
d7055 1
d7160 3
d7195 3
@
