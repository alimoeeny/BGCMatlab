function [xc, details] = ShapeCorr(P,Q, varargin)%xc = ShapeCorr(P,Q, varargin) calc cross correlation of spike mean shapes%  .,'delays',x  Checks for differnet time alignements given in x (samples)%  .,'driftts',x  Checks for differnet probe alignements given in x (probes)%%  so if P has a cell that is just like Q, but shifted by one probe, it%  will find that xcorr% ...,'proberange',dp)  limits the calculation of corr to porbes within dp% probes of P.probe. Sometimes things far away can make a mess of a good% correlation.%% 'scatter'  plots a scatterplot of voltage samples% 'plot'  plots both spike waveformstestdelays = 0; %allow for different time allignment +- n samplestestshifts = 0; %allow for different probe allignment +- n probesproberange = [];details.timeshift = 0;details.probeshift = 0;details.amp = NaN;plottype = 'none';probedepths = [];j = 1;while j <= length(varargin)    if isfield(varargin{j},'spacing')        if isfield(varargin{j},'Y')            Array = varargin{j};           probedepths = Array.Y;         end            elseif isfield(varargin{j},'ArrayConfig')        Array = varargin{j}.ArrayConfig;        if isfield(varargin{j},'corrproberange')            proberange = varargin{j}.corrproberange;        end    elseif strncmpi(varargin{j},'delays',6)        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            testdelays = varargin{j};            testdelays = -testdelays:testdelays;        else            testdelays = -5:5;        end    elseif strncmpi(varargin{j},'fixprobe',5) %add shift to eliminate ref probe    elseif strncmpi(varargin{j},'delay',5)            j = j+1;            testdelays = varargin{j}; %set manually    elseif strncmpi(varargin{j},'drifts',5)        if length(varargin) > j && isnumeric(varargin{j+1})            j = j+1;            testshifts = varargin{j};            testshifts = -testshifts:testshifts;        else            testshifts = -5:5;        end    elseif strncmpi(varargin{j},'shift',4) %manually set probe offset        j = j+1;        testshifts = varargin{j};    elseif strncmpi(varargin{j},'plot',4)        plottype = 'lines';    elseif strncmpi(varargin{j},'scatter',8)        plottype = 'scatter';    elseif strncmpi(varargin{j},'proberange',7)        j = j+1;        proberange = varargin{j};    end    j = j+1;endif iscell(P) && iscluster(P) && length(P) > 1    if nargin > 1        varargin = {Q varargin{:}};    end    details = {};    for j = 2:length(P)        [xc(j-1), details{j-1} ] = PC.ShapeCorr(P{1},P{j},varargin{:});    end    if length(P) == 2        details = details{1};    end    return;endif iscell(Q)    details = {};    for j = 1:length(Q)        [xc(j), details{j} ] = PC.ShapeCorr(P,Q{j},varargin{:});    endendif ~isfield(P,'MeanSpike') || ~isfield(Q,'MeanSpike')    xc = NaN;    return;endxcs = [];details.testdelays = testdelays;details.proberange = proberange;spksz = size(P.MeanSpike.ms);p = P.probe(1); %ref probeif isempty(proberange) && ~isempty(probedepths)    proberange = array.GetValue(Array, 'shaperange');end    for k = 1:length(testshifts)        ps = testshifts(k);        if isempty(proberange)            pid = 1:size(P.MeanSpike.ms,1);            if ~isempty(probedepths)                shifty = probedepths+ps;                id = find(shifty >0 & shifty <= max(probedepths)); %hifted probes                qid = id;                pid = find(ismember(probedepths,unique(shifty(qid))));            else                qid = [1:size(P.MeanSpike.ms,1)]+ps;                id = find(qid > 0 & qid < size(P.MeanSpike.ms,1));                qid = qid(id);                pid = pid(id);            end        elseif length(proberange) > 1            pid = proberange;            qid = pid;        else            if ~isempty(probedepths)                epos = Array.X + i .* Array.Y;                qpos = Array.X + i .* (Array.Y-ps);                id = find(abs(epos(p) - epos) <= proberange);                shifty = probedepths(id)+ps;                qid = find(shifty >0 & shifty <= max(probedepths)); %probes for which shift has valid comparison                xid  = find(shifty <0 | shifty > max(probedepths)); %Can't get this                pid = id(qid);                for j = 1:length(pid)                    qid(j) = find(qpos == epos(pid(j)));                end                if length(pid) ~= length(qid)                    shifty = probedepths(id)+ps;                end            else                pid = P.probe(1)-proberange:P.probe(1)+proberange;                qid = pid+ps;                id = find(qid > 0 & qid < spksz(1) & pid > 0 & pid < spksz(1));                qid = qid(id);                pid = pid(id);            end        end        for j = 1:length(testdelays)            ptid = 1:size(P.MeanSpike.ms,2);            qtid = ptid+testdelays(j);            id = find(qtid>0 & qtid <= spksz(2));            qtid = qtid(id);            ptid = ptid(id);            Va{j,k} = P.MeanSpike.ms(pid,ptid);            Vb{j,k} = Q.MeanSpike.ms(qid,qtid);            xc = corrcoef(P.MeanSpike.ms(pid,ptid),Q.MeanSpike.ms(qid,qtid));            if strcmp(plottype,'lines')                plot(P.MeanSpike.ms(pid,ptid)','-');                hold on;                plot(Q.MeanSpike.ms(qid,qtid)','--');            elseif strcmp(plottype,'scatter')                plot(P.MeanSpike.ms(pid,ptid)',Q.MeanSpike.ms(qid,qtid)','.');            end            xcs(j,k) = xc(1,2);            shifts(j,k) = j;        end            end    %now calc with no offsets    if isempty(proberange)        pid = 1:size(P.MeanSpike.ms,1);    else        pid = P.probe(1)-proberange:P.probe(1)+proberange;        pid= pid(pid > 0 & pid < size(P.MeanSpike.ms,1));    end    details.xcs = xcs;    pl = size(P.MeanSpike.ms,2);    ql = size(Q.MeanSpike.ms,2);    if length(P.MeanSpike.ms(:)) == length(Q.MeanSpike.ms(:))        xc = corrcoef(P.MeanSpike.ms(pid,:),Q.MeanSpike.ms(pid,:));        details.Va = P.MeanSpike.ms(pid,:);        details.Vb = Q.MeanSpike.ms(pid,:);    elseif pl > ql %should really match peak or something here.         x = P.MeanSpike.ms(pid,1:ql);        xc = corrcoef(x,Q.MeanSpike.ms(pid,:));    else        x = Q.MeanSpike.ms(pid,1:pl);        xc = corrcoef(P.MeanSpike.ms(pid,:),x);    end            xc = xc(1,2);    details.truexc = xc;    if length(xcs) == 1        xc =xcs;    end        if length(xcs) > 1 && max(xcs(:)) > xc .* 1.01        [xc, a] = max(xcs(:));                [ts,ps] = ind2sub(size(xcs),a);        details.probeshift = testshifts(ps);        details.timeshift = testdelays(ts);         details.Va = Va{ts,ps};        details.Vb = Vb{ts,ps};    end  details.amp = (details.Va(:)' * details.Vb(:)) ./ (details.Va(:)' * details.Va(:));            