function [C, ok] = GetClusterInfo(C, cl, varargin)% [C, ok] = GetClusterInfo(C, cl)% [C, ok] = GetClusterInfo(C, e,p, cl, 'allexpt')% [C, ok] = GetClusterInfo(DATA, [e p])% [C, ok] = GetClusterInfo(DATA, [e p cl])% [C, ok] = GetClusterInfo(DATA, [e p cl],'allexpt')% [C, ok] = GetClusterInfo(C, [e p cl]) C of form Clusters{e}{p}%[C, ok] = GetClusterInfo(C, [e p 1]) Returns C{e}{p} %[C, ok] = GetClusterInfo(C, [e p 0]) returns a cell array with one%              element for each cluster in C%[C, ok] = GetClusterInfo(C, [e p 1], 'addfit' ) adds in fit datagetauto = 0;addclst = 0;addfit = 0;rawmode = 0;returncell = 0; %if 1 always return cell array, even if 1 longloadargs = {};getvalue = '';eid = 0;ArrayConfig = [];j = 1;while j <= length(varargin)    if isfield(varargin{j},'ArrayConfig')        ArrayConfig = varargin{j}.ArrayConfig;            elseif strncmpi(varargin{j},'array',5) %return cell array        returncell = j;    elseif strncmpi(varargin{j},'addfit',6)        addfit =1;    elseif strncmpi(varargin{j},'allexpt',4)        if length(cl) ==3             eid = cl(1);            pid = cl(2);            cl = cl(3);        else            eid = cl;            pid = varargin{1};            cl = varargin{2};        end    elseif strncmpi(varargin{j},'auto',4)        getauto = 1;        loadargs = {loadargs{:} 'auto'};    elseif strncmpi(varargin{j},'clst',4)        addclst = 1;    elseif strncmpi(varargin{j},'ncut',4)        getvalue = 'ncut';    elseif strncmpi(varargin{j},'raw',3)        rawmode = 1;    end    j = j+1;endexptit = 0;if isfield(C,'currentpoint')    DATA = C;    Clusters = PC.CheckClusterLoaded(DATA, cl(1),loadargs{:});    C = PC.GetClusterInfo(Clusters,cl, varargin{:}, DATA);    if addfit        C = PC.AddFits(DATA.toplevel, C);    end    return;elseif iscell(C) && isfield(cl,'p')        for j = 1:length(cl)        rC{j} = PC.GetClusterInfo(C,[cl(j).eid cl(j).p cl(j).cl]);    end    C = rC;    return;elseif iscell(C) && (length(cl) ==3 || size(cl,2) == 3)        if (size(cl,1) > 1  || returncell) && size(cl,2) == 3        if returncell %don't recurse this            varargin = varargin(setdiff(1:length(varargin),returncell));        end        Clusters = C;        clear C;        for j = 1:size(cl,1)            [C{j}, ok(j)] = PC.GetClusterInfo(Clusters,cl(j,:),varargin{:});        end        return;    else        if cl(3) == 0 %get a cell array for each            exptid = cl(1);            if isstruct(C{cl(1)})                topC = C{cl(1)}(cl(2));            else                topC = C{cl(1)}{cl(2)};            end            clear C;            C{1} = topC;            for j = 1:length(topC.next)                if iscluster(topC.next{j})                    C{end+1} = SubCluster(topC,j+1,addclst);                end            end            return;        end        eid = cl(1);        pid = cl(2);        cl = cl(3);    endelseif iscell(C) && size(cl,2) ==2    Clusters = C;    if rem(cl(1,2),1) > 0        clear C;        e = cl(:,1);        pid = floor(cl(:,2));        clid = round(rem(cl(:,2),1).*10);        for j = 1:size(cl,1)            C{j} = PC.GetClusterInfo(Clusters,[e(j) pid(j) clid(j)],varargin{:});        end        return;    elseif length(C) > 1        if iscell(C{cl(1)})            C = C{cl(1)}{cl(2)};        else            C = C{cl(1)}(cl(2));        end        cl = 1;    else        pid = cl(1);        cl = cl(2);        C = C{pid};    endelseif isfigure(C)    DATA = GetDataFromFig(C);    C = PC.GetClusterInfo(DATA, cl, varargin{:});    if addfit        C = PC.AddFits(DATA.toplevel, C);    end    return;endok = 1; %defaultif eid %expect a Cell array of Cellarrays, don't force load    if length(C) < eid || isempty(C{eid})        expids = CellToMat(C,'exptid');        probes = CellToMat(C,'probe');        id = find(expids == eid & probes == pid);        if isempty(id)            ok = 0;            return;        else            ok = 2;            C = C{id};        end    elseif length(C{eid}) < pid %applies to structs and cells        ok = 0;        return;    end    if ok == 2 %already set    elseif isstruct(C{eid})        C = C{eid}(pid);    else        C = C{eid}{pid};    end    if isempty(C)        ok = 0;        return;    endend  ok = 1;  if rawmode      return;  end  topC =C;  if cl > 1 && cl ~= C.cluster %if call with C.next{}, already correct      topC = C;      [C, ok] = SubCluster(topC,cl,addclst);  end  if ~isempty(C)      if ~isfield(C,'ncut')          if isfield(topC,'clst')          C.ncut = sum(topC.clst == C.cluster+1);          elseif isfield(C,'times')              C.ncut = length(C.times);          else              C.ncut = 0;          end      end  end  if isfield(C,'ncut') && isfield(topC,'duration')      C.rate = C.ncut./topC.duration;  end  if ~isfield(C,'mahal')      ok = 0;  end      if ~isfield(C,'times')  && ~isfield(C,'t')    C.times = [];elseif isfield(ArrayConfig,'idstr')    C.array = strrep(ArrayConfig.idstr,'Electrode ','');    endif ~isempty(getvalue)    if isfield(C,getvalue);        C = C.(getvalue);    else        C = NaN;    endendfunction [C, ok] = SubCluster(topC,cl, addclst)ok = 1;      if ~isfield(topC,'next')          ok = 0;      elseif length(topC.next) >= cl-1 && isfield(topC.next{cl-1},'mahal')          C = topC.next{cl-1};%fields needed so taht result can be treated just like main result.                    C = CopyFields(C, topC,{'probe' 'exptno' 'chspk' 'exptid' 'sign' 'nspks'});          C.next = {};          if addclst              C = CopyFields(C, topC,{'clst' 't'});          end      elseif cl >= length(topC.next)-1 || ~iscluster(topC.next{cl-1})          ok = 0;          C = [];      end