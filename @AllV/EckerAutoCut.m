function [DATA, details]  = EckerAutoCut(DATA, varargin)usev = 0;retrigger = 0;reapply = 0;explore = 1;combinefits = 1;explorefits = ones(1,10);%%Thoughts% When re-triggering, use template space based on% Templates from last round?%quick auotcut might be improved with FindBestSpace and%then optimize cluster? But this may bias to cells on other probesj = 1;while j <= length(varargin)    if strncmpi(varargin{j},'quick',5)        explore = 0;    elseif strncmpi(varargin{j},'fit',3)        j = j+1;        explorefits = zeros(size(explorefits));        explorefits(varargin{j}) = 1;    elseif strncmpi(varargin{j},'nocombine',5)        combinefits = 0;    elseif strncmpi(varargin{j},'reapply',5)        reapply= 1;        explore = 0;        j = j+1;        C = varargin{j};    elseif strncmpi(varargin{j},'retrigger',5)        retrigger = 1;    end    j = j+1;endaddpath('/b/group/matlab/agb');Vall = AllV.mygetappdata(DATA,'Vall');if isfield(Vall,'t')    Vall.Vtime = Vall.t;    Vall.Fs = 40000;    X.Vtime = Vall.t;    X.Fs = 40000;    if isinteger(Vall.V)        %X.V = double(Vall.V').*Vall.intscale(1)/Vall.intscale(2);    else        X.V = Vall.V;    endendts=now;if retriggerelseif explore    fprintf('Running Kalman Filter cuts');    if explorefits(1)        fits{1} =  TryKalman(DATA, DATA.pcs(:,1:5)',[1 1:5]);        fprintf('...1');        fprintf('(%.1f sec)',mytoc(ts));    end    if explorefits(2)        fits{2} =  TryKalman(DATA, DATA.pcs(:,1:8)',[1 1:8]);        fprintf('...2');        fprintf('(%.1f)',mytoc(ts));    end    if explorefits(3)        fits{3} =  TryKalman(DATA, DATA.pcs(:,1:12)',[1 1:12]);        fprintf('...3');        fprintf('(%.1f)',mytoc(ts));    end    if ~isfield(DATA,'TemplateScores') || size(DATA.TemplateScores,2) < 20        %almost certainly worth more work here - use a quick template, or use        %best cluster from above        fprintf('Calculating Std Template Scores\n');        DATA.usestdtemplates = 1;        DATA = AllV.CalcTemplateScores(DATA);        DATA.cluster.TemplateUsed = DATA.TemplateUsed;        tspaces{1} = [9:16];        tspaces{2} = [1:4 9:12 17:20];    else        tspaces{1} = [1 8 10 15];        tspaces{2} = [9:16];    end    for j = 1:length(tspaces)        tspaces{j} = tspaces{j}(tspaces{j} <= size(DATA.TemplateScores,2));    end    if explorefits(4)        fits{4} =  TryKalman(DATA, DATA.TemplateScores,[3 [1:size(DATA.TemplateScores,2)]]);        fprintf('...4');        fprintf('(%.1f)',mytoc(ts));    end    if explorefits(5)        fits{5} =  TryKalman(DATA, DATA.TemplateScores(:,tspaces{1}),[3 tspaces{1}]);        fprintf('...5');        fprintf('(%.1f)',mytoc(ts));    end    if DATA.cluster.usestdtemplates        id = unique(DATA.tmplots(17:24,:));    else        id = unique(DATA.tmplots(1:8,:));    end    if explorefits(6)        id = intersect(id,1:size(DATA.TemplateScores,2));        fits{6} =  TryKalman(DATA, DATA.TemplateScores(:,id),[3 id(:)']);        fprintf('...6');        fprintf('(%.1f)',mytoc(ts));    end    if explorefits(7)        fits{7} =  TryKalman(DATA, DATA.TemplateScores(:,tspaces{2}),[3 tspaces{2}]);        fprintf('...7');        fprintf('(%.1f)\n',mytoc(ts));    end    %fits{7} =  TryKalman(DATA, DATA.TemplateScores(:,id),[3 1 2]);    if sum(explorefits(1:7))         [fit, details] = AllV.ChooseBestFit(fits,DATA);    else        [fit, details] = AllV.ChooseBestFit(DATA.cluster.autofits(1:7),DATA);    end    if explorefits(8)        [DATA, DATA.cluster] = AllV.SetClusterFromFit(DATA, DATA.cluster, fit);        DATA.usestdtemplates = 0;        DATA.cluster.neednewtemplate = 1;        [DATA, Template] = AllV.CalcTemplateScores(DATA, DATA.cluster.MeanSpike,'keepscores');        id = unique(DATA.tmplots(1:8,:));        fits{8} =  TryKalman(DATA, DATA.TemplateScores(:,id),[3 id(:)']);        fits{8}.Template = Template;        DATA.usestdtemplates = 1;        DATA = AllV.CalcTemplateScores(DATA);        DATA.cluster.TemplateUsed = DATA.TemplateUsed;        [fit, details] = AllV.ChooseBestFit(fits, DATA);    end    for j = 1:length(fits)        if ~isempty(fits{j})            fits{j}.fitnumber = j;        end    end        for j = 1:length(details.scores)        if ~isempty(fits{j})            fits{j}.fitscore = [details.scores(j) details.ascores{1}(j)];        end    end        if sum(explorefits) > 1        if combinefits %wait until this is sorted.            [fits, cdetails] = AllV.CombineFits(DATA,fits,'all');            [allfits, allf] = AllV.CombineFits(DATA, fits, 'expandall');            [fit, details] = AllV.ChooseBestFit(allfits, DATA);            if length(fit.SU) <= 1 && isempty(details.scores) %no fits found a cluster                fprintf('No Kalman Fits found an SU. Trying bgc quick cut\n');                DATA = AllV.QuickAutoCut(DATA);                xy = DATA.xy{1};                fit.clst = DATA.cluster.clst;                [ell.xy, scores, details] = FindEllipse(xy,fit.clst,'cluster',1);                ell = CopyFields(ell,details,{'scores' 'guess'});                ell.allxy = mean(xy);                fit.ellipse = CopySFields(fit.ellipse,2,ell);                dropi = AllV.CalcTriggerDrop(DATA, fit.clst == 2);                fit.dropi(2) = dropi(3);                X.xyr =  ell.xy;                X.clst = fit.clst;                X.angle = ell.xy(5);                [fit.optellipse(2).xy, details] = clust.OptimizeEllipse(X, 'mahaldprimenearsu','xy',xy);                fit.optellipse(2).isolation = details.isolation;                fit.optellipse(2).score = details.score;                fit.SU = [0 1];                fit.isolation(1,:) = DATA.cluster.isolation([2 1 4 3]);                fit.isolation(2,:) = DATA.cluster.isolation;                fit.space{2,2} = DATA.cluster.space;                fit.D(2,2) = DATA.cluster.isolation(1);                fit.nearD(2,2) = DATA.cluster.isolation(3);                fit.space{1,1} = DATA.cluster.space;                fit = rmfields(fit,{'ellipse' 'NDisolation' 'eckercluster'});                fit.bestfit = [length(fits)+1 0];                fit.sortorder = [1 2];                fit.energy = [0 1];                fit.alternatetype = 'quickcut';                x = AllV.CalcTriggerDrop(DATA, fit.clst == 1);                fit.dropi(1) = x(3);                x = AllV.CalcTriggerDrop(DATA, fit.clst == 2);                fit.dropi(2) = x(3);                fits{end+1} = fit;            end        end        DATA.cluster.autofits = CondenseFits(fits);        DATA.cluster.autofits= fits;    else        fiti = find(explorefits > 0);        DATA.cluster.autofits{fiti} = fits{fiti};    end    %      DATA.cluster.autofits = fits; %Each has a clst, wasteful for now, but may want to lookelseif reapply    if C.eckercluster.fitspace(1) == 3        fit = TryKalman(DATA, DATA.TemplateScores(:,C.eckercluster.fitspace(2:end)),C.eckercluster.fitspace);    elseif C.eckercluster.fitspace(1) == 1        fit = TryKalman(DATA, DATA.pcs(:,C.eckercluster.fitspace(2:end)),C.eckercluster.fitspace);    endelse        if DATA.plottype == 3            id = unique(DATA.tmplots(1:8,:));            fits{1} = TryKalman(DATA, DATA.TemplateScores(:,id(1:5))', [3 1:5]);            if isempty(fits{1}.bestscores) && length(id) > 5                fits{2} = TryKalman(DATA, DATA.TemplateScores(:,id)', [3 id(:)']);            else                fits{2} = TryKalman(DATA, DATA.TemplateScores', [3 1:size(DATA.TemplateScores,2)]);            end            fit = AllV.ChooseBestFit(fits, DATA);        else            fit = TryKalman(DATA, DATA.pcs(:,1:8)', [1 1:8],'zscore');        endendDATA.cluster.cluster =1;details.newDATA = 0;[DATA, DATA.cluster,fit] = AllV.SetClusterFromFit(DATA, DATA.cluster, fit);DATA.cluster = AllV.PlotTriggerHist(DATA,DATA.cluster,'fitall');DATA.cluster.eckercluster.dropi(1,:) = DATA.cluster.hashdropi;cls = unique(DATA.cluster.clst);if sum(cls==2)    DATA.cluster.eckercluster.dropi(2,:) = DATA.cluster.dropi;endfor j = 1:length(DATA.cluster.next)    if isfield(DATA.cluster.next{j},'dropi')        DATA.cluster.eckercluster.dropi(end+1,:) = DATA.cluster.next{j}.dropi;    endendDATA.usegmcid = 1;  %plot results according to GM clustering%DATA.cluster.space(1) = 14DATA.cluster.shape = 3;function fits = CondenseFits(F)fields = {'params' 'mu_t' 'mu' 'C' 'Cmu' 'priors' 'df' };cfields = {'Y' 't' 'train' 'test'};for j = 1:length(F)    for k = 1:length(fields)        f = fields{k};        if iscell(F)            if isfield(F{j},'eckercluster') && isfield(F{j}.eckercluster,'fit')                fits(j).eckercluster.fit.(f) = F{j}.eckercluster.fit.(f);            end        else            fits(j).(f) = F(j).(f);        end    endendfunction K = TryKalman(DATA, S, space, varargin)K = [];dozscore = 0;if DATA.interactive > 0    verbose = 'Neutral';else    verbose = 'Silent';endj = 1;while j <= length(varargin)    if strcmp(varargin{j},'zscore')        dozscore = 1;    end    j = j+1;endif diff(size(S)) < 0    S = S';endif dozscore    S = zscore(S);endsx = std(S,[],2);id = find(~isnan(sx) & sx > 0); %remove empty rowsS = S(id,:);K.exptno = DATA.exptno;K.probe = DATA.probe;K.fitspace = [space(1) space(id+1)];[S, K] = RemoveRedundantDims(S, K, 0.9);ev = eig(cov(S'));if min(ev) < 0    K = AddError(K, DATA, 'Negative Eigenvalues');    [S, K] = RemoveRedundantDims(S, K, 0.8);endtry    lastwarn('','');    DATA.usegmcid = 1;    %might wadnt to try 'blocksize' arg too    [a,b,c] = MoKsm_agb(S, verbose);        if strncmp(lastwarn,'Matrix is close to singular',27)        [S, K] = RemoveRedundantDims(S, K, 0.8);        lastwarn('','');        nc(1) = length(unique(a));        [a,b,c] = MoKsm_agb(S, verbose);        nc(2) = length(unique(a));        if strncmp(lastwarn,'Matrix is close to singular',27)            K = AddError(K,DATA,'Singular Matrix');        else            K = AddError(K,DATA,'Initially Singular Matrix (%d ->%d clusters)',nc);        end    end%make sure cl=1 is MU if poss, to be like manual %if all SU or all NOT SU, find probably mu    if ~sum(c.SU ==0) || ~sum(c.SU ==1)  %something is probably mu. Make most likely candidate 1        [a,c, energy] = SetClusterOrder(a,c,DATA);    elseif sum(c.SU ==1) == 1 && sum(c.SU ==0) ==1 %check for switch        [a,c, energy] = SetClusterOrder(a,c,DATA);    else        [a,c,energy] = SetClusterOrder(a,c,DATA);    end    %might need another test one day of what is the MU cluster......    if  ~isempty(c.SU) && c.SU(1) == 1 && sum(c.SU ==0)        checksu = 0;  %This test seems to cause trouble. SU is sometimes 1 for real MU        if checksu            mu = find(c.SU ==0);            id = find(a == mu(1));            a(a == 1) = mu(1);            a(id) = 1;            c.SU(1) = 0;            c.SU(mu(1)) = 1;            e = energy(mu(1));            energy(mu(1)) = energy(1);            energy(1) = e;            K = AddError(K,'Cl1 was SU. Swapped with %d',mu(1));        else            fprintf('Cluster 1 is SU according to mo_ksm\n');        end    end    K.energy = energy;    if DATA.interactive > 0        fprintf('Finding Best spaces by Mahal distance..');    end    DATA.gmcid = a;    C = DATA.cluster;    C.next = {};    C.space = space;    state.verbose = verbose;    X = AllV.CalcMyDistanceMatrix(DATA,C,state.verbose,'nearmahal');    K.D = X.D;    K.nearD = X.nearD;    K.bestscores = X.bestscores;%    X.space is an NxN matrix of spaces for isolation% of cl(j) vs cl(k). The diagnonal is cl(j) vs all others    K.space = X.space;    K.SU = c.SU;    K.eckercluster = c;    K.clst = a;    K.isolation = X.isolation; %Cell vs rest for each cell, in its space    cls = unique(a);%Also calculate isolation in and ND space        for j = cls(:)';        K.NDisolation(j,:) = CalcIsolation(S',a,j);        xid = X.space{j,j}(2:3);        if space(1) == 1            xy = DATA.pcs(:,xid);        elseif space(1) == 3            xy = DATA.TemplateScores(:,xid);        end        if length(cls) ==1            K.ellipse.xy = [NaN NaN NaN NaN NaN];            K.optellipse.xy = [NaN NaN NaN NaN NaN];        else            [ell.xy, scores, details] = FindEllipse(xy,K.clst,'cluster',j-1);            ell = CopyFields(ell,details,{'scores' 'guess'});            ell.allxy = mean(xy);            K.ellipse(j) = ell;            dropi = AllV.CalcTriggerDrop(DATA, K.clst == j);            K.dropi(j) = dropi(3);            X.xyr =  ell.xy;            X.clst = K.clst;            X.angle = ell.xy(5);            [K.optellipse(j).xy, details] = clust.OptimizeEllipse(X, 'mahaldprimenearsu','xy',xy);            K.optellipse(j).isolation = details.isolation;        end    end    K = SortByDistance(K,'energy');    K.clst = int16(K.clst);    if length(cls) == 1        K.lratio = NaN;        K.isolation_distance = NaN;    else        [K.lratio, K.isolation_distance] = AllV.CalcLRatio(S', [], K.clst);    end    K.fitdate = now;    if DATA.interactive > 0        fprintf('\n');    endcatch ME    cprintf('red','Error Doing Kalman Filter cut on probe %d\n',DATA.probe);    CheckExceptions(ME);    K.clst = ones(size(DATA.pcs,1),1);    K.eckercluster.type1 = [NaN NaN];    K.eckercluster.type2 = [NaN NaN];    K.eckercluster.SU=0;    K.D = [];    K.bestscores = [];    K.isolation = [];    K.SU = [];end%Sorting by meanspike energy might produce more consistent results...%do not change cluster 1 - MU is function fit = SortByDistance(K, varargin)[a,b] = sort(K.bestscores(2:end),'descend');j = 1;while j <= length(varargin)    if strcmp(varargin{j},'energy') && isfield(K,'energy')        [a,b] = sort(K.energy(2:end),'descend');    end        j = j+1;endb = [1 1+b];fit = K;fit.space = K.space(b,b);fit.isolation = K.isolation(b,:);f = {'bestscores' 'SU' 'ellipse' 'optellipse' 'dropi' 'energy' 'lratio' 'isolation_distance'};for j = 1:length(f)    if isfield(fit,f{j})        fit.(f{j}) = K.(f{j})(b);    endendfit.NDisolation = K.NDisolation(b,:);fit.eckercluster.sortorder = b;did = sub2ind(size(K.D),b,b);fit.D = remapMatrix(K.D,b);for j = 1:length(fit.SU)    fit.clst(K.clst == b(j)) = j;endfunction R = remapMatrix(M,o)R = M;for j = 1:size(M,1)    R(j,:) = M(o(j),o);endfunction [a,cout, energy] = SetClusterOrder(a,c,DATA)     cout = c;     E = sum(DATA.energy(ismember(DATA.eprobe,DATA.probe),:),1);     Eb = sum(DATA.energy(ismember(DATA.eprobe,setdiff(DATA.chspk,DATA.probe)),:),1);     for j  = 1:length(unique(a));         sid = find(a== j);         ctrig(j) = nanmean(DATA.rV(sid));         energy(j) = nanmean(E(sid));         oenergy(j) = nanmean(Eb(sid));     end%really want energy dominated by the trigger probe.      energy = (energy./mean(energy)) + (oenergy./(3*mean(oenergy)));     [mintrig,mu] =  min(energy);     if mu ~= 1         sid = find(a==1);         a(a == mu) = 1;         a(sid) = mu;         e = energy(mu);         energy(mu) = energy(1);         energy(1) = e;         cout.SU(1) = c.SU(mu);         cout.SU(mu) = c.SU(1);     endfunction [S, K] = RemoveRedundantDims(S, K, cmaxcrit)         C = cov(S');for j = 1:size(C,1)    for k = 1:j-1        ccoeff(j,k) = C(j,k)./(sqrt(C(j,j) * C(k,k)));        ccoeff(k,j) = ccoeff(j,k);    endend[cmax,b] = max(ccoeff(:));K.corrmax(1) = cmax;rmid = [];while cmax > cmaxcrit    [a,b] = ind2sub(size(ccoeff),b);    rowscores = sum(ccoeff(:,[a b]));    if diff(rowscores) > 0        rmid(end+1) = b;    else        rmid(end+1) = a;    end    corrs(length(rmid)) = cmax;    ccoeff(rmid(end),:) = 0;    ccoeff(:,rmid(end)) = 0;    [cmax,b] = max(ccoeff(:));endK.corrmax(2) = cmax;if ~isempty(rmid)    K.redundantdims = K.fitspace(rmid+1);    fprintf('%s Eliminating %d redundant dimensions of %d:',AllV.IDStr(K),length(rmid),length(K.fitspace)-1);    for j = 1:length(rmid)        fprintf(' %d (%.2f)',K.fitspace(rmid(j)+1),corrs(j));    end    fprintf(' next %.2f\n',cmax);    K.fitspace(rmid+1) = [];    S(rmid,:) = [];end