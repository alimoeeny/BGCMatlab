function [Scores, T, details] = CalcScores(DATA, MeanSpike)%[Scores, T, details] = CalcScores(DATA, MeanSpike)%Scores is a M probes * N events% this need to be modified to work like AllV.TemplatePlot now, with%T being for all probes, but only calculating scores for chspk details.tstart = now;if isfield(MeanSpike,'crosscluster') && MeanSpike.crosscluster > 0    needdprime = 0;else    needdprime = 1;end    AllVoltages = AllV.mygetappdata(DATA,'AllVoltages');if isfield(MeanSpike,'ms')    T = MeanSpike.ms;    if isfield(MeanSpike,'mu')        mT = MeanSpike.mu;    else        mT = T;    endelse    T = MeanSpike;endtrigpt = find(DATA.spts ==0);npts = size(T,2);if isfield(MeanSpike,'othermeans')  && sum(size(MeanSpike.othermeans{1}) == size(MeanSpike.ms)) > 1    oT = MeanSpike.othermeans;else    oT{1} =T;    endfor j = 1:length(oT)    sz = size(oT{j});    if npts > sz(2)        oT{j}(:,sz(2):npts) = 0;    elseif npts < sz(2)        oT{j} = oT{j}(:,1:npts);    endenddetails.otherTemplate = oT;   [dspk, csdspk] = AllV.UseProbeList(DATA, 'dvdy');        if DATA.usestdtemplates        if DATA.usestdtemplates ==1            MeanSpike = DATA.StdTemplate;        else            T = DATA.AltTemplates;            tpt = 9; %default            MeanSpike = zeros(length(T),size(AllVoltages,2));            for j = 1:length(T)                for k = 1:size(T{j},1)                    MeanSpike(j,tpt+T{j}(k,1)) = T{j}(k,2);                end                MeanSpike(j,:) = MeanSpike(j,:) - mean(MeanSpike(j,:))            end        end        if size(MeanSpike,2) > size(AllVoltages,2);%should erally adjust here for trigger point                        MeanSpike = MeanSpike(:, 1:size(AllVoltages,2));        end        j = DATA.probe(1);        ispk = j;        ns = size(MeanSpike,1);        details.ntemplates = ns;        for j = 1:length(DATA.chspk);                        ispk = DATA.chspk(j);            meanV = repmat(mean(AllVoltages(ispk,:,:),2),[1  size(AllVoltages,2) 1]);            for k = 1:size(MeanSpike,1)                Scores(j,k,:) = MeanSpike(k,:) * squeeze(AllVoltages(ispk,:,:) - meanV);                Scores(j,k+ns,:) = squeeze(diff(MeanSpike(k,:),1,2)) * squeeze(diff(AllVoltages(ispk,:,:),1,2));            end        end        if needdprime            id = find(DATA.clst ==2);            nid = find(DATA.clst ~=2);            for j = DATA.chspk(:)'                dp = (T(j,:)-mT(j,:))./sqrt(mean([var(AllVoltages(j,:,nid),[],3) var(AllVoltages(j,:,id),[],3)]));                details.vdprime(j,:) = dp;            end        else            details.dprime = zeros(length(DATA.chspk),size(T,2));        end        details.endtime = now;        return;    end    if size(AllVoltages,1) > 2        if size(AllVoltages,1) < max(csdspk) && DATA.loadfromspikes            AllVoltages(max(csdspk),end,end) = 0;        end%if a channel is zero in the template used, means it was not in the data% - becuase template was done with swatches only.%set this to zero before calculating dv    nid = find(sum(T(dspk,:)') == 0);    if ~isempty(nid)        x = AllVoltages;        x(dspk(nid),:,:) = 0;        dv = diff(x(dspk,:,:),1,1);    else        dv = diff(AllVoltages(dspk,:,:),1,1);    end    mdv = diff(T(dspk,:,:),1,1); %dvdt for template    omdv = diff(oT{1}(dspk,:,:),1,1); %dvdt for alternate template    csd = diff(AllVoltages(csdspk,:,:),2,1);    mcsd = diff(T(csdspk,:,:),2,1);    end%    meanV = repmat(mean(AllVoltages(DATA.chspk,:,:),2),[1  size(AllVoltages,2) 1]);    vid = 1:min([size(T,2) size(AllVoltages,2)]); %% in case old cut used different range    %but using indices makes calculatins slower, so only do this if    %necessary.    if size(T,2) ~= size(AllVoltages,2)        sizediff = 1;    else        sizediff = 0;    end%does meanV need to know about vid?        for j = 1:length(DATA.chspk)        c = DATA.chspk(j);        meanV = repmat(squeeze(mean(AllVoltages(c,:,:),2))',[size(AllVoltages,2) 1]);        AllVs{j} = squeeze(AllVoltages(c,:,:)) - meanV;    end        Scores = zeros(length(DATA.chspk),7+length(oT)+1,DATA.nevents);    for j = 1:length(DATA.chspk)        c = DATA.chspk(j);        if size(AllVoltages,1) > 2        Scores(j,3,:) = squeeze(mdv(j,:)) * squeeze(dv(j,:,:));%sometimes, when using spikes loaded from one probe and a templated defined%from a different proebe, can end up with not enough csd channels%e.g. clust.AlignAutoFits([45 1 1; 44 2 1]) pprM034        if j <= size(csd,1)            Scores(j,4,:) = squeeze(mcsd(j,:)) * squeeze(csd(j,:,:));        else            Scores(j,4,:) = zeros(1,size(csd,3));        end        Scores(j,1+7+length(oT),:) =  squeeze(mdv(j,:)) * squeeze(dv(j,:,:));        end        if sizediff            sV = T(c,vid) - mean(T(c,vid));            mV = mT(c,vid) - mean(mT(c,vid));            Scores(j,2,:) = squeeze(diff(T(c,vid),1,2)) * squeeze(diff(AllVoltages(c,vid,:),1,2));            for k = 1:length(oT)                oV = oT{k}(c,vid) - mean(oT{k}(c,vid));                Scores(j,k+7,:) =  squeeze(oV) * AllVs{j};            end        else            sV = T(c,:) - mean(T(c,:)); %mean spike, probe c            mV = mT(c,:) - mean(mT(c,:)); %mean mu, probe c            Scores(j,2,:) = squeeze(diff(T(c,:),1,2)) * squeeze(diff(AllVoltages(c,:,:),1,2));            for k = 1:length(oT)                oV = squeeze(oT{k}(c,:) - mean(oT{k}(c,:)));                Scores(j,k+7,:) =  oV * AllVs{j};            end        end        Scores(j,1,:) = squeeze(sV) * AllVs{j};        Scores(j,6,:) =  squeeze(mV) * AllVs{j};        Scores(j,7,:) = sum(abs(repmat(sV',1,size(AllVoltages,3)) - AllVs{j}));        dpcrit = 1;        if size(MeanSpike.vdprime,1) >= c            dp = MeanSpike.vdprime(c,:);            id = find(abs(dp) > dpcrit);%Temlatescore5(:,5,:) is different, using sign(dp); Templatescores(3) is%like Scores(5). see below            if length(id)                Scores(j,5,:) = sign(dp(id)) * squeeze(AllVoltages(c,id,:));            else                [a,b] = sort(dp,'descend');                id = b(1:2);                Scores(j,5,:) = sign(dp(id)) * squeeze(AllVoltages(c,id,:));            end%            TemplateScores(k,3,:) = squeeze(dp(j,:)) * squeeze(AllVoltages(j,:,:) - repmat(mu(j,:),[1 1 DATA.nevents]));            Scores(j,5,:) = dp * squeeze(AllVoltages(c,:,:) - repmat(mV,[1 1 DATA.nevents]));        else        Scores(j,5,:) = 0;        end    end    if length(DATA.chspk) == 1        meanV = repmat(mean(AllVoltages(j,:,:),2),[1  size(AllVoltages,2) 1]);        if size(AllVoltages,2) < size(DATA.StdTemplate,2)            tid = 1:size(AllVoltages,2);        else            tid = 1:size(DATA.StdTemplate,2);        end        Scores(1,3,:) = DATA.StdTemplate(1,tid) * squeeze(AllVoltages(DATA.chspk,:,:) - meanV);        Scores(1,4,:) = DATA.StdTemplate(2,tid) * squeeze(AllVoltages(DATA.chspk,:,:) - meanV);        Scores(1,6,:) = MeanSpike.mu(DATA.chspk,:) * squeeze(AllVoltages(DATA.chspk,:,:) - meanV);;        Scores(1,7,:) = DATA.rV;        Scores(1,8,:) = squeeze(diff(DATA.StdTemplate(1,tid),1,2)) * squeeze(diff(AllVoltages(j,:,:),1,2));        Scores(1,9,:) = squeeze(diff(DATA.StdTemplate(2,tid),1,2)) * squeeze(diff(AllVoltages(j,:,:),1,2));    elseif length(DATA.chspk) == 2        Scores(1,12,:) = csd(1,trigpt,:);    else        Scores(1,12,:) = csd(2,trigpt,:);    end    if 0 %old way. Might want this back. Now store all channels (so can use CSD of template)        T = T(DATA.chspk,:);    end    details.endtime = now;