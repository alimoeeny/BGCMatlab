function M = CalcMyDistanceMatrix(DATA, C, varargin)%Given classsification, calculated mahal separations for all%pairs/direcioncsverbose = 'quiet';isolationtest = 'default';argon = {};j = 1;while j <= length(varargin)    if strncmpi(varargin{j},'nearmahal',5)        isolationtest = varargin{j};    elseif strncmpi(varargin{j},'verbose',5)        verbose = varargin{j};    else         argon = {argon{:} varargin{j}};    end    j =j+1;end    p= DATA.probe(1);    AllVoltages = AllV.mygetappdata(DATA,'AllVoltages');    uid = DATA.uid;       ntr = 1;    M.errs = {};    M.errdata = [];    M.space = {};        if DATA.usegmcid        cls = unique(DATA.gmcid);    else        cls = unique(DATA.clst);    end    cls = cls(cls > 0); for j = 1:length(cls)     M.D(j,j) = NaN; end  if length(cls) ==1 %all mu     M.space{1,1} = C.space(1:3); end  %diagonal is cluster against rest subspace = [];durs = []; for j = 1:length(cls)     b = cls(cls ~= cls(j));     a = AllV.FindBestSpace(DATA,C,'clusters',j,b,isolationtest,argon{:});     if strcmp(isolationtest,'nearmahal')%even though optimize with nearest neighbor metric, use real%mahal distance as the final measure.  ?Dangerous.......         M.D(j,j) = a.isolation(1);         xid = 3;     else         M.D(j,j) = a.isolation(1);         xid = 1;     end     M.nearD(j,j) = a.isolation(3);     M.isolation(j,:) = a.isolation;     M.space{j,j} = a.space;     if isfield(a,'quickisolation') %for comparing methods         M.quickisolation(j,:) = a.quickisolation;         M.quickspace{j} = a.quickspace;         s = sprintf('Best space methods cl%d %.2f/%.2f %.2f/%.2f',j,M.isolation(j,1),M.quickisolation(j,1),M.isolation(j,3),M.quickisolation(j,3));         if M.isolation(j,xid) > M.quickisolation(j,xid) * 1.1             cprintf('red','%s\n',s)         elseif M.isolation(j,xid)  < M.quickisolation(j,xid) && length(a.quickspace) <= length(a.space)-1             fprintf('??%s\n',s)         end     end     if isfield(a,'dur')         durs = [durs; a.dur];     end     ns = min([4 length(a.space)]);     subspace = [subspace a.space(2:ns)]; end %subspace is all the dimensions used for each clsuter vs rest. %restrict space for pairwise distances measrues to this. subspace = unique(subspace);if ~isempty(durs)    durs = sum(durs);    fprintf('Durs %.2f,%.2f %d dimenstions\n',durs,a.ndims)end  for j = 2:length(cls)     for k = 1:j-1         a = AllV.FindBestSpace(DATA,C,'clusters',j,k,'subspace',subspace,argon{:});         M.D(j,k) = a.isolation(1);         M.D(k,j) = a.isolation(2);         M.nearD(j,k) = a.isolation(3);         M.nearD(k,j) = a.isolation(4);         M.space{j,k} = a.space;         M.space{k,j} = a.space;     end%     a = AllV.FindBestSpace(DATA,C,'clusters',k,k); end  M.bestscores = max([min(M.D'); min(M.D)]);