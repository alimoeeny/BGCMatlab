function DATA = ClassifyAll(DATA, force,varargin)    AllV.mysetappdata(DATA,'TriggerHistPlotted',0);replot = 0;recluster = 1;    quickcutmode.quick = 0;    cargs = {};    j = 1;    while j <= length(varargin)        if strncmpi(varargin{j},'quick',5)            quickcutmode = DATA.quickcutmode;            quickcutmode.quick = 1;            cargs = {cargs{:} quickcutmode};        elseif strncmpi(varargin{j},'replot',5)            replot = 1;        elseif strncmpi(varargin{j},'recluster',5)            recluster = 1;            cargs = {cargs{:} varargin{j}};        end        j = j+1;    end    if DATA.cluster.auto && strncmp(DATA.cluster.autocutmode,'ecker',5);        if isfield(DATA.cluster,'clst')            DATA.clst = DATA.cluster.clst;        end        for j = 1:length(DATA.cluster.next)            if isfield(DATA.cluster.next{j},'xy')                DATA.xy{j+1} = DATA.cluster.next{j}.xy;            end        end%If we have created a new fit, add quantification                if isfield(DATA.cluster.eckercluster,'combinecls')            DATA.cluster = clust.Quantify(DATA, DATA.cluster, [],'nearmahal');        end        DATA.clid = find(DATA.clst == 2);        DATA.nid = find(DATA.clst ~= 2);        return;    end    DataClusters = AllV.mygetappdata(DATA,'Clusters');    if DATA.interactive >= 0        oldname = get(DATA.toplevel,'Name');        set(DATA.toplevel,'Name','Classifying...');        drawnow;    end    if isfield(DATA.cluster,'ctime')        ctimes(1) = DATA.cluster.ctime;    else        ctimes(1) = now;    end    if isfield(DATA.cluster,'crit') && isnan(DATA.cluster.crit) %1 was deleted        iscluster(1) = 0;    else        iscluster(1) = 1;    end    if isfield(DATA.cluster,'triggerset')        triggerset(1) = DATA.cluster.triggerset;    else        triggerset(1) = 0;    end    e = DATA.cluster.exptno;    for j = 1:length(DATA.cluster.next)        if isfield(DATA.cluster.next{j},'ctime')            ctimes(j+1) = DATA.cluster.next{j}.ctime;        else            if isempty(DATA.cluster.next{j})                ctimes(j+1) = 0;            else                errordlg(sprintf('Missing ctime Cluster %d E%.1f',j+1,e),'Cluster Cut Time','modal');                ctimes(j+1) = j+1;            end        end        if isfield(DATA.cluster.next{j},'space') && DATA.cluster.next{j}.triggerset == DATA.triggerset            iscluster(j+1) = 1;        else            iscluster(j+1) = 0;        end        if isfield(DATA.cluster.next{j},'triggerset')            triggerset(j+1) = DATA.cluster.next{j}.triggerset;        else            triggerset = 0;        end    end    cls = 1:(1+length(DATA.cluster.next));    cls = cls(ctimes>0 & iscluster > 0 & triggerset == DATA.triggerset);    ctimes = ctimes(cls);    [a, tlist] = sort(ctimes);    tlist = cls(tlist);    cc = DATA.currentcluster;    if ~isfield(DATA.cluster,'chspk')        DATA.cluster.chspk = DATA.chspk;    end        if recluster && force > 0 %clear all existing assignments        DATA.clst = ones(size(DATA.clst));    end        if DATA.cluster.space(1) == 6        [DATA.ndxy, DATA.gmcid] = AllV.ProjectND(DATA, DATA.cluster.space(2), DATA.cluster.gmfit);        DATA.cluster.bestcl = DATA.gmcid;    end    if isfield(DATA.cluster,'TemplatePC')        DATA.TemplatePC = DATA.cluster.TemplatePC;    end    autorefine = 0;    for j = 1:length(tlist)        needcl = AllV.NeedClusterData(DATA.cluster,tlist(j));        DATA.currentcluster = tlist(j);        if force            DATA = AllV.SetTemplateData(DATA,tlist(j));        end        DATA.cluster = AllV.CheckScoreScaling(DATA, DATA.cluster);        if tlist(j) == 1            DATA.currentcluster = 1;%needcl == 2 means that already classified, but fits not done. If force is%on, the cut is going to be redone anyway            if needcl == 2  && force == 0                if DATA.interactive > 0                    set(DATA.toplevel,'Name',sprintf('Quantifying Cluster %d...',tlist(j)));                    drawnow;                end                DATA.cluster = AllV.ClassifyFit(DATA, DATA.cluster,1);            elseif force || needcl                if DATA.interactive > 0                    set(DATA.toplevel,'Name','Classifying Cluster 1...');                    drawnow;                end%if autorefine, then will have to claissfy twice if ther are > 1clusters.%So on first pass, only do the quck classif. But set quick to zero so that%the second time it treated as new.%if fitdprime is NaN i tmeans cluster was empty - really needs refining                if DATA.autorefine > 0 && isfield(DATA.cluster,'fitdprime') && ...                    (DATA.cluster.fitdprime(1) < -DATA.autorefine  || isnan(DATA.cluster.fitdprime(1)))                    [cl, cluster, DATA.xy{1}] = AllV.ClassifySpikes(DATA,DATA.cluster,'quick','noplot');                    cluster.quick = 0;                    DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],cluster, DATA.currentcluster));                    DATA.cluster.clst = cl.clst;                    DATA = AllV.OptimizeBoundary(DATA);                    cluster = DATA.cluster;                    autorefine = autorefine+1;                elseif DATA.cluster.auto && strcmp(DATA.cluster.autocutmode,'james')                    DATA = AllV.JamesAutoCut(DATA,'reapply', DATA.cluster);                    cl.id = find(DATA.clst == DATA.cluster.cluster+1);                    cl.nid = find(DATA.clst ~= DATA.cluster.cluster+1);                    cl.clst = DATA.clst;                    cl.MeanSpike = AllV.PlotMeanSpike(DATA,'recalc');                    cluster = DATA.cluster;                    DATA.plottype = 13;                else                    [cl, cluster, DATA.xy{1}] = AllV.ClassifySpikes(DATA,DATA.cluster,cargs{:},'noplot','notrig');                    if DATA.userefcluster                        refcorr = AllV.CompareMeans(cluster,DATA.cluster);                        cluster.refshapecorr = refcorr.xcorrs;                    end                    DataClusters{DATA.probe(1)}.mahal = cluster.mahal;                    DATA.clusterboundary{DATA.currentcluster} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],cluster, DATA.currentcluster));                end                DATA.clid = cl.id;                DATA.nid = cl.nid;                DATA.clst = cl.clst;                if length(cl.id) > 1 && DATA.autorefine == 0                    if quickcutmode.quick == 1                         cl.MeanSpike = DATA.cluster.MeanSpike;                    end                    DATA.MeanSpike = cl.MeanSpike;                    DATA.cluster = cluster;                    DATA.cluster.MeanSpike = cl.MeanSpike;                    if size(DATA.energy,2) >= max(DATA.clid)                        DATA.cluster.minspke = prctile(DATA.energy(1,DATA.clid),1) .* 0.95;                        DATA.cluster.minspkvar = prctile(DATA.spkvar(DATA.probe(1),DATA.clid),1) .* 0.95;                    end                    DATA.cluster.ctime = now;                elseif length(cl.id) <= 1                    DATA.cluster = cluster;                end                if DATA.userefcluster && ~strcmp(DATA.refinemode,'none')                    DATA = AllV.OptimizeBoundary(DATA);                    if DATA.interactive >= 0                        AllV.ReplotPCs(DATA,[]);                    end                end                if DATA.cluster.mahal(4) < 0.001 && quickcutmode.quick == 0                    c = AllV.PlotHistogram(DATA, []);                    DATA.cluster.mahal(4) = c.gmdprime;                end            end        elseif isfield(DATA.cluster.next{tlist(j)-1},'space')            if needcl == 2 && force == 0                if DATA.interactive > 0                set(DATA.toplevel,'Name',sprintf('Quantifying Cluster %d...',tlist(j)));                drawnow;                end                DATA.cluster.next{tlist(j)-1} = AllV.ClassifyFit(DATA, DATA.cluster.next{tlist(j)-1},tlist(j));            elseif force || needcl                if DATA.interactive > 0                set(DATA.toplevel,'Name',sprintf('Classifying Cluster %d...',tlist(j)));                drawnow;                end            DATA.currentcluster = tlist(j);            if DATA.autorefine > 0 && DistanceMeasure(DATA.cluster.next{tlist(j)-1},'fitdprime') > DATA.autorefine                [xcl, DATA.cluster, DATA.xy{tlist(j)}] = AllV.ClassifySpikes(DATA,DATA.cluster,'quick','noplot','notrig');                DATA = AllV.OptimizeBoundary(DATA);                autorefine = autorefine+1;            else                [xcl, DATA.cluster, DATA.xy{tlist(j)}] = AllV.ClassifySpikes(DATA,DATA.cluster,'noplot', 'notrig',cargs{:});            end            if ~isempty(xcl)                DATA.clst = xcl.clst;            end            if DATA.cluster.next{tlist(j)-1}.mahal(4) < 0.001 && quickcutmode.quick == 0                c = AllV.PlotHistogram(DATA, [], quickcutmode);                DATA.cluster.next{tlist(j)-1}.mahal(4) = c.gmdprime;            end            %            DATA.cluster.next{tlist(j)-1}.ctime = now;            if isfield(xcl,'MeanSpike') %%may not be true on first "quick" pass            DATA.cluster.next{tlist(j)-1}.MeanSpike = xcl.MeanSpike;            end            DATA.clusterboundary{tlist(j)} = AllV.CondenseCluster(AllV.BoundaryFromCluster([],DATA.cluster, tlist(j)));            end        end%if only calculating metrics, don't call this               if DATA.iteratefit && DATA.autorefine > 0 && (needcl == 1 || force)              AllV.IterateFit(DATA, DATA.iteratefit);              DATA = get(DATA.toplevel,'UserData');        end        if DATA.watchplots && (needcl || force) && quickcutmode.quick == 0            AllV.PlotHistogram(DATA, []);            try %plot can be a problem if reclassifying an old cluster with missing fields                AllV.ReplotPCs(DATA,[]);            end        end    end%Unrefined Cluster N can steal events from refined cluster N-1, so need to appl one more time %and need to call Classify again anyway to apply refined bounday.%Also set cluster.times in each Cluster now for the same reason    DATA = AllV.mysetappdata(DATA,'Clusters',DataClusters);    if autorefine %no apply refined cluster        DATA.autorefine = 0;        DATA = AllV.ClassifyAll(DATA,1);        DATA.cluster.autorefine = 1; %was in fact refined        DATA.autorefine = 1;    end    %    quantify dropi for other clusters    if quickcutmode.quick == 0 || quickcutmode.dropi        for j = 1:length(DATA.cluster.next)            if ~isempty(DATA.cluster.next{j})                cluster = AllV.PlotTriggerHist(DATA,DATA.cluster.next{j},quickcutmode);                DATA.cluster.next{j}.vhist = cluster.vhist;                DATA.cluster.next{j}.dropi = cluster.dropi;                DATA.cluster.next{j}.times = DATA.t(DATA.clst == j+2);            end        end    end    if quickcutmode.quick == 0 || quickcutmode.mean        DATA.cluster.MeanSpike = AllV.PlotMeanSpike(DATA, 'cluster', 1, 'recalc');        for j = 1:length(DATA.cluster.next)            if ~isempty(DATA.cluster.next{j})                DATA.cluster.next{j}.MeanSpike = AllV.PlotMeanSpike(DATA, 'cluster',j+1, 'recalc');            end        end    end    DATA.cluster = AllV.PlotTriggerHist(DATA,DATA.cluster,'showall',quickcutmode);    if DATA.watchplots > 1        drawnow;    end    DATA.cluster.times = DATA.t(DATA.clst == 2);    DATA.cluster.ncut = length(DATA.cluster.times);    for j = 1:length(DATA.cluster.next)        if isfield(DATA.cluster.next{j},'space')            DATA.cluster.next{j}.times = DATA.t(DATA.clst == j+2);            DATA.cluster.next{j}.ncut = length(DATA.cluster.next{j}.times);        end    end    DATA.currentcluster = cc;    DATA.clid = find(DATA.clst == cc+1);    if DATA.checkclusters        AllV.CheckClusters(DataClusters, 'CheckNexts','Classify');        AllV.CheckClusters(DataClusters,'CheckFitSpace');    end    if replot        DATA = AllV.ReplotPCs(DATA,[]);        AllV.QuickSpks(DATA, DATA.plot.nquickspks);    end    if DATA.interactive >= 0        set(DATA.toplevel,'UserData',DATA);        set(DATA.toplevel,'Name',oldname);    end    DATA.endtime = now;